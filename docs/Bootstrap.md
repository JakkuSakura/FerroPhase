# Bootstrap Strategy

## Objective
- Allow FerroPhase to bring up a useful subset of the toolchain without cloning its full crate graph, by swapping externally hosted stages (parsers, optimizers, backends) with simpler local shims or precomputed JSON inputs.
- Focus on pieces that already live in this repository (`fp-core`, AST transforms, diagnostics) and identify how far we can progress before we need dependencies such as `syn`, `tree-sitter`, `swc`, or LLVM toolchains.
- Drive this mode via a `bootstrap` cargo feature plus a runtime environment variable (e.g. `FERROPHASE_BOOTSTRAP=1`) so the existing `fp` binary can switch behaviour without a bespoke bootstrap executable.

## Executive Summary
- **Viable today:** Loading and manipulating AST/HIR structures, running limited intrinsic rewrites, and emitting diagnostics can be made self-contained with modest work (feature flags, alternate storage types).
- **Needs shims:** Type inference, const-eval, and closure lowering lean on `syn` (for parsing embedded Rust fragments) and shared caches built on `dashmap`. Replacing these by reading pre-typed JSON snapshots is feasible but requires new plumbing.
- **Out of reach for bootstrap:** Source-language frontends (`fp-rust`, `fp-typescript`, `fp-python`, etc.) and LLVM/TypeScript/C# backends require large external libraries. For a self-hosted bootstrap we must treat their outputs as data inputs generated by a “stage 0” toolchain.

## Current Dependency Surface

| Pipeline Stage | Primary Crates | Key External Dependencies | Bootstrap Impact |
| -------------- | -------------- | ------------------------- | ---------------- |
| Source parsing / LAST | `fp-lang`, `fp-rust`, language frontends | `syn`, `tree-sitter`, `swc`, `cargo-metadata`, language runtimes | Cannot run without network-only crates; must ingest AST from JSON instead. |
| AST storage & diagnostics | `fp-core`, `fp-cli` (diagnostics) | `serde`, `dashmap`, `derive_more`, `miette`, `tracing` | Replace `dashmap` with `HashMap` on a `bootstrap` feature; keep `serde` (already vendored via crates.io snapshot) or bake a minimal serializer. |
| Typing & const-eval | `fp-typing`, `fp-interpret`, `fp-optimize` | `syn`, `proc-macro2`, `dashmap`, `tokio` (through CLI), `serde_json` | Gate parsing helpers; allow injecting pre-typed AST/const snapshots to skip `syn`. Need single-threaded context alternative. |
| Backends (LLVM, TS, etc.) | `fp-llvm`, `fp-typescript`, `fp-python`, `fp-csharp`, `fp-zig`, `fp-wit` | `llvm-ir`, system LLVM/clang, `swc`, language printers | Treat outputs as precomputed JSON/IR blobs; bootstrap mode only verifies AST transformations or transpiles via simplified emitters. |
| CLI orchestration | `fp-cli` | `clap`, `tokio`, `indicatif`, `miette` | For bootstrap, ship a tiny driver (no async, minimal CLI) or expose library entrypoints callable from an external script. |

## Bootstrap-Friendly Building Blocks

### Core data model
- `fp-core`’s AST/HIR/LIR structures already derive `Serialize`/`Deserialize`. Add a `bootstrap` cargo feature that:
  - switches `DashMap`-backed contexts in `context.rs` to plain `HashMap` + `RefCell`,
  - gates out `tree-sitter` exports in `cst::ts`,
  - bundles a lightweight `AstSerializer`/`Deserializer` using `serde_json`.
- Guard the bootstrap runtime path with `FERROPHASE_BOOTSTRAP=1`; when set, the binary should prefer JSON inputs while still executing the full pipeline (type-checking, const-eval, lowering) using prepared metadata.
- Deliver a `JsonAstLoader` helper (either in `fp-core` or a new `fp-bootstrap` crate) that loads `Node`, `Ty`, and `HIR` representations from JSON files.

### Diagnostics and intrinsic normalization
- `fp-optimize::passes::normalize_intrinsics` is internal; it depends on `dashmap` only through shared contexts. With the single-threaded context flag it can keep working.
- CLI diagnostics rely on `miette`; for bootstrap we can emit plain strings or reuse the simplified `DiagnosticManager` already provided by `fp-core`.

### Typing and const evaluation
- Current code dynamically parses Rust fragments (`syn`) when it encounters `Expr::Any` or stringly typed casts. In bootstrap mode (cargo feature enabled **and** `FERROPHASE_BOOTSTRAP=1` present) the pipeline still runs `fp_typing::annotate`, but it should rely on pre-populated `Node.ty` fields or bundled type tables to avoid invoking heavyweight parsers.
- Const evaluation continues to execute so that downstream stages see the same mutations; preload serialized interpreter snapshots to supply any data consumers normally sourced from external crates.

### Lowering and backend stages
- `fp_optimize::transformations` converts typed AST into HIR/MIR. These modules do not directly depend on the heavyweight parsers; they consume annotated ASTs. Once types are present, they can still run.
- Code-generation backends remain external. For bootstrap validation we can stop after MIR dumps or emit JSON LIR snapshots.

## JSON Snapshot Workflow

1. **Stage 0 – frontend only.** Build the toolchain normally (`cargo build --release`) and run `fp parse Cargo.toml --no-resolve --snapshot …` to materialise the entire workspace AST as `*.ast.json`. No optimisation, typing, or lowering occurs; we only capture the parsed tree that later stages will replay.
2. **Stage 1 – replay and emit.** Using the Stage 0 `fp` binary, set `FERROPHASE_BOOTSTRAP=1` and feed the saved snapshot into `fp compile`. The pipeline skips parsing, rehydrates the AST, then performs intrinsic normalisation, typing, const evaluation, MIR/LIR generation, emits LLVM IR, and finally links the requested binary via `lld`/`clang`.
3. **Stage 2 – self-host check.** Take the freshly produced `fp` binary from Stage 1 and repeat Stage 1 against the same snapshot. Matching LLVM/binary artefacts demonstrate that the new compiler can drive the optimisation and codegen passes on its own inputs.

### Reference command sequence

```
# Stage 0 – parse and persist the AST snapshot
cargo build --release
"$PWD/target/release/fp" parse \
  Cargo.toml \
  --no-resolve \
  --snapshot target/bootstrap/workspace.stage0.ast.json

# Stage 1 – rebuild in bootstrap mode
cargo build --release --no-default-features --features bootstrap

# Stage 1 – replay snapshot, emit LLVM IR, and link a binary
FERROPHASE_BOOTSTRAP=1 "$PWD/target/release/fp" compile \
  target/bootstrap/workspace.stage0.ast.json \
  --target llvm \
  --output target/bootstrap/workspace.stage1.ll
FERROPHASE_BOOTSTRAP=1 "$PWD/target/release/fp" compile \
  target/bootstrap/workspace.stage0.ast.json \
  --target binary \
  --output target/bootstrap/workspace.stage1.bin

# Stage 2 – use the Stage 1 compiler to repeat the replay
stage1_bin="$PWD/target/bootstrap/workspace.stage1.out" # use .exe on Windows
FERROPHASE_BOOTSTRAP=1 "$stage1_bin" compile \
  target/bootstrap/workspace.stage0.ast.json \
  --target llvm \
  --output target/bootstrap/workspace.stage2.ll
FERROPHASE_BOOTSTRAP=1 "$stage1_bin" compile \
  target/bootstrap/workspace.stage0.ast.json \
  --target binary \
  --output target/bootstrap/workspace.stage2.bin
```

For convenience, `scripts/bootstrap.sh` automates these steps (including rebuilding with the `bootstrap` feature and the Stage 2 verification). Running it from the repository root produces both LLVM IR and binaries for Stage 1 and Stage 2 with no additional arguments:

```
scripts/bootstrap.sh
```

> Note: the Stage 1 binary is emitted as `*.out` on Unix-like systems and `*.exe` on Windows—adjust the `stage1_bin` assignment accordingly.

When using the bootstrap binary, default features (and therefore optional dependencies like `miette`) stay disabled. Pass `--no-default-features --features bootstrap` to ensure the smaller dependency surface.

## Proposed Implementation Plan

1. **Feature-gate external crates**
   - Add a shared `bootstrap` cargo feature to `fp-core`, `fp-typing`, `fp-optimize`, and `fp-cli`.
   - Provide alternative type aliases or modules that compile without `dashmap`, `tokio`, or `tree-sitter`.
   - Ensure unit tests and CI build both default and `bootstrap` configurations.
2. **Runtime toggle**
   - Introduce an environment variable (`FERROPHASE_BOOTSTRAP`) that switches the CLI into snapshot-replay mode at runtime.
   - Flow this flag through `PipelineOptions` so stages can adjust behaviour (prefer JSON artefacts, use alternate serializers) while still exercising the full pipeline.
3. **Introduce JSON loaders**
   - Provide `fp_core::ast::json` helpers (done) so bootstrap builds can import/export ASTs without touching external parsers.
   - Allow the CLI pipeline to recognise `.json` inputs when `FERROPHASE_BOOTSTRAP=1` (done) and reuse the standard stages on reconstructed trees.
   - Extend the snapshot format with schema/tool metadata so later phases can validate compatibility (done: `.ast.json` carries version + frontend AST only).
   - Expose an opt-in export path via `FERROPHASE_BOOTSTRAP_SNAPSHOT=1` so Stage 0 flows can emit fresh snapshots alongside existing intermediates (done).
4. **Record and replay const evaluation**
   - Optional future work: persist AST deltas or interpreter outputs if we want to avoid re-running const evaluation during bootstrap.
5. **Automation script**
   - Provide a repository script that orchestrates the Stage 0 → Stage 1 cycle: build `fp` normally, emit snapshots, rebuild with `--features bootstrap`, set the env var, and run validation steps.
6. **Stretch goals**
   - Re-implement a tiny subset of type inference in pure FerroPhase AST (no `syn`) for simple programs.
   - Replace JSON dumps with a stable binary format once the pipeline is proven.

## Open Questions & Risks
- **Type coverage:** how to guarantee that pre-annotated ASTs remain in sync with code changes? We likely need hashing/versioning baked into the snapshot format.
- **Const-eval side effects:** recorded outcomes must encode not only mutated ASTs but also generated functions/impls. Need a canonical diff format to replay safely.
- **Maintenance overhead:** dual-mode (`default` vs `bootstrap`) can drift; automated CI must build both configurations.
- **Lack of backend validation:** without LLVM/JS printers we only prove that front-half transformations work. Decide whether bootstrap should at least emit Rust transpilation (requires `syn` again) or stop at MIR.
- **Data volume:** serialized AST/HIR for the entire workspace may be large. Consider per-crate snapshots or chunking.

With these constraints, partial self-bootstrap is realistic: we can verify AST normalization, intrinsic handling, and lowering using only code from this repository plus `serde` (or a bundled serializer). Full source parsing and backend emission remain outside the bootstrap scope unless FerroPhase eventually re-implements their functionality natively.
