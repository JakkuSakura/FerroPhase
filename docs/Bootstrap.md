# Bootstrap Strategy

## Objective
- Allow FerroPhase to bring up a useful subset of the toolchain without cloning its full crate graph, by swapping externally hosted stages (parsers, optimizers, backends) with simpler local shims or precomputed JSON inputs.
- Focus on pieces that already live in this repository (`fp-core`, AST transforms, diagnostics) and identify how far we can progress before we need dependencies such as `syn`, `tree-sitter`, `swc`, or LLVM toolchains.
- Drive this mode via a `bootstrap` cargo feature plus a runtime environment variable (e.g. `FERROPHASE_BOOTSTRAP=1`) so the existing `fp` binary can switch behaviour without a bespoke bootstrap executable.

## Executive Summary
- **Viable today:** Loading and manipulating AST/HIR structures, running limited intrinsic rewrites, and emitting diagnostics can be made self-contained with modest work (feature flags, alternate storage types).
- **Needs shims:** Type inference, const-eval, and closure lowering lean on `syn` (for parsing embedded Rust fragments) and shared caches built on `dashmap`. Replacing these by reading pre-typed JSON snapshots is feasible but requires new plumbing.
- **Out of reach for bootstrap:** Source-language frontends (`fp-rust`, `fp-typescript`, `fp-python`, etc.) and LLVM/TypeScript/C# backends require large external libraries. For a self-hosted bootstrap we must treat their outputs as data inputs generated by a “stage 0” toolchain.

## Current Dependency Surface

| Pipeline Stage | Primary Crates | Key External Dependencies | Bootstrap Impact |
| -------------- | -------------- | ------------------------- | ---------------- |
| Source parsing / LAST | `fp-lang`, `fp-rust`, language frontends | `syn`, `tree-sitter`, `swc`, `cargo-metadata`, language runtimes | Cannot run without network-only crates; must ingest AST from JSON instead. |
| AST storage & diagnostics | `fp-core`, `fp-cli` (diagnostics) | `serde`, `dashmap`, `derive_more`, `miette`, `tracing` | Replace `dashmap` with `HashMap` on a `bootstrap` feature; keep `serde` (already vendored via crates.io snapshot) or bake a minimal serializer. |
| Typing & const-eval | `fp-typing`, `fp-interpret`, `fp-optimize` | `syn`, `proc-macro2`, `dashmap`, `tokio` (through CLI), `serde_json` | Gate parsing helpers; allow injecting pre-typed AST/const snapshots to skip `syn`. Need single-threaded context alternative. |
| Backends (LLVM, TS, etc.) | `fp-llvm`, `fp-typescript`, `fp-python`, `fp-csharp`, `fp-zig`, `fp-wit` | `llvm-ir`, system LLVM/clang, `swc`, language printers | Treat outputs as precomputed JSON/IR blobs; bootstrap mode only verifies AST transformations or transpiles via simplified emitters. |
| CLI orchestration | `fp-cli` | `clap`, `tokio`, `indicatif`, `miette` | For bootstrap, ship a tiny driver (no async, minimal CLI) or expose library entrypoints callable from an external script. |

## Bootstrap-Friendly Building Blocks

### Core data model
- `fp-core`’s AST/HIR/LIR structures already derive `Serialize`/`Deserialize`. Add a `bootstrap` cargo feature that:
  - switches `DashMap`-backed contexts in `context.rs` to plain `HashMap` + `RefCell`,
  - gates out `tree-sitter` exports in `cst::ts`,
  - bundles a lightweight `AstSerializer`/`Deserializer` using `serde_json`.
- Guard the bootstrap runtime path with `FERROPHASE_BOOTSTRAP=1`; when set, the binary should prefer JSON inputs while still executing the full pipeline (type-checking, const-eval, lowering) using prepared metadata.
- Deliver a `JsonAstLoader` helper (either in `fp-core` or a new `fp-bootstrap` crate) that loads `Node`, `Ty`, and `HIR` representations from JSON files.

### Diagnostics and intrinsic normalization
- `fp-optimize::passes::normalize_intrinsics` is internal; it depends on `dashmap` only through shared contexts. With the single-threaded context flag it can keep working.
- CLI diagnostics rely on `miette`; for bootstrap we can emit plain strings or reuse the simplified `DiagnosticManager` already provided by `fp-core`.

### Typing and const evaluation
- Current code dynamically parses Rust fragments (`syn`) when it encounters `Expr::Any` or stringly typed casts. In bootstrap mode (cargo feature enabled **and** `FERROPHASE_BOOTSTRAP=1` present) the pipeline still runs `fp_typing::annotate`, but it should rely on pre-populated `Node.ty` fields or bundled type tables to avoid invoking heavyweight parsers.
- Const evaluation continues to execute so that downstream stages see the same mutations; preload serialized interpreter snapshots to supply any data consumers normally sourced from external crates.

### Lowering and backend stages
- `fp_optimize::transformations` converts typed AST into HIR/MIR. These modules do not directly depend on the heavyweight parsers; they consume annotated ASTs. Once types are present, they can still run.
- Code-generation backends remain external. For bootstrap validation we can stop after MIR dumps or emit JSON LIR snapshots.

## JSON Snapshot Workflow

1. **Stage 0 (full toolchain)**: run the existing `fp` CLI (built without the `bootstrap` feature, using the standard dependency stack) to produce:
   - `*.ast.json` — serialized `Node` with `ty` metadata,
   - optional `*.hir.json` / `*.mir.json`,
   - `const_eval.json` capturing specialized functions and diagnostics.
2. **Stage 1 (bootstrap)**: rebuild `fp` with `--features bootstrap`, export `FERROPHASE_BOOTSTRAP=1`, and rerun the CLI to:
   - reconstruct `Node` using `serde_json`,
   - stitch const-eval mutations into the AST,
   - run intrinsic normalization / closure lowering / MIR lowering using the dependency-light path,
   - validate or emit intermediate dumps instead of invoking heavyweight backends.
3. **Stage 2 (self-host)**: once FerroPhase can regenerate the Stage 0 snapshots, a script can orchestrate `cargo run --release` (standard mode) to seed JSON artefacts, rebuild with `--features bootstrap`, and invoke the bootstrap flow so the new binary proves it can process its own inputs.

## Proposed Implementation Plan

1. **Feature-gate external crates**
   - Add a shared `bootstrap` cargo feature to `fp-core`, `fp-typing`, `fp-optimize`, and `fp-cli`.
   - Provide alternative type aliases or modules that compile without `dashmap`, `tokio`, or `tree-sitter`.
   - Ensure unit tests and CI build both default and `bootstrap` configurations.
2. **Runtime toggle**
   - Introduce an environment variable (`FERROPHASE_BOOTSTRAP`) that switches the CLI into snapshot-replay mode at runtime.
   - Flow this flag through `PipelineOptions` so stages can adjust behaviour (prefer JSON artefacts, use alternate serializers) while still exercising the full pipeline.
3. **Introduce JSON loaders**
   - Implement `JsonAstLoader` and `JsonConstSnapshot` utilities.
   - Extend `PipelineInput` with a `PreTypedJson` variant that skips frontends/type inference when `FERROPHASE_BOOTSTRAP` is set.
   - Route CLI commands to these loaders instead of invoking external frontends/backends.
4. **Record and replay const evaluation**
   - Extend `ConstEvaluationOrchestrator` to export/import snapshots (AST deltas, stdout, diagnostics).
   - Allow bootstrap mode to apply these deltas without executing the interpreter.
5. **Automation script**
   - Provide a repository script that orchestrates the Stage 0 → Stage 1 cycle: build `fp` normally, emit snapshots, rebuild with `--features bootstrap`, set the env var, and run validation steps.
6. **Stretch goals**
   - Re-implement a tiny subset of type inference in pure FerroPhase AST (no `syn`) for simple programs.
   - Replace JSON dumps with a stable binary format once the pipeline is proven.

## Open Questions & Risks
- **Type coverage:** how to guarantee that pre-annotated ASTs remain in sync with code changes? We likely need hashing/versioning baked into the snapshot format.
- **Const-eval side effects:** recorded outcomes must encode not only mutated ASTs but also generated functions/impls. Need a canonical diff format to replay safely.
- **Maintenance overhead:** dual-mode (`default` vs `bootstrap`) can drift; automated CI must build both configurations.
- **Lack of backend validation:** without LLVM/JS printers we only prove that front-half transformations work. Decide whether bootstrap should at least emit Rust transpilation (requires `syn` again) or stop at MIR.
- **Data volume:** serialized AST/HIR for the entire workspace may be large. Consider per-crate snapshots or chunking.

With these constraints, partial self-bootstrap is realistic: we can verify AST normalization, intrinsic handling, and lowering using only code from this repository plus `serde` (or a bundled serializer). Full source parsing and backend emission remain outside the bootstrap scope unless FerroPhase eventually re-implements their functionality natively.
