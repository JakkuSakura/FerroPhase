pub mod serializer;

mod expr;
mod item;
mod stmt;
mod ty;
mod utils;
mod value;

use eyre::Result;
use fp_core::ast::{Node, NodeKind};

pub use serializer::ZigSerializer;

pub(crate) struct ZigEmitter {
    code: String,
    indent: usize,
    wrote_header: bool,
}

impl ZigEmitter {
    pub(crate) fn new() -> Self {
        Self {
            code: String::new(),
            indent: 0,
            wrote_header: false,
        }
    }

    pub(crate) fn finish(mut self) -> String {
        if !self.code.ends_with('\n') {
            self.code.push('\n');
        }
        self.code.trim_end().to_string()
    }

    pub(crate) fn emit_node(&mut self, node: &Node) -> Result<()> {
        match node.kind() {
            NodeKind::File(file) => self.emit_file(file)?,
            NodeKind::Item(item) => self.emit_item(item)?,
            NodeKind::Expr(expr) => {
                self.ensure_header();
                self.push_placeholder_comment(
                    "top-level expressions are not supported for Zig output yet",
                );
                if let Some(rendered) = self.render_expr(expr) {
                    self.push_comment(&format!("Original expression: {}", rendered));
                }
            }
        }
        Ok(())
    }

    fn ensure_header(&mut self) {
        if self.wrote_header {
            return;
        }
        self.push_comment("Generated by FerroPhase Zig backend (experimental)");
        self.push_blank_line();
        self.wrote_header = true;
    }

    fn push_placeholder_comment(&mut self, message: &str) {
        self.ensure_header();
        self.push_comment(message);
    }

    fn push_comment(&mut self, message: &str) {
        for line in message.lines() {
            self.push_line(&format!("// {}", line.trim()));
        }
    }

    fn push_blank_line(&mut self) {
        if self.code.ends_with("\n\n") || self.code.is_empty() {
            return;
        }
        if !self.code.ends_with('\n') {
            self.code.push('\n');
        }
        self.code.push('\n');
    }

    fn push_line(&mut self, line: &str) {
        for _ in 0..self.indent {
            self.code.push_str("    ");
        }
        self.code.push_str(line);
        self.code.push('\n');
    }
}

#[cfg(test)]
mod tests;
