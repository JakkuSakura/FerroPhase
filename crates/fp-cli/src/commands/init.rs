//! Project initialization command implementation

use crate::{cli::CliConfig, Result, CliError};
use console::style;
use std::path::{Path, PathBuf};
use std::fs;
use tracing::info;

/// Arguments for the init command
pub struct InitArgs {
    pub project_name: String,
    pub template: String,
    pub output: Option<PathBuf>,
    pub git: bool,
}

/// Execute the init command
pub async fn init_command(args: InitArgs, config: &CliConfig) -> Result<()> {
    let project_dir = args.output.unwrap_or_else(|| PathBuf::from(&args.project_name));
    
    info!("Initializing project '{}' in {}", args.project_name, project_dir.display());
    
    // Check if directory already exists
    if project_dir.exists() {
        if project_dir.read_dir().map_err(|e| CliError::Io(e))?.next().is_some() {
            return Err(CliError::Project(format!("Directory '{}' is not empty", project_dir.display())));
        }
    }
    
    // Create project directory
    fs::create_dir_all(&project_dir).map_err(|e| CliError::Io(e))?;
    
    // Create project structure based on template
    match args.template.as_str() {
        "basic" => create_basic_template(&project_dir, &args.project_name, config).await?,
        "library" => create_library_template(&project_dir, &args.project_name, config).await?,
        "binary" => create_binary_template(&project_dir, &args.project_name, config).await?,
        "multi-lang" => create_multi_lang_template(&project_dir, &args.project_name, config).await?,
        _ => return Err(CliError::InvalidInput(format!("Unknown template: {}", args.template))),
    }
    
    // Initialize git repository if requested
    if args.git || config.project.auto_git {
        init_git_repository(&project_dir).await?;
    }
    
    print_success_message(&args.project_name, &project_dir);
    
    Ok(())
}

async fn create_basic_template(project_dir: &Path, project_name: &str, config: &CliConfig) -> Result<()> {
    let src_dir = project_dir.join(&config.project.default_structure.src_dir);
    fs::create_dir_all(&src_dir).map_err(|e| CliError::Io(e))?;
    
    // Create main.fp
    let main_content = format!(r#"//! {} - A FerroPhase project
//! Generated by FerroPhase CLI

fn main() {{
    println!("Hello from FerroPhase!");
    println!("Project: {}", PROJECT_NAME);
    
    // Demonstrate const evaluation
    const GREETING = const {{
        let hour = 14; // Would be actual time in real implementation
        if hour < 12 {{
            "Good morning"
        }} else if hour < 18 {{
            "Good afternoon"
        }} else {{
            "Good evening"
        }}
    }};
    
    println!("{{}}, FerroPhase!", GREETING);
}}

const PROJECT_NAME: &str = "{}";
"#, project_name, project_name);
    
    fs::write(src_dir.join("main.fp"), main_content).map_err(|e| CliError::Io(e))?;
    
    // Create Ferrophase.toml
    let config_content = format!(r#"[project]
name = "{}"
version = "0.1.0"
edition = "2021"
description = "A FerroPhase project"

[compilation]
target = "rust"
opt_level = 2

[dependencies]
# Add your dependencies here

[dev-dependencies]
# Add your development dependencies here
"#, project_name);
    
    fs::write(project_dir.join("Ferrophase.toml"), config_content).map_err(|e| CliError::Io(e))?;
    
    // Create README.md
    let readme_content = format!(r#"# {}

A FerroPhase project demonstrating meta-compilation capabilities.

## Getting Started

```bash
# Compile to Rust
fp compile src/main.fp --target rust

# Run the compiled code
fp compile src/main.fp --target rust --run

# Start interactive evaluation
fp eval --expr "1 + 2 * 3"

# Start REPL
fp repl
```

## Features

- Advanced compile-time evaluation
- Multi-language interoperability
- Flexible backend targets
- Rich type system with structural typing

## Learn More

- [FerroPhase Documentation](https://github.com/your-org/FerroPhase)
- [Examples](./examples/)
"#, project_name);
    
    fs::write(project_dir.join("README.md"), readme_content).map_err(|e| CliError::Io(e))?;
    
    Ok(())
}

async fn create_library_template(project_dir: &Path, project_name: &str, config: &CliConfig) -> Result<()> {
    let src_dir = project_dir.join(&config.project.default_structure.src_dir);
    fs::create_dir_all(&src_dir).map_err(|e| CliError::Io(e))?;
    
    // Create lib.fp
    let lib_content = format!(r#"//! {} - A FerroPhase library
//! Generated by FerroPhase CLI

/// Core functionality for {}
pub mod core {{
    /// A demonstration of compile-time computation
    pub type ComputedType<T> = const {{
        let mut result_type = struct {{}};
        
        // Add fields based on type characteristics
        addfield!(result_type, "data", T);
        addfield!(result_type, "metadata", TypeMetadata<T>);
        
        result_type
    }};
    
    /// Type metadata computed at compile time
    pub type TypeMetadata<T> = struct {{
        name: &'static str,
        size: usize,
        alignment: usize,
    }};
    
    /// Utility functions
    pub fn create_with_metadata<T>(value: T) -> ComputedType<T> {{
        ComputedType {{
            data: value,
            metadata: TypeMetadata {{
                name: type_name!(T),
                size: sizeof!(T),
                alignment: alignof!(T),
            }},
        }}
    }}
}}

/// Public API
pub use core::*;

#[cfg(test)]
mod tests {{
    use super::*;
    
    #[test]
    fn test_computed_type() {{
        let value = create_with_metadata(42i32);
        assert_eq!(value.data, 42);
        assert_eq!(value.metadata.name, "i32");
    }}
}}
"#, project_name, project_name);
    
    fs::write(src_dir.join("lib.fp"), lib_content).map_err(|e| CliError::Io(e))?;
    
    // Create tests directory
    let tests_dir = project_dir.join(&config.project.default_structure.tests_dir);
    fs::create_dir_all(&tests_dir).map_err(|e| CliError::Io(e))?;
    
    let test_content = format!(r#"//! Integration tests for {}

use {}::*;

#[test]
fn test_library_functionality() {{
    // Test the core functionality
    let result = create_with_metadata("hello");
    assert_eq!(result.data, "hello");
    assert_eq!(result.metadata.name, "&str");
}}
"#, project_name, project_name);
    
    fs::write(tests_dir.join("integration_test.fp"), test_content).map_err(|e| CliError::Io(e))?;
    
    // Create project config
    create_project_config(project_dir, project_name, "library").await?;
    
    Ok(())
}

async fn create_binary_template(project_dir: &Path, project_name: &str, config: &CliConfig) -> Result<()> {
    // Similar to basic but with more structure
    create_basic_template(project_dir, project_name, config).await?;
    
    // Add additional binary-specific files
    let src_dir = project_dir.join(&config.project.default_structure.src_dir);
    
    // Create config.fp
    let config_content = r#"//! Configuration management for the binary

pub struct Config {
    pub debug: bool,
    pub log_level: LogLevel,
    pub server_port: u16,
}

pub enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            debug: cfg!(debug_assertions),
            log_level: LogLevel::Info,
            server_port: 8080,
        }
    }
}

/// Load configuration with compile-time validation
pub fn load_config() -> Config {
    const {
        // Validate configuration at compile time
        let config = Config::default();
        
        if config.server_port < 1024 {
            compile_warning!("Using privileged port, may require elevated permissions");
        }
        
        config
    }
}
"#;
    
    fs::write(src_dir.join("config.fp"), config_content).map_err(|e| CliError::Io(e))?;
    
    Ok(())
}

async fn create_multi_lang_template(project_dir: &Path, project_name: &str, config: &CliConfig) -> Result<()> {
    let src_dir = project_dir.join(&config.project.default_structure.src_dir);
    fs::create_dir_all(&src_dir).map_err(|e| CliError::Io(e))?;
    
    // Create main.fp with multi-language examples
    let main_content = format!(r#"//! {} - Multi-language FerroPhase project
//! Demonstrates cross-language compile-time computation

fn main() {{
    println!("Multi-language FerroPhase project!");
    
    // Python-powered compile-time computation
    const ANALYSIS_RESULT = const python! {{
        import math
        
        def analyze_data():
            # Complex analysis that would be tedious in Rust
            data = [1, 2, 3, 4, 5]
            mean = sum(data) / len(data)
            variance = sum((x - mean) ** 2 for x in data) / len(data)
            std_dev = math.sqrt(variance)
            
            return {{
                "mean": mean,
                "std_dev": std_dev,
                "optimization_hint": "vectorize" if len(data) > 100 else "scalar"
            }}
        
        analyze_data()
    }};
    
    // JavaScript-powered configuration DSL
    const API_CONFIG = const javascript! {{
        const config = {{
            endpoints: {{
                "/users": {{ method: "GET", auth: true }},
                "/posts": {{ method: ["GET", "POST"], auth: false }},
                "/admin": {{ method: "*", auth: true, admin: true }}
            }},
            middleware: ["cors", "logging", "auth"]
        }};
        
        // Validate configuration
        Object.keys(config.endpoints).forEach(path => {{
            if (!path.startsWith("/")) {{
                throw new Error(`Invalid endpoint path: ${{path}}`);
            }}
        }});
        
        config;
    }};
    
    // Use the compile-time computed values
    println!("Analysis result: mean = {{}}", ANALYSIS_RESULT.mean);
    println!("API endpoints: {{}}", API_CONFIG.endpoints.len());
    
    // Generate optimized code based on analysis
    let processor = const {{
        if ANALYSIS_RESULT.optimization_hint == "vectorize" {{
            generate_simd_processor!()
        }} else {{
            generate_scalar_processor!()
        }}
    }};
    
    processor.run();
}}

/// Demonstration of generated processors
trait DataProcessor {{
    fn run(&self);
}}

// These would be generated by the compile-time intrinsics
struct SimdProcessor;
struct ScalarProcessor;

impl DataProcessor for SimdProcessor {{
    fn run(&self) {{
        println!("Running SIMD-optimized processor");
    }}
}}

impl DataProcessor for ScalarProcessor {{
    fn run(&self) {{
        println!("Running scalar processor");
    }}
}}
"#, project_name);
    
    fs::write(src_dir.join("main.fp"), main_content).map_err(|e| CliError::Io(e))?;
    
    // Create Python integration example
    let python_dir = src_dir.join("python");
    fs::create_dir_all(&python_dir).map_err(|e| CliError::Io(e))?;
    
    let python_content = r#"# Python utilities for compile-time computation
# This file demonstrates how Python can be used at compile-time in FerroPhase

def complex_analysis(data):
    """Perform complex data analysis that's easier to express in Python"""
    import numpy as np
    
    # Convert to numpy array for efficient computation
    arr = np.array(data)
    
    result = {
        "mean": float(np.mean(arr)),
        "std": float(np.std(arr)),
        "min": float(np.min(arr)),
        "max": float(np.max(arr)),
        "quartiles": [float(q) for q in np.percentile(arr, [25, 50, 75])],
    }
    
    # Determine optimization strategy
    if len(data) > 1000:
        result["strategy"] = "parallel"
    elif len(data) > 100:
        result["strategy"] = "vectorized"
    else:
        result["strategy"] = "scalar"
    
    return result

def generate_lookup_table(func, start, end, step):
    """Generate a lookup table for a mathematical function"""
    import math
    
    table = []
    x = start
    while x <= end:
        table.append((x, func(x)))
        x += step
    
    return table
"#;
    
    fs::write(python_dir.join("analysis.py"), python_content).map_err(|e| CliError::Io(e))?;
    
    // Create JavaScript integration example
    let js_dir = src_dir.join("javascript");
    fs::create_dir_all(&js_dir).map_err(|e| CliError::Io(e))?;
    
    let js_content = r#"// JavaScript utilities for compile-time DSL processing
// This file demonstrates how JavaScript can be used for configuration DSLs

function validateApiConfig(config) {
    const errors = [];
    
    // Validate endpoints
    for (const [path, spec] of Object.entries(config.endpoints)) {
        if (!path.startsWith('/')) {
            errors.push(`Endpoint path must start with '/': ${path}`);
        }
        
        if (!spec.method) {
            errors.push(`Endpoint ${path} missing method specification`);
        }
        
        if (spec.auth === undefined) {
            errors.push(`Endpoint ${path} missing auth specification`);
        }
    }
    
    // Validate middleware
    if (!Array.isArray(config.middleware)) {
        errors.push('Middleware must be an array');
    }
    
    if (errors.length > 0) {
        throw new Error('Configuration validation failed:\n' + errors.join('\n'));
    }
    
    return true;
}

function generateApiSchema(config) {
    const schema = {
        openapi: "3.0.0",
        info: {
            title: "Generated API",
            version: "1.0.0"
        },
        paths: {}
    };
    
    for (const [path, spec] of Object.entries(config.endpoints)) {
        schema.paths[path] = {};
        
        const methods = Array.isArray(spec.method) ? spec.method : [spec.method];
        
        for (const method of methods) {
            if (method === '*') continue; // Skip wildcard for OpenAPI
            
            schema.paths[path][method.toLowerCase()] = {
                summary: `${method} ${path}`,
                security: spec.auth ? [{ bearerAuth: [] }] : []
            };
        }
    }
    
    return schema;
}
"#;
    
    fs::write(js_dir.join("config_dsl.js"), js_content).map_err(|e| CliError::Io(e))?;
    
    // Create project config for multi-lang
    create_project_config(project_dir, project_name, "multi-lang").await?;
    
    Ok(())
}

async fn create_project_config(project_dir: &Path, project_name: &str, template: &str) -> Result<()> {
    let config_content = format!(r#"[project]
name = "{}"
version = "0.1.0"
edition = "2021"
template = "{}"
description = "A FerroPhase {} project"

[compilation]
target = "rust"
opt_level = 2
debug = false

# Multi-language support
[languages]
python = {{ enabled = true, version = "3.8+" }}
javascript = {{ enabled = true, runtime = "node" }}

[dependencies]
# Core FerroPhase dependencies

[dev-dependencies]
# Development dependencies

[features]
default = ["std"]
std = []
no_std = []

[build]
# Custom build configuration
"#, project_name, template, template);
    
    fs::write(project_dir.join("Ferrophase.toml"), config_content).map_err(|e| CliError::Io(e))?;
    Ok(())
}

async fn init_git_repository(project_dir: &Path) -> Result<()> {
    // Initialize git repository
    let output = tokio::process::Command::new("git")
        .arg("init")
        .current_dir(project_dir)
        .output()
        .await
        .map_err(|e| CliError::Project(format!("Failed to initialize git repository: {}", e)))?;
    
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(CliError::Project(format!("Git init failed: {}", stderr)));
    }
    
    // Create .gitignore
    let gitignore_content = r#"# FerroPhase
/target/
*.rs.bk
*.ll
*.wasm

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log

# Temporary files
/tmp/
"#;
    
    fs::write(project_dir.join(".gitignore"), gitignore_content).map_err(|e| CliError::Io(e))?;
    
    Ok(())
}

fn print_success_message(project_name: &str, project_dir: &Path) {
    println!();
    println!("{} Successfully created FerroPhase project '{}'", style("✓").green(), style(project_name).cyan().bold());
    println!();
    println!("Next steps:");
    println!("  {} cd {}", style("$").dim(), project_dir.display());
    println!("  {} fp compile src/main.fp --target rust --run", style("$").dim());
    println!("  {} fp repl", style("$").dim());
    println!();
    println!("Learn more:");
    println!("  {} fp --help", style("$").dim());
    println!("  {} https://github.com/your-org/FerroPhase", style("📖").cyan());
    println!();
}