use std::fs::File;
use std::io::Write;
use std::path::Path;

use fp_core::ast::{AstDeserializer, AstSerializer};
use fp_core::Result;
use fp_rust_lang::parser::RustParser;
use fp_rust_lang::printer::rustfmt::format_code;
use fp_rust_lang::printer::RustPrinter;

/// FerroPhase Rust Transpiler
///
/// This tool processes Rust files and generates formatted code.
///
/// Usage: fp-rust-transpile <input_directory>
fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <input_directory>", args[0]);
        eprintln!("Example: {} examples", args[0]);
        std::process::exit(1);
    }

    let base_path = Path::new(&args[1]);
    if !base_path.exists() {
        eprintln!("Error: Directory '{}' does not exist", base_path.display());
        std::process::exit(1);
    }

    process_directory(base_path)
}

fn process_directory(base_path: &Path) -> Result<()> {
    println!("🔧 Processing directory: {}", base_path.display());

    // Collect and sort all files in the directory
    let mut dirs: Vec<_> = std::fs::read_dir(base_path)?
        .into_iter()
        .filter_map(|entry| entry.ok())
        .map(|entry| entry.path())
        .filter(|path| {
            path.extension()
                .and_then(|ext| ext.to_str())
                .map_or(false, |ext| ext == "rs")
        })
        .collect();

    dirs.sort();

    if dirs.is_empty() {
        println!("⚠️  No Rust files found in {}", base_path.display());
        return Ok(());
    }

    println!("📁 Found {} Rust files to process", dirs.len());

    // Initialize components
    let rust_printer = RustPrinter::new();
    let rust_parser = RustParser::new();

    for file_in in dirs {
        let file_name = file_in.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("unknown");

        // Skip generated files and non-main files
        if !file_name.contains("main_") || file_name.contains("_gen.rs") {
            continue;
        }

        let output_file_name = file_name.replace(".rs", "_gen.rs");
        let file_out = file_in.with_file_name(output_file_name);

        println!("🔄 Processing: {} → {}", file_in.display(), file_out.display());

        match process_file(&file_in, &file_out, &rust_parser, &rust_printer as &dyn AstSerializer) {
            Ok(_) => println!("✅ Successfully processed: {}", file_name),
            Err(e) => eprintln!("❌ Failed to process {}: {}", file_name, e),
        }
    }

    println!("🎉 Processing complete!");
    Ok(())
}

fn process_file(
    input_path: &Path,
    output_path: &Path,
    parser: &RustParser,
    printer: &dyn AstSerializer,
) -> Result<()> {
    // Read input file
    let file_content = std::fs::read_to_string(input_path)?;

    // Parse the code
    let node = parser.deserialize_node(&file_content)?;

    // Generate formatted code
    let code = printer.serialize_node(&node)?;
    let formatted_code = format_code(&code)?;

    // Write the formatted code to output file
    let mut output_file = File::create(output_path)?;
    writeln!(output_file, "// Original file: {}", input_path.display())?;
    writeln!(output_file, "// Generated by fp-rust-transpile")?;
    writeln!(output_file)?;
    writeln!(output_file, "{}", formatted_code)?;

    Ok(())
}