use std::fs::File;
use std::io::Write;
use std::path::Path;

use clap::Parser;
use fp_core::ast::{AstDeserializer, AstSerializer};
use fp_core::Result;
use fp_rust_lang::parser::RustParser;
use fp_rust_lang::printer::rustfmt::format_code;
use fp_rust_lang::printer::RustPrinter;

/// FerroPhase Rust Transpiler
///
/// This tool processes a single Rust file and generates formatted code.
///
/// Usage: fp-rust-transpile [OPTIONS]
#[derive(Parser)]
struct Opts {
    /// Input Rust file
    #[clap(short, long, required = true)]
    input: String,
}
fn main() -> Result<()> {
    let opts: Opts = Opts::parse();
    let input_path = Path::new(&opts.input);

    if !input_path.exists() {
        eprintln!("Error: File '{}' does not exist", input_path.display());
        std::process::exit(1);
    }

    process_file(input_path)
}

fn process_file(input_path: &Path) -> Result<()> {
    // Read input file
    let file_content = std::fs::read_to_string(input_path)?;
    
    // Parse the code
    let node = RustParser::new().deserialize_node(&file_content)?;
    
    // Generate formatted code
    let code = RustPrinter::new().serialize_node(&node)?;
    let formatted_code = format_code(&code)?;
    
    // Create output file path
    let output_path = input_path.with_file_name(
        input_path.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("output")
            .replace(".rs", "_gen.rs")
    );
    
    // Write the formatted code to output file
    let mut output_file = File::create(&output_path)?;
    writeln!(output_file, "// Original file: {}", input_path.display())?;
    writeln!(output_file, "// Generated by fp-rust-transpile")?;
    writeln!(output_file)?;
    writeln!(output_file, "{}", formatted_code)?;
    
    println!("âœ… Successfully processed: {}", input_path.display());
    Ok(())
}
