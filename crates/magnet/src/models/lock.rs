use crate::models::{DependencyEdge, PackageGraph, PackageNode};
use eyre::{Result, WrapErr};
use semver::{Version, VersionReq};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};
use std::path::Path;

const LOCK_VERSION: u32 = 1;
const REGISTRY_SOURCE: &str = "registry+crates.io";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MagnetLock {
    pub version: u32,
    #[serde(rename = "package", default)]
    pub packages: Vec<LockPackage>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockPackage {
    pub name: String,
    pub version: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dependencies: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct LockedRegistryVersion {
    pub version: String,
    pub checksum: Option<String>,
}

#[derive(Debug, Clone)]
pub struct LockIndex {
    registry: HashMap<String, Vec<LockedRegistryEntry>>,
}

#[derive(Debug, Clone)]
struct LockedRegistryEntry {
    version: Version,
    checksum: Option<String>,
}

impl MagnetLock {
    pub fn from_graph(
        graph: &PackageGraph,
        workspace_root: &Path,
        cache_dir: Option<&Path>,
    ) -> Self {
        let mut packages = graph
            .packages
            .iter()
            .map(|node| lock_package_from_node(node, workspace_root, cache_dir))
            .collect::<Vec<_>>();
        packages.sort_by(|a, b| a.name.cmp(&b.name).then(a.version.cmp(&b.version)));
        Self {
            version: LOCK_VERSION,
            packages,
        }
    }

    pub fn read_from_path(path: &Path) -> Result<Option<Self>> {
        if !path.exists() {
            return Ok(None);
        }
        let content = std::fs::read_to_string(path)
            .with_context(|| format!("Failed to read {}", path.display()))?;
        let lock: Self = toml::from_str(&content)
            .with_context(|| format!("Failed to parse {}", path.display()))?;
        Ok(Some(lock))
    }

    pub fn write_to_path(&self, path: &Path) -> Result<()> {
        let payload = toml::to_string(self).context("Failed to serialize Magnet.lock")?;
        let content = format!(
            "# This file is automatically @generated by Magnet.\n{}",
            payload
        );
        std::fs::write(path, content)
            .with_context(|| format!("Failed to write {}", path.display()))?;
        Ok(())
    }

    pub fn trim_to_roots(mut self) -> Self {
        if self.packages.is_empty() {
            return self;
        }

        let mut package_map: HashMap<(String, String, Option<String>), LockPackage> =
            HashMap::new();
        for pkg in &self.packages {
            package_map.insert(
                (pkg.name.clone(), pkg.version.clone(), pkg.source.clone()),
                pkg.clone(),
            );
        }

        let mut reachable: HashSet<(String, String, Option<String>)> = HashSet::new();
        let mut queue: VecDeque<(String, String, Option<String>)> = VecDeque::new();

        for pkg in &self.packages {
            if pkg.source.is_none() {
                let key = (pkg.name.clone(), pkg.version.clone(), pkg.source.clone());
                if reachable.insert(key.clone()) {
                    queue.push_back(key);
                }
            }
        }

        while let Some(key) = queue.pop_front() {
            let Some(pkg) = package_map.get(&key) else {
                continue;
            };
            for dep in &pkg.dependencies {
                if let Some((name, version, source)) = parse_lock_dependency(dep) {
                    let dep_key = (name, version, source);
                    if package_map.contains_key(&dep_key) && reachable.insert(dep_key.clone()) {
                        queue.push_back(dep_key);
                    }
                }
            }
        }

        self.packages = self
            .packages
            .into_iter()
            .filter(|pkg| {
                let key = (pkg.name.clone(), pkg.version.clone(), pkg.source.clone());
                reachable.contains(&key)
            })
            .collect();
        self
    }

    pub fn validate(&self) -> Vec<String> {
        let mut warnings = Vec::new();
        let mut known = HashMap::new();
        for pkg in &self.packages {
            let key = (
                pkg.name.as_str(),
                pkg.version.as_str(),
                pkg.source.as_deref(),
            );
            known.insert(key, true);
        }

        for pkg in &self.packages {
            for dep in &pkg.dependencies {
                match parse_lock_dependency(dep) {
                    Some((name, version, source)) => {
                        let key = (name.as_str(), version.as_str(), source.as_deref());
                        if !known.contains_key(&key) {
                            warnings.push(format!(
                                "missing package for dependency '{}' of {} {}",
                                dep, pkg.name, pkg.version
                            ));
                        }
                    }
                    None => {
                        warnings.push(format!(
                            "unrecognized dependency format '{}' in {} {}",
                            dep, pkg.name, pkg.version
                        ));
                    }
                }
            }
        }
        warnings
    }
}

impl LockIndex {
    pub fn from_lock(lock: &MagnetLock) -> Self {
        let mut registry: HashMap<String, Vec<LockedRegistryEntry>> = HashMap::new();
        for package in &lock.packages {
            if package.source.as_deref() != Some(REGISTRY_SOURCE) {
                continue;
            }
            if let Ok(version) = Version::parse(&package.version) {
                registry
                    .entry(package.name.clone())
                    .or_default()
                    .push(LockedRegistryEntry {
                        version,
                        checksum: package.checksum.clone(),
                    });
            }
        }
        for entries in registry.values_mut() {
            entries.sort_by(|a, b| b.version.cmp(&a.version));
        }
        Self { registry }
    }

    pub fn match_registry(&self, name: &str, req: &VersionReq) -> Option<LockedRegistryVersion> {
        let entries = self.registry.get(name)?;
        for entry in entries {
            if req.matches(&entry.version) {
                return Some(LockedRegistryVersion {
                    version: entry.version.to_string(),
                    checksum: entry.checksum.clone(),
                });
            }
        }
        None
    }
}

fn lock_package_from_node(
    node: &PackageNode,
    workspace_root: &Path,
    cache_dir: Option<&Path>,
) -> LockPackage {
    let source = package_source(node, workspace_root, cache_dir);
    let dependencies = node
        .dependencies
        .iter()
        .filter_map(format_dependency)
        .collect::<Vec<_>>();
    LockPackage {
        name: node.name.clone(),
        version: node.version.clone(),
        source,
        checksum: node.checksum.clone(),
        dependencies,
    }
}

fn package_source(
    node: &PackageNode,
    workspace_root: &Path,
    cache_dir: Option<&Path>,
) -> Option<String> {
    if let Some(source) = node.source.as_ref() {
        return Some(source.clone());
    }
    if let Some(cache_dir) = cache_dir {
        let registry_root = cache_dir.join("registry").join("crates");
        if node.root.starts_with(&registry_root) {
            return Some(REGISTRY_SOURCE.to_string());
        }
    }
    if node.root.starts_with(workspace_root) {
        return None;
    }
    Some(format!("path+{}", node.root.display()))
}

fn format_dependency(dep: &DependencyEdge) -> Option<String> {
    let name = dep.package.as_deref().unwrap_or(&dep.name);
    let version = dep.resolved_version.as_ref().or(dep.version.as_ref())?;
    let mut out = format!("{} {}", name, version);
    if let Some(source) = dep.source.as_deref() {
        out.push_str(&format!(" ({})", source));
    } else if let Some(path) = dep.path.as_ref() {
        out.push_str(&format!(" (path+{})", path.display()));
    }
    Some(out)
}

fn parse_lock_dependency(value: &str) -> Option<(String, String, Option<String>)> {
    let (core, source) = if let Some((left, right)) = value.rsplit_once(" (") {
        let source = right.strip_suffix(')')?.to_string();
        (left.trim(), Some(source))
    } else {
        (value.trim(), None)
    };
    let mut parts = core.split_whitespace();
    let name = parts.next()?.to_string();
    let version = parts.next()?.to_string();
    Some((name, version, source))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lock_index_picks_highest_matching_version() -> Result<()> {
        let lock = MagnetLock {
            version: LOCK_VERSION,
            packages: vec![
                LockPackage {
                    name: "k9".to_string(),
                    version: "0.11.7".to_string(),
                    source: Some(REGISTRY_SOURCE.to_string()),
                    checksum: Some("abc".to_string()),
                    dependencies: Vec::new(),
                },
                LockPackage {
                    name: "k9".to_string(),
                    version: "0.11.9".to_string(),
                    source: Some(REGISTRY_SOURCE.to_string()),
                    checksum: Some("def".to_string()),
                    dependencies: Vec::new(),
                },
            ],
        };
        let index = LockIndex::from_lock(&lock);
        let req = VersionReq::parse("^0.11.0")?;
        let locked = index.match_registry("k9", &req).unwrap();
        assert_eq!(locked.version, "0.11.9");
        assert_eq!(locked.checksum.as_deref(), Some("def"));
        Ok(())
    }
}
