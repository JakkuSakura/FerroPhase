use crate::models::{DependencyEdge, PackageGraph, PackageNode};
use eyre::{Result, WrapErr};
use semver::{Version, VersionReq};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

const LOCK_VERSION: u32 = 1;
const REGISTRY_SOURCE: &str = "registry+crates.io";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MagnetLock {
    pub version: u32,
    #[serde(rename = "package", default)]
    pub packages: Vec<LockPackage>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockPackage {
    pub name: String,
    pub version: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub dependencies: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct LockedRegistryVersion {
    pub version: String,
    pub checksum: Option<String>,
}

#[derive(Debug, Clone)]
pub struct LockIndex {
    registry: HashMap<String, Vec<LockedRegistryEntry>>,
}

#[derive(Debug, Clone)]
struct LockedRegistryEntry {
    version: Version,
    checksum: Option<String>,
}

impl MagnetLock {
    pub fn from_graph(
        graph: &PackageGraph,
        workspace_root: &Path,
        cache_dir: Option<&Path>,
    ) -> Self {
        let mut packages = graph
            .packages
            .iter()
            .map(|node| lock_package_from_node(node, workspace_root, cache_dir))
            .collect::<Vec<_>>();
        packages.sort_by(|a, b| a.name.cmp(&b.name).then(a.version.cmp(&b.version)));
        Self {
            version: LOCK_VERSION,
            packages,
        }
    }

    pub fn read_from_path(path: &Path) -> Result<Option<Self>> {
        if !path.exists() {
            return Ok(None);
        }
        let content = std::fs::read_to_string(path)
            .with_context(|| format!("Failed to read {}", path.display()))?;
        let lock: Self =
            toml::from_str(&content).with_context(|| format!("Failed to parse {}", path.display()))?;
        Ok(Some(lock))
    }

    pub fn write_to_path(&self, path: &Path) -> Result<()> {
        let payload = toml::to_string(self).context("Failed to serialize Magnet.lock")?;
        let content = format!(
            "# This file is automatically @generated by Magnet.\n{}",
            payload
        );
        std::fs::write(path, content)
            .with_context(|| format!("Failed to write {}", path.display()))?;
        Ok(())
    }
}

impl LockIndex {
    pub fn from_lock(lock: &MagnetLock) -> Self {
        let mut registry: HashMap<String, Vec<LockedRegistryEntry>> = HashMap::new();
        for package in &lock.packages {
            if package.source.as_deref() != Some(REGISTRY_SOURCE) {
                continue;
            }
            if let Ok(version) = Version::parse(&package.version) {
                registry
                    .entry(package.name.clone())
                    .or_default()
                    .push(LockedRegistryEntry {
                        version,
                        checksum: package.checksum.clone(),
                    });
            }
        }
        for entries in registry.values_mut() {
            entries.sort_by(|a, b| b.version.cmp(&a.version));
        }
        Self { registry }
    }

    pub fn match_registry(&self, name: &str, req: &VersionReq) -> Option<LockedRegistryVersion> {
        let entries = self.registry.get(name)?;
        for entry in entries {
            if req.matches(&entry.version) {
                return Some(LockedRegistryVersion {
                    version: entry.version.to_string(),
                    checksum: entry.checksum.clone(),
                });
            }
        }
        None
    }
}

fn lock_package_from_node(
    node: &PackageNode,
    workspace_root: &Path,
    cache_dir: Option<&Path>,
) -> LockPackage {
    let source = package_source(node, workspace_root, cache_dir);
    let dependencies = node
        .dependencies
        .iter()
        .filter_map(format_dependency)
        .collect::<Vec<_>>();
    LockPackage {
        name: node.name.clone(),
        version: node.version.clone(),
        source,
        checksum: node.checksum.clone(),
        dependencies,
    }
}

fn package_source(
    node: &PackageNode,
    workspace_root: &Path,
    cache_dir: Option<&Path>,
) -> Option<String> {
    if let Some(cache_dir) = cache_dir {
        let registry_root = cache_dir.join("registry").join("crates");
        if node.root.starts_with(&registry_root) {
            return Some(REGISTRY_SOURCE.to_string());
        }
    }
    if node.root.starts_with(workspace_root) {
        return None;
    }
    Some(format!("path+{}", node.root.display()))
}

fn format_dependency(dep: &DependencyEdge) -> Option<String> {
    let name = dep.package.as_deref().unwrap_or(&dep.name);
    let version = dep
        .resolved_version
        .as_ref()
        .or(dep.version.as_ref())?;
    let mut out = format!("{} {}", name, version);
    if let Some(source) = dep.source.as_deref() {
        out.push_str(&format!(" ({})", source));
    } else if let Some(path) = dep.path.as_ref() {
        out.push_str(&format!(" (path+{})", path.display()));
    }
    Some(out)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lock_index_picks_highest_matching_version() -> Result<()> {
        let lock = MagnetLock {
            version: LOCK_VERSION,
            packages: vec![
                LockPackage {
                    name: "k9".to_string(),
                    version: "0.11.7".to_string(),
                    source: Some(REGISTRY_SOURCE.to_string()),
                    checksum: Some("abc".to_string()),
                    dependencies: Vec::new(),
                },
                LockPackage {
                    name: "k9".to_string(),
                    version: "0.11.9".to_string(),
                    source: Some(REGISTRY_SOURCE.to_string()),
                    checksum: Some("def".to_string()),
                    dependencies: Vec::new(),
                },
            ],
        };
        let index = LockIndex::from_lock(&lock);
        let req = VersionReq::parse("^0.11.0")?;
        let locked = index.match_registry("k9", &req).unwrap();
        assert_eq!(locked.version, "0.11.9");
        assert_eq!(locked.checksum.as_deref(), Some("def"));
        Ok(())
    }
}
