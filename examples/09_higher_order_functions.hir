hir::Program {
    fn add__i64(a: i64, b: i64) -> i64 {
        // params: [a: i64, b: i64]
        (a + b)
    }

    fn apply__i64_op_add__i64(a: i64, b: i64) -> () {
        // params: [a: i64, b: i64]
        {
            printf("%d
", add__i64(a, b));
        }
    }

    fn add__f64(a: f64, b: f64) -> f64 {
        // params: [a: f64, b: f64]
        (a + b)
    }

    fn apply__f64_op_add__f64(a: f64, b: f64) -> () {
        // params: [a: f64, b: f64]
        {
            printf("%f
", add__f64(a, b));
        }
    }

    fn apply_if__op_add__i64(cond: bool, a: i64, b: i64) -> i64 {
        // params: [cond: bool, a: i64, b: i64]
        if (cond)
            add__i64(a, b)
        else
            0
    }

    struct __Closure0 {
        pub n: i64,
    }

    fn __closure0_call(__env: __Closure0, x: i64) -> i64 {
        // params: [__env: __Closure0, x: i64]
        (x + __env.n)
    }

    struct __Closure1 {
    }

    fn __closure1_call(__env: __Closure1, x: i64) -> i64 {
        // params: [__env: __Closure1, x: i64]
        (x * 2)
    }

    fn make_adder(n: i64) -> () {
        // params: [n: i64]
        __Closure0 { n: n }
    }

    fn main() -> () {
        {
            printf("Generic operations:
");
            apply__i64_op_add__i64(10, 20);
            apply__f64_op_add__f64(1.5, 2.5);
            printf("
Conditional:
");
            printf("%d
", apply_if__op_add__i64(true, 5, 3));
            printf("%d
", apply_if__op_add__i64(false, 5, 3));
            printf("
Closure factory:
");
            const add_10: () =
                make_adder(10);
            printf("add_10(5) = %d
", __closure0_call(add_10, 5));
            let double = __Closure1 {  };
            printf("double(7) = %d
", __closure1_call(double, 7));
        }
    }
}
