hir::Program {
    struct __Closure0 {
        pub n: i64
,
    }

    fn __closure0_call(__env: __Closure0, x: i64
) -> i64
 {
        // params: [__env: __Closure0, x: i64
]
        (x + __env.n)
    }

    struct __Closure1 {
        pub __fp_no_capture: i8
,
    }

    fn __closure1_call(__env: __Closure1, x: i64
) -> i64
 {
        // params: [__env: __Closure1, x: i64
]
        (x * 2)
    }

    fn apply_if(cond: bool, a: i64
, b: i64
, op: ()) -> i64
 {
        // params: [cond: bool, a: i64
, b: i64
, op: ()]
        if (cond)
            op(a, b)
        else
            0
    }

    fn make_adder(n: i64
) -> __Closure0 {
        // params: [n: i64
]
        __Closure0 { n: n }
    }

    fn main() -> () {
        {
            printf("Generic operations:
");
            apply__spec0(10, 20, add__spec0);
            apply__spec1(1.5, 2.5, add__spec1);
            printf("
Conditional:
");
            printf("%d
", apply_if(true, 5, 3, add__spec0));
            printf("%d
", apply_if(false, 5, 3, add__spec0));
            printf("
Closure factory:
");
            const add_10: __Closure0 =
                make_adder(10);
            printf("add_10(5) = %d
", __closure0_call(add_10, 5));
            let double = __Closure1 { __fp_no_capture: 0 };
            printf("double(7) = %d
", __closure1_call(double, 7));
        }
    }

    fn apply__spec0(a: i64
, b: i64
, op: ()) -> () {
        // params: [a: i64
, b: i64
, op: ()]
        {
            printf("%d
", op(a, b));
        }
    }

    fn add__spec0(a: i64
, b: i64
) -> i64
 {
        // params: [a: i64
, b: i64
]
        (a + b)
    }

    fn apply__spec1(a: f64
, b: f64
, op: ()) -> () {
        // params: [a: f64
, b: f64
, op: ()]
        {
            printf("%f
", op(a, b));
        }
    }

    fn add__spec1(a: f64
, b: f64
) -> f64
 {
        // params: [a: f64
, b: f64
]
        (a + b)
    }
}
