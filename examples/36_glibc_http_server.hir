hir::Program {
    pub struct std::bench::BenchCase {
        pub name: str,
        pub run: fn() -> (),
    }

    pub const std::bench::REGISTRY: [BenchCase; 0] =
        [];

    pub struct std::bench::BenchReport {
        pub total: i64,
        pub passed: i64,
        pub failed: i64,
    }

    pub fn std::bench::run_benches() -> BenchReport;

    pub struct std::collections::HashMapEntry<K, V> {
        pub key: K,
        pub value: V,
    }

    pub struct std::collections::HashMap<K, V> {
        pub entries: Vec<HashMapEntry<K, V>>,
    }

    impl HashMap<K, V> {
        fn std::collections::from(entries: Vec<HashMapEntry<K, V>>) -> HashMap<K, V>;

        fn std::collections::len(self: &HashMap<K, V>) -> i64;

        fn std::collections::get_unchecked(self: &HashMap<K, V>, key: K) -> V;
    }

    pub struct std::ffi::CStr {
    }

    pub fn std::future::sleep(seconds: f64) -> std::task::Future<()>;

    pub struct std::json::JsonField {
        pub key: &str,
        pub value: std::json::JsonValue,
    }

    pub enum std::json::JsonValue {
        Null,
        Bool,
        Number,
        String,
        Array,
        Object,
    }

    pub fn std::json::parse(input: &str) -> JsonValue;

    pub fn std::json::print(value: JsonValue) -> ();

    pub fn std::json::print_value(value: &JsonValue) -> ();

    pub struct std::json::Parser {
        pub src: Vec<&str>,
        pub pos: i64,
    }

    impl Parser {
        fn std::json::new(src: &str) -> Parser;

        fn std::json::bump(self: &Parser, amount: i64) -> ();

        fn std::json::parse_value(self: &Parser) -> JsonValue;

        fn std::json::parse_array(self: &Parser) -> JsonValue;

        fn std::json::parse_object(self: &Parser) -> JsonValue;

        fn std::json::parse_string(self: &Parser) -> &str;

        fn std::json::parse_number(self: &Parser) -> &str;

        fn std::json::skip_ws(self: &Parser) -> ();

        fn std::json::expect_char(self: &Parser, ch: &str) -> ();

        fn std::json::starts_with(self: &Parser, literal: &str) -> bool;

        fn std::json::peek(self: &Parser) -> &str;

        fn std::json::is_eof(self: &Parser) -> bool;
    }

    pub fn std::json::is_number_char(ch: &str) -> bool;

    impl TypeBuilder {
    }

    pub struct std::net::addr::SocketAddr {
    }

    pub struct std::net::tcp::TcpStream {
    }

    impl TcpStream {
        fn std::net::tcp::connect(addr: SocketAddr) -> TcpStream;

        fn std::net::tcp::read(self: &TcpStream, buf: &[u8]) -> i64;

        fn std::net::tcp::write(self: &TcpStream, buf: &[u8]) -> i64;

        fn std::net::tcp::shutdown(self: &TcpStream) -> ();
    }

    pub struct std::net::tcp::TcpListener {
    }

    impl TcpListener {
        fn std::net::tcp::bind(addr: SocketAddr) -> TcpListener;

        fn std::net::tcp::accept(self: &TcpListener) -> TcpStream;
    }

    pub struct std::net::udp::UdpSocket {
    }

    impl UdpSocket {
        fn std::net::udp::bind(addr: SocketAddr) -> UdpSocket;

        fn std::net::udp::send_to(self: &UdpSocket, buf: &[u8], addr: SocketAddr) -> i64;

        fn std::net::udp::recv_from(self: &UdpSocket, buf: &[u8]) -> (i64, SocketAddr);
    }

    pub struct std::net::tls::TlsConnector {
    }

    impl TlsConnector {
        fn std::net::tls::connect(self: &TlsConnector, domain: &str, stream: TcpStream) -> std::net::tls::TlsStream;
    }

    pub struct std::net::tls::TlsAcceptor {
    }

    impl TlsAcceptor {
        fn std::net::tls::accept(self: &TlsAcceptor, stream: TcpStream) -> std::net::tls::TlsStream;
    }

    pub struct std::net::tls::TlsStream {
    }

    impl TlsStream {
        fn std::net::tls::read(self: &TlsStream, buf: &[u8]) -> i64;

        fn std::net::tls::write(self: &TlsStream, buf: &[u8]) -> i64;

        fn std::net::tls::shutdown(self: &TlsStream) -> ();
    }

    pub struct std::net::http::HttpClient {
    }

    impl HttpClient {
        fn std::net::http::send(self: &HttpClient, request: std::net::http::HttpRequest) -> std::net::http::HttpResponse;
    }

    pub struct std::net::http::HttpRequest {
    }

    impl HttpRequest {
        fn std::net::http::get(url: &str) -> HttpRequest;

        fn std::net::http::post(url: &str, body: &[u8]) -> HttpRequest;
    }

    pub struct std::net::http::HttpResponse {
    }

    impl HttpResponse {
        fn std::net::http::status(self: &HttpResponse) -> i64;

        fn std::net::http::body(self: &HttpResponse) -> &[u8];
    }

    pub struct std::net::ws::WsStream {
    }

    impl WsStream {
        fn std::net::ws::connect(url: &str) -> WsStream;

        fn std::net::ws::send(self: &WsStream, message: std::net::ws::WsMessage) -> ();

        fn std::net::ws::recv(self: &WsStream) -> std::net::ws::WsMessage;
    }

    pub struct std::net::ws::WsMessage {
    }

    impl WsMessage {
        fn std::net::ws::text(value: &str) -> WsMessage;

        fn std::net::ws::binary(value: &[u8]) -> WsMessage;
    }

    pub struct std::net::quic::QuicConnection {
    }

    impl QuicConnection {
        fn std::net::quic::connect(addr: SocketAddr, server_name: &str) -> QuicConnection;

        fn std::net::quic::open_bi(self: &QuicConnection) -> std::net::quic::QuicStream;
    }

    pub struct std::net::quic::QuicListener {
    }

    impl QuicListener {
        fn std::net::quic::bind(addr: SocketAddr) -> QuicListener;

        fn std::net::quic::accept(self: &QuicListener) -> QuicConnection;
    }

    pub struct std::net::quic::QuicStream {
    }

    impl QuicStream {
        fn std::net::quic::read(self: &QuicStream, buf: &[u8]) -> i64;

        fn std::net::quic::write(self: &QuicStream, buf: &[u8]) -> i64;

        fn std::net::quic::finish(self: &QuicStream) -> ();
    }

    pub enum std::proc_macro::Delimiter {
        Parenthesis,
        Brace,
        Bracket,
    }

    pub struct std::proc_macro::Group {
        pub delimiter: Delimiter,
        pub tokens: Vec<std::proc_macro::TokenTree>,
    }

    pub struct std::proc_macro::Ident {
        pub text: str,
    }

    pub struct std::proc_macro::Punct {
        pub text: str,
    }

    pub struct std::proc_macro::Literal {
        pub text: str,
    }

    pub enum std::proc_macro::TokenTree {
        Token,
        Group,
    }

    pub struct std::proc_macro::TokenStream {
    }

    pub fn std::proc_macro::token_stream_from_str(text: str) -> TokenStream;

    pub fn std::proc_macro::token_stream_to_string(stream: TokenStream) -> str;

    impl TokenStream {
        fn std::proc_macro::from_str(text: str) -> TokenStream;

        fn std::proc_macro::to_string(self: TokenStream) -> str;
    }

    pub struct std::task::Future<T> {
        pub handle: any,
    }

    pub struct std::task::Task<T> {
        pub handle: any,
    }

    pub fn std::task::spawn<T>(fut: any) -> Task<T>;

    pub struct std::test::TestCase {
        pub name: str,
        pub run: fn() -> (),
    }

    pub const std::test::REGISTRY: [TestCase; 0] =
        [];

    pub struct std::test::TestReport {
        pub total: i64,
        pub passed: i64,
        pub failed: i64,
    }

    pub fn std::test::run_tests() -> TestReport;

    pub fn std::test::run() -> TestReport;

    pub fn std::time::now() -> f64;

    pub fn std::time::sleep(seconds: f64) -> ();

    pub struct std::bench::BenchCase {
        pub name: str,
        pub run: fn() -> (),
    }

    pub const std::bench::REGISTRY: [BenchCase; 0] =
        [];

    pub struct std::bench::BenchReport {
        pub total: i64,
        pub passed: i64,
        pub failed: i64,
    }

    pub fn std::bench::run_benches() -> BenchReport;

    pub struct std::collections::HashMapEntry<K, V> {
        pub key: K,
        pub value: V,
    }

    pub struct std::collections::HashMap<K, V> {
        pub entries: Vec<HashMapEntry<K, V>>,
    }

    impl HashMap<K, V> {
        fn std::collections::from(entries: Vec<HashMapEntry<K, V>>) -> HashMap<K, V>;

        fn std::collections::len(self: &HashMap<K, V>) -> i64;

        fn std::collections::get_unchecked(self: &HashMap<K, V>, key: K) -> V;
    }

    pub struct std::ffi::CStr {
    }

    pub fn std::future::sleep(seconds: f64) -> std::task::Future<()>;

    pub struct std::json::JsonField {
        pub key: &str,
        pub value: std::json::JsonValue,
    }

    pub enum std::json::JsonValue {
        Null,
        Bool,
        Number,
        String,
        Array,
        Object,
    }

    pub fn std::json::parse(input: &str) -> JsonValue;

    pub fn std::json::print(value: JsonValue) -> ();

    pub fn std::json::print_value(value: &JsonValue) -> ();

    pub struct std::json::Parser {
        pub src: Vec<&str>,
        pub pos: i64,
    }

    impl Parser {
        fn std::json::new(src: &str) -> Parser;

        fn std::json::bump(self: &Parser, amount: i64) -> ();

        fn std::json::parse_value(self: &Parser) -> JsonValue;

        fn std::json::parse_array(self: &Parser) -> JsonValue;

        fn std::json::parse_object(self: &Parser) -> JsonValue;

        fn std::json::parse_string(self: &Parser) -> &str;

        fn std::json::parse_number(self: &Parser) -> &str;

        fn std::json::skip_ws(self: &Parser) -> ();

        fn std::json::expect_char(self: &Parser, ch: &str) -> ();

        fn std::json::starts_with(self: &Parser, literal: &str) -> bool;

        fn std::json::peek(self: &Parser) -> &str;

        fn std::json::is_eof(self: &Parser) -> bool;
    }

    pub fn std::json::is_number_char(ch: &str) -> bool;

    impl TypeBuilder {
    }

    pub struct std::net::addr::SocketAddr {
    }

    pub struct std::net::tcp::TcpStream {
    }

    impl TcpStream {
        fn std::net::tcp::connect(addr: SocketAddr) -> TcpStream;

        fn std::net::tcp::read(self: &TcpStream, buf: &[u8]) -> i64;

        fn std::net::tcp::write(self: &TcpStream, buf: &[u8]) -> i64;

        fn std::net::tcp::shutdown(self: &TcpStream) -> ();
    }

    pub struct std::net::tcp::TcpListener {
    }

    impl TcpListener {
        fn std::net::tcp::bind(addr: SocketAddr) -> TcpListener;

        fn std::net::tcp::accept(self: &TcpListener) -> TcpStream;
    }

    pub struct std::net::udp::UdpSocket {
    }

    impl UdpSocket {
        fn std::net::udp::bind(addr: SocketAddr) -> UdpSocket;

        fn std::net::udp::send_to(self: &UdpSocket, buf: &[u8], addr: SocketAddr) -> i64;

        fn std::net::udp::recv_from(self: &UdpSocket, buf: &[u8]) -> (i64, SocketAddr);
    }

    pub struct std::net::tls::TlsConnector {
    }

    impl TlsConnector {
        fn std::net::tls::connect(self: &TlsConnector, domain: &str, stream: TcpStream) -> std::net::tls::TlsStream;
    }

    pub struct std::net::tls::TlsAcceptor {
    }

    impl TlsAcceptor {
        fn std::net::tls::accept(self: &TlsAcceptor, stream: TcpStream) -> std::net::tls::TlsStream;
    }

    pub struct std::net::tls::TlsStream {
    }

    impl TlsStream {
        fn std::net::tls::read(self: &TlsStream, buf: &[u8]) -> i64;

        fn std::net::tls::write(self: &TlsStream, buf: &[u8]) -> i64;

        fn std::net::tls::shutdown(self: &TlsStream) -> ();
    }

    pub struct std::net::http::HttpClient {
    }

    impl HttpClient {
        fn std::net::http::send(self: &HttpClient, request: std::net::http::HttpRequest) -> std::net::http::HttpResponse;
    }

    pub struct std::net::http::HttpRequest {
    }

    impl HttpRequest {
        fn std::net::http::get(url: &str) -> HttpRequest;

        fn std::net::http::post(url: &str, body: &[u8]) -> HttpRequest;
    }

    pub struct std::net::http::HttpResponse {
    }

    impl HttpResponse {
        fn std::net::http::status(self: &HttpResponse) -> i64;

        fn std::net::http::body(self: &HttpResponse) -> &[u8];
    }

    pub struct std::net::ws::WsStream {
    }

    impl WsStream {
        fn std::net::ws::connect(url: &str) -> WsStream;

        fn std::net::ws::send(self: &WsStream, message: std::net::ws::WsMessage) -> ();

        fn std::net::ws::recv(self: &WsStream) -> std::net::ws::WsMessage;
    }

    pub struct std::net::ws::WsMessage {
    }

    impl WsMessage {
        fn std::net::ws::text(value: &str) -> WsMessage;

        fn std::net::ws::binary(value: &[u8]) -> WsMessage;
    }

    pub struct std::net::quic::QuicConnection {
    }

    impl QuicConnection {
        fn std::net::quic::connect(addr: SocketAddr, server_name: &str) -> QuicConnection;

        fn std::net::quic::open_bi(self: &QuicConnection) -> std::net::quic::QuicStream;
    }

    pub struct std::net::quic::QuicListener {
    }

    impl QuicListener {
        fn std::net::quic::bind(addr: SocketAddr) -> QuicListener;

        fn std::net::quic::accept(self: &QuicListener) -> QuicConnection;
    }

    pub struct std::net::quic::QuicStream {
    }

    impl QuicStream {
        fn std::net::quic::read(self: &QuicStream, buf: &[u8]) -> i64;

        fn std::net::quic::write(self: &QuicStream, buf: &[u8]) -> i64;

        fn std::net::quic::finish(self: &QuicStream) -> ();
    }

    pub enum std::proc_macro::Delimiter {
        Parenthesis,
        Brace,
        Bracket,
    }

    pub struct std::proc_macro::Group {
        pub delimiter: Delimiter,
        pub tokens: Vec<std::proc_macro::TokenTree>,
    }

    pub struct std::proc_macro::Ident {
        pub text: str,
    }

    pub struct std::proc_macro::Punct {
        pub text: str,
    }

    pub struct std::proc_macro::Literal {
        pub text: str,
    }

    pub enum std::proc_macro::TokenTree {
        Token,
        Group,
    }

    pub struct std::proc_macro::TokenStream {
    }

    pub fn std::proc_macro::token_stream_from_str(text: str) -> TokenStream;

    pub fn std::proc_macro::token_stream_to_string(stream: TokenStream) -> str;

    impl TokenStream {
        fn std::proc_macro::from_str(text: str) -> TokenStream;

        fn std::proc_macro::to_string(self: TokenStream) -> str;
    }

    pub struct std::task::Future<T> {
        pub handle: any,
    }

    pub struct std::task::Task<T> {
        pub handle: any,
    }

    pub fn std::task::spawn<T>(fut: any) -> Task<T>;

    pub struct std::test::TestCase {
        pub name: str,
        pub run: fn() -> (),
    }

    pub const std::test::REGISTRY: [TestCase; 0] =
        [];

    pub struct std::test::TestReport {
        pub total: i64,
        pub passed: i64,
        pub failed: i64,
    }

    pub fn std::test::run_tests() -> TestReport;

    pub fn std::test::run() -> TestReport;

    pub fn std::time::now() -> f64;

    pub fn std::time::sleep(seconds: f64) -> ();

    pub struct InAddr {
        pub s_addr: u32,
    }

    pub struct SockAddrIn {
        pub sin_family: u16,
        pub sin_port: u16,
        pub sin_addr: InAddr,
        pub sin_zero0: u32,
        pub sin_zero1: u32,
    }

    pub fn libc::socket(domain: i32, sock_type: i32, protocol: i32) -> i32;

    pub fn libc::bind(fd: i32, addr: *SockAddrIn, addrlen: u32) -> i32;

    pub fn libc::listen(fd: i32, backlog: i32) -> i32;

    pub fn libc::accept(fd: i32, addr: *SockAddrIn, addrlen: *u32) -> i32;

    pub fn libc::write(fd: i32, buf: *u8, count: usize) -> i64;

    pub fn libc::close(fd: i32) -> i32;

    pub fn libc::htons(hostshort: u16) -> u16;

    pub const AF_INET: i32 =
        2;

    pub const SOCK_STREAM: i32 =
        1;

    pub const INADDR_ANY: u32 =
        0;

    pub const SOCKADDR_LEN: u32 =
        16;

    pub const RESPONSE_LEN: usize =
        111;

    pub const RESPONSE: [u8; 111] =
        [72, 84, 84, 80, 47, 49, 46, 49, 32, 50, 48, 48, 32, 79, 75, 13, 10, 67, 111, 110, 116, 101, 110, 116, 45, 76, 101, 110, 103, 116, 104, 58, 32, 49, 50, 13, 10, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 32, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 116, 102, 45, 56, 13, 10, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 58, 32, 99, 108, 111, 115, 101, 13, 10, 13, 10, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 10];

    pub fn make_addr(port: u16) -> SockAddrIn {
        // params: [port: u16]
        {
            SockAddrIn { sin_family: (2 as u16), sin_port: libc::htons(hostshort = port), sin_addr: InAddr { s_addr: 0 }, sin_zero0: 0, sin_zero1: 0 }
        }
    }

    pub fn main() -> () {
        {
            let server_fd = libc::socket(domain = 2, sock_type = 1, protocol = 0);
            if ((server_fd < 0))
                {
                    std::println(arg0 = format_string("socket failed"));
                    return;
                }
            let addr = make_addr(port = 8080);
            let addr_ptr = (&addr as *SockAddrIn);
            let bind_rc = libc::bind(fd = server_fd, addr = addr_ptr, addrlen = 16);
            if ((bind_rc < 0))
                {
                    std::println(arg0 = format_string("bind failed"));
                    libc::close(fd = server_fd);
                    return;
                }
            let listen_rc = libc::listen(fd = server_fd, backlog = 16);
            if ((listen_rc < 0))
                {
                    std::println(arg0 = format_string("listen failed"));
                    libc::close(fd = server_fd);
                    return;
                }
            std::println(arg0 = format_string("listening on 0.0.0.0:8080"));
            loop
                {
                    let mut client_addr = make_addr(port = 0);
                    let mut client_len: u32 = 16;
                    let client_addr_ptr = (&mut client_addr as *SockAddrIn);
                    let client_len_ptr = (&mut client_len as *u32);
                    let client_fd = libc::accept(fd = server_fd, addr = client_addr_ptr, addrlen = client_len_ptr);
                    if ((client_fd < 0))
                        {
                            std::println(arg0 = format_string("accept failed"));
                            continue;
                        }
                    let response_ptr = (&[72, 84, 84, 80, 47, 49, 46, 49, 32, 50, 48, 48, 32, 79, 75, 13, 10, 67, 111, 110, 116, 101, 110, 116, 45, 76, 101, 110, 103, 116, 104, 58, 32, 49, 50, 13, 10, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 32, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 116, 102, 45, 56, 13, 10, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 58, 32, 99, 108, 111, 115, 101, 13, 10, 13, 10, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 10][0] as *u8);
                    let _ = libc::write(fd = client_fd, buf = response_ptr, count = 111);
                    libc::close(fd = client_fd);
                }
        }
    }
}
