fp-bytecode {
  const_pool:
    [0] 0
    [1] 0
    [2] 0
    [3] u64 0
    [4] true
    [5] f64 0.2
    [6] f64 0.5
    [7] 0
    [8] 0
    [9] true
    [10] false
    [11] false
    [12] 1
    [13] 0
    [14] true
    [15] false
    [16] false
    [17] 1
    [18] 1
    [19] f64 0
    [20] 1
    [21] 1
    [22] f64 1000000000
    [23] f64 0
    [24] 0
    [25] 0
    [26] 0
    [27] u64 0
    [28] true
    [29] false
    [30] 1
    [31] 1
    [32] 1
    [33] 1
    [34] 1
    [35] 1
    [36] 1
    [37] 1
    [38] 1
    [39] 0
    [40] 1
    [41] 2
    [42] 0
    [43] 1
    [44] 0
    [45] 0
    [46] 1
    [47] 2
    [48] 0
    [49] 5
    [50] 7
    [51] 1
    [52] 10
    [53] 5
    [54] 15
    [55] 24
    [56] 17
    [57] 10
    [58] 0
    [59] 1
    [60] 4
    [61] 1
    [62] 120
    [63] 4
    [64] 1
    [65] 1
    [66] 1
  functions:
    fn __closure0_call(params: 1, locals: 2)
      bb0:
        load.place _1.0
        terminator call fn BenchCase::run 1 -> _0 then bb1
      bb1:
        terminator return
    fn __closure1_call(params: 1, locals: 2)
      bb0:
        load.place _1.0
        terminator call fn BenchCase::run 1 -> _0 then bb1
      bb1:
        terminator return
    fn __closure2_call(params: 1, locals: 2)
      bb0:
        load.place _1.0
        terminator call fn TestCase::run 1 -> _0 then bb1
      bb1:
        terminator return
    fn std::bench::run_benches(params: 0, locals: 60)
      bb0:
        make.array 0
        store.place _2
        make.array 0
        store.place _3
        load.place _3
        store.place _1
        load.const 0
        store.place _4
        load.const 1
        store.place _5
        load.const 2
        store.place _6
        terminator jump bb1
      bb1:
        load.const 3
        store.place _8
        load.place _6
        load.place _8
        binop Lt
        store.place _7
        load.place _7
        terminator switch [1:bb2] otherwise bb3
      bb2:
        load.place _6
        store.place _10
        load.place _6
        store.place _11
        load.place _1[_11]
        store.place _9
        load.const 4
        store.place _12
        load.const 5
        store.place _13
        load.const 6
        store.place _14
        intrinsic TimeNow 0
        store.place _16
        load.place _16
        store.place _15
        load.place _15
        load.place _13
        binop Add
        store.place _18
        load.place _18
        store.place _17
        load.const 7
        store.place _19
        terminator jump bb4
      bb3:
        load.place _4
        load.place _5
        binop Add
        store.place _58
        load.place _58
        store.place _57
        load.place _4
        load.place _5
        load.place _57
        intrinsic Println 3 "bench result: %lld passed; %lld failed; %lld total\n"
        make.tuple 0
        store.place _59
        load.place _57
        load.place _4
        load.place _5
        make.tuple 3
        store.place _0
        terminator return
      bb4:
        intrinsic TimeNow 0
        store.place _21
        load.place _21
        load.place _17
        binop Lt
        store.place _20
        load.place _20
        terminator switch [1:bb5] otherwise bb6
      bb5:
        load.place _9
        make.tuple 1
        store.place _23
        load.place _23
        terminator call fn __closure0_call 1 -> _25 then bb7
      bb6:
        intrinsic TimeNow 0
        store.place _29
        load.place _29
        store.place _28
        load.place _28
        load.place _14
        binop Add
        store.place _31
        load.place _31
        store.place _30
        load.const 8
        store.place _32
        load.place _12
        terminator switch [1:bb14] otherwise bb15
      bb7:
        load.const 9
        store.place _24
        terminator jump bb9
      bb8:
        load.const 10
        store.place _24
        terminator jump bb9
      bb9:
        load.place _24
        store.place _22
        load.place _22
        unop Not
        store.place _27
        load.place _27
        terminator switch [1:bb10] otherwise bb11
      bb10:
        load.const 11
        store.place _12
        terminator jump bb6
      bb11:
        make.tuple 0
        store.place _26
        terminator jump bb12
      bb12:
        load.place _19
        load.const 12
        binop Add
        store.place _19
        terminator jump bb4
      bb13:
        make.tuple 0
        store.place _26
        terminator jump bb12
      bb14:
        terminator jump bb17
      bb15:
        make.tuple 0
        store.place _33
        terminator jump bb16
      bb16:
        intrinsic TimeNow 0
        store.place _45
        load.place _45
        store.place _44
        load.place _44
        load.place _28
        binop Sub
        store.place _47
        load.place _47
        store.place _46
        load.place _12
        terminator switch [1:bb27] otherwise bb28
      bb17:
        intrinsic TimeNow 0
        store.place _36
        load.place _36
        load.place _30
        binop Lt
        store.place _35
        load.place _32
        load.const 13
        binop Eq
        store.place _37
        load.place _35
        load.place _37
        binop Or
        store.place _34
        load.place _34
        terminator switch [1:bb18] otherwise bb19
      bb18:
        load.place _9
        make.tuple 1
        store.place _39
        load.place _39
        terminator call fn __closure1_call 1 -> _41 then bb20
      bb19:
        make.tuple 0
        store.place _33
        terminator jump bb16
      bb20:
        load.const 14
        store.place _40
        terminator jump bb22
      bb21:
        load.const 15
        store.place _40
        terminator jump bb22
      bb22:
        load.place _40
        store.place _38
        load.place _38
        unop Not
        store.place _43
        load.place _43
        terminator switch [1:bb23] otherwise bb24
      bb23:
        load.const 16
        store.place _12
        terminator jump bb19
      bb24:
        make.tuple 0
        store.place _42
        terminator jump bb25
      bb25:
        load.place _32
        load.const 17
        binop Add
        store.place _32
        terminator jump bb17
      bb26:
        make.tuple 0
        store.place _42
        terminator jump bb25
      bb27:
        load.place _4
        load.const 18
        binop Add
        store.place _4
        load.place _32
        store.place _50
        load.place _50
        store.place _49
        load.place _49
        load.const 19
        binop Gt
        store.place _53
        load.place _53
        terminator switch [1:bb30] otherwise bb31
      bb28:
        load.place _5
        load.const 20
        binop Add
        store.place _5
        load.place _9.0
        intrinsic Println 1 "  %s ... FAILED\n"
        make.tuple 0
        store.place _56
        make.tuple 0
        store.place _48
        terminator jump bb29
      bb29:
        load.place _6
        load.const 21
        binop Add
        store.place _6
        terminator jump bb1
      bb30:
        load.place _46
        load.place _49
        binop Div
        store.place _54
        load.place _54
        load.const 22
        binop Mul
        store.place _52
        terminator jump bb32
      bb31:
        load.const 23
        store.place _52
        terminator jump bb32
      bb32:
        load.place _52
        store.place _51
        load.place _9.0
        load.place _32
        load.place _46
        load.place _51
        intrinsic Println 4 "  %s ... ok (iters: %lld, time: %.6fs, ns/iter: %.2f)\n"
        make.tuple 0
        store.place _55
        make.tuple 0
        store.place _48
        terminator jump bb29
    fn std::test::run_tests(params: 0, locals: 22)
      bb0:
        make.array 0
        store.place _2
        make.array 0
        store.place _3
        load.place _3
        store.place _1
        load.const 24
        store.place _4
        load.const 25
        store.place _5
        load.const 26
        store.place _6
        terminator jump bb1
      bb1:
        load.const 27
        store.place _8
        load.place _6
        load.place _8
        binop Lt
        store.place _7
        load.place _7
        terminator switch [1:bb2] otherwise bb3
      bb2:
        load.place _6
        store.place _10
        load.place _6
        store.place _11
        load.place _1[_11]
        store.place _9
        load.place _9
        make.tuple 1
        store.place _13
        load.place _13
        terminator call fn __closure2_call 1 -> _15 then bb4
      bb3:
        load.place _4
        load.place _5
        binop Add
        store.place _20
        load.place _20
        store.place _19
        load.place _4
        load.place _5
        load.place _19
        intrinsic Println 3 "test result: %lld passed; %lld failed; %lld total\n"
        make.tuple 0
        store.place _21
        load.place _19
        load.place _4
        load.place _5
        make.tuple 3
        store.place _0
        terminator return
      bb4:
        load.const 28
        store.place _14
        terminator jump bb6
      bb5:
        load.const 29
        store.place _14
        terminator jump bb6
      bb6:
        load.place _14
        store.place _12
        load.place _12
        terminator switch [1:bb7] otherwise bb8
      bb7:
        load.place _4
        load.const 30
        binop Add
        store.place _4
        load.place _9.0
        intrinsic Println 1 "  %s ... ok\n"
        make.tuple 0
        store.place _17
        make.tuple 0
        store.place _16
        terminator jump bb9
      bb8:
        load.place _5
        load.const 31
        binop Add
        store.place _5
        load.place _9.0
        intrinsic Println 1 "  %s ... FAILED\n"
        make.tuple 0
        store.place _18
        make.tuple 0
        store.place _16
        terminator jump bb9
      bb9:
        load.place _6
        load.const 32
        binop Add
        store.place _6
        terminator jump bb1
    fn std::test::run(params: 0, locals: 1)
      bb0:
        terminator call fn std::test::run_tests 0 -> _0 then bb1
      bb1:
        terminator return
    fn std::time::now(params: 0, locals: 1)
      bb0:
        intrinsic TimeNow 0
        store.place _0
        terminator return
    fn factorial(params: 1, locals: 5)
      bb0:
        load.const 33
        store.place _2
        load.const 34
        store.place _3
        terminator jump bb1
      bb1:
        load.place _3
        load.place _1
        binop Le
        store.place _4
        load.place _4
        terminator switch [1:bb2] otherwise bb3
      bb2:
        load.place _2
        load.place _3
        binop Mul
        store.place _2
        load.place _3
        load.const 35
        binop Add
        store.place _3
        terminator jump bb1
      bb3:
        load.place _2
        store.place _0
        terminator return
    fn const_factorial(params: 1, locals: 5)
      bb0:
        load.place _1
        load.const 36
        binop Le
        store.place _2
        load.place _2
        terminator switch [1:bb1] otherwise bb2
      bb1:
        load.const 37
        store.place _0
        terminator jump bb3
      bb2:
        load.place _1
        load.const 38
        binop Sub
        store.place _4
        load.place _4
        terminator call fn const_factorial 1 -> _3 then bb4
      bb3:
        terminator return
      bb4:
        load.place _1
        load.place _3
        binop Mul
        store.place _0
        terminator jump bb3
    fn sum_range(params: 2, locals: 7)
      bb0:
        load.const 39
        store.place _3
        load.place _1
        store.place _5
        terminator jump bb1
      bb1:
        load.place _5
        load.place _2
        binop Lt
        store.place _6
        load.place _6
        terminator switch [1:bb2] otherwise bb3
      bb2:
        load.place _3
        load.place _5
        binop Add
        store.place _3
        load.place _5
        load.const 40
        binop Add
        store.place _5
        terminator jump bb1
      bb3:
        make.tuple 0
        store.place _4
        load.place _3
        store.place _0
        terminator return
    fn find_first_divisor(params: 1, locals: 9)
      bb0:
        load.const 41
        store.place _2
        terminator jump bb1
      bb1:
        terminator jump bb2
      bb2:
        load.place _2
        load.place _2
        binop Mul
        store.place _5
        load.place _5
        load.place _1
        binop Gt
        store.place _4
        load.place _4
        terminator switch [1:bb4] otherwise bb5
      bb3:
        terminator return
      bb4:
        load.place _1
        store.place _0
        terminator jump bb3
      bb5:
        make.tuple 0
        store.place _3
        terminator jump bb6
      bb6:
        load.place _1
        load.place _2
        binop Rem
        store.place _8
        load.place _8
        load.const 42
        binop Eq
        store.place _7
        load.place _7
        terminator switch [1:bb8] otherwise bb9
      bb7:
        make.tuple 0
        store.place _3
        terminator jump bb6
      bb8:
        load.place _2
        store.place _0
        terminator jump bb3
      bb9:
        make.tuple 0
        store.place _6
        terminator jump bb10
      bb10:
        load.place _2
        load.const 43
        binop Add
        store.place _2
        terminator jump bb1
      bb11:
        make.tuple 0
        store.place _6
        terminator jump bb10
    fn sum_even_numbers(params: 1, locals: 8)
      bb0:
        load.const 44
        store.place _2
        load.const 45
        store.place _3
        terminator jump bb1
      bb1:
        load.place _3
        load.place _1
        binop Lt
        store.place _4
        load.place _4
        terminator switch [1:bb2] otherwise bb3
      bb2:
        load.place _3
        load.const 46
        binop Add
        store.place _3
        load.place _3
        load.const 47
        binop Rem
        store.place _7
        load.place _7
        load.const 48
        binop Ne
        store.place _6
        load.place _6
        terminator switch [1:bb4] otherwise bb5
      bb3:
        load.place _2
        store.place _0
        terminator return
      bb4:
        terminator jump bb1
      bb5:
        make.tuple 0
        store.place _5
        terminator jump bb6
      bb6:
        load.place _2
        load.place _3
        binop Add
        store.place _2
        terminator jump bb1
      bb7:
        make.tuple 0
        store.place _5
        terminator jump bb6
    fn main(params: 0, locals: 41)
      bb0:
        intrinsic Println 0 "ðŸ“˜ Tutorial: 13_loops.fp\n"
        make.tuple 0
        store.place _1
        intrinsic Println 0 "ðŸ§­ Focus: Loop constructs: while, for, and loop.\n"
        make.tuple 0
        store.place _2
        intrinsic Println 0 "ðŸ§ª What to look for: labeled outputs below\n"
        make.tuple 0
        store.place _3
        intrinsic Println 0 "âœ… Expectation: outputs match labels\n"
        make.tuple 0
        store.place _4
        intrinsic Println 0 "\n"
        make.tuple 0
        store.place _5
        intrinsic Println 0 "=== Loop Constructs ===\n\n"
        make.tuple 0
        store.place _6
        intrinsic Println 0 "1. While loop - factorial:\n"
        make.tuple 0
        store.place _7
        load.const 49
        terminator call fn factorial 1 -> _8 then bb1
      bb1:
        load.place _8
        intrinsic Println 1 "  5! = %lld\n"
        make.tuple 0
        store.place _9
        load.const 50
        terminator call fn factorial 1 -> _10 then bb2
      bb2:
        load.place _10
        intrinsic Println 1 "  7! = %lld\n"
        make.tuple 0
        store.place _11
        intrinsic Println 0 "\n2. For loop - sum range:\n"
        make.tuple 0
        store.place _12
        load.const 51
        load.const 52
        terminator call fn sum_range 2 -> _13 then bb3
      bb3:
        load.place _13
        intrinsic Println 1 "  sum(1..10) = %lld\n"
        make.tuple 0
        store.place _14
        load.const 53
        load.const 54
        terminator call fn sum_range 2 -> _15 then bb4
      bb4:
        load.place _15
        intrinsic Println 1 "  sum(5..15) = %lld\n"
        make.tuple 0
        store.place _16
        intrinsic Println 0 "\n3. Loop with break expression:\n"
        make.tuple 0
        store.place _17
        load.const 55
        terminator call fn find_first_divisor 1 -> _18 then bb5
      bb5:
        load.place _18
        intrinsic Println 1 "  First divisor of 24: %lld\n"
        make.tuple 0
        store.place _19
        load.const 56
        terminator call fn find_first_divisor 1 -> _20 then bb6
      bb6:
        load.place _20
        intrinsic Println 1 "  First divisor of 17: %lld\n"
        make.tuple 0
        store.place _21
        intrinsic Println 0 "\n4. Loop with continue:\n"
        make.tuple 0
        store.place _22
        load.const 57
        terminator call fn sum_even_numbers 1 -> _23 then bb7
      bb7:
        load.place _23
        intrinsic Println 1 "  Sum of even numbers < 10: %lld\n"
        make.tuple 0
        store.place _24
        intrinsic Println 0 "\n5. Nested loops:\n"
        make.tuple 0
        store.place _25
        load.const 58
        store.place _26
        load.const 59
        store.place _28
        terminator jump bb8
      bb8:
        load.place _28
        load.const 60
        binop Lt
        store.place _29
        load.place _29
        terminator switch [1:bb9] otherwise bb10
      bb9:
        load.const 61
        store.place _31
        terminator jump bb11
      bb10:
        make.tuple 0
        store.place _27
        load.place _26
        intrinsic Println 1 "\n  Iterations: %lld\n"
        make.tuple 0
        store.place _36
        intrinsic Println 0 "\n6. Compile-time recursion:\n"
        make.tuple 0
        store.place _37
        load.const 62
        store.place _38
        load.place _38
        intrinsic Println 1 "  const_factorial(5) = %lld\n"
        make.tuple 0
        store.place _39
        intrinsic Println 0 "\nâœ“ Loop constructs demonstrated!\n"
        make.tuple 0
        store.place _40
        terminator return
      bb11:
        load.place _31
        load.const 63
        binop Lt
        store.place _32
        load.place _32
        terminator switch [1:bb12] otherwise bb13
      bb12:
        load.place _26
        load.const 64
        binop Add
        store.place _26
        load.place _28
        load.place _31
        binop Eq
        store.place _34
        load.place _34
        terminator switch [1:bb14] otherwise bb15
      bb13:
        make.tuple 0
        store.place _30
        load.place _28
        load.const 65
        binop Add
        store.place _28
        terminator jump bb8
      bb14:
        load.place _28
        intrinsic Print 1 "[%lld] "
        make.tuple 0
        store.place _35
        make.tuple 0
        store.place _33
        terminator jump bb16
      bb15:
        make.tuple 0
        store.place _33
        terminator jump bb16
      bb16:
        load.place _31
        load.const 66
        binop Add
        store.place _31
        terminator jump bb11
    fn BenchCase::run(params: 1, locals: 2)
      bb0:
        terminator return
    fn TestCase::run(params: 1, locals: 2)
      bb0:
        terminator return
  entry: main
}
