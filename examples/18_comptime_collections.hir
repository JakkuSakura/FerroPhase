hir::Program {
    pub struct std::collections::HashMapEntry<K, V> {
        pub key: K,
        pub value: V,
    }

    pub struct std::collections::HashMap<K, V> {
        pub entries: Vec<HashMapEntry<K, V>>,
    }

    impl HashMap<K, V> {
        fn std::collections::from(entries: Vec<HashMapEntry<K, V>>) -> HashMap<K, V> {
            // params: [entries: Vec<HashMapEntry<K, V>>]
            {
                HashMap { entries: entries }
            }
        }

        fn std::collections::len(self: &HashMap<K, V>) -> i64 {
            // params: [self: &HashMap<K, V>]
            {
                self.entries.len()
            }
        }

        fn std::collections::get_unchecked(self: &HashMap<K, V>, key: K) -> V {
            // params: [self: &HashMap<K, V>, key: K]
            {
                let mut idx = 0;
                while ((idx < self.entries.len()))
                    {
                        let entry = self.entries[idx];
                        if ((entry.key == key))
                            {
                                return entry.value;
                            }
                        idx = (idx + 1);
                    }
                loop
                    {
                    }
            }
        }
    }

    pub const PRIMES: [i64; 6] =
        [2, 3, 5, 7, 11, 13];

    pub const ZERO_BUFFER: [i64; 16] =
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    pub const HTTP_STATUSES: HashMap<&str, i64> =
        [["ok", 200], ["created", 201], ["accepted", 202], ["not_found", 404]];

    pub fn main() -> () {
        {
            printf("ðŸ“˜ Tutorial: 18_comptime_collections.fp\n");
            printf("ðŸ§­ Focus: Showcase compile-time Vec and HashMap construction.\n");
            printf("ðŸ§ª What to look for: labeled outputs below\n");
            printf("âœ… Expectation: outputs match labels\n");
            printf("\n");
            printf("=== Compile-time Collections ===\n");
            printf("Vec literals:\n");
            std::Println(2 args);
            printf("  zero buffer: %lld elements\n", ZERO_BUFFER.len());
            printf("  first four zeros: [%lld, %lld, %lld, %lld]\n", ZERO_BUFFER[0], ZERO_BUFFER[1], ZERO_BUFFER[2], ZERO_BUFFER[3]);
            printf("\nHashMap literal via HashMap::from:\n");
            printf("  tracked HTTP statuses: %lld entries\n", HTTP_STATUSES.len());
            std::Println(1 args);
            std::Println(1 args);
        }
    }
}
