ast::File {
  items:
    pub module std : _ {
      pub module bench : _ {
        pub struct BenchCase : _ {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<Expr(BenchCase)> : _
          value [0 values] : _
        pub struct BenchReport : _ {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_benches() -> Expr(BenchReport) : _
          block (8 stmts) : _
            let benches: Vec<Expr(BenchCase)>
              init:
                value [0 values] : _
            let mut passed
              init:
                value 0 : _
            let mut failed
              init:
                value 0 : _
            let mut idx
              init:
                value 0 : _
            expr_stmt (value)
              while : _
                cond:
                  binop < : _
                    lhs:
                      locator idx : _
                    rhs:
                      invoke : _
                        target: benches.len
                body:
                  block (16 stmts) : _
                    let bench: Expr(BenchCase)
                      init:
                        index : _
                          value:
                            locator benches : _
                          index:
                            locator idx : _
                    let mut ok
                      init:
                        value true : _
                    let warmup_secs
                      init:
                        value 5 : _
                    let measure_secs
                      init:
                        value 15 : _
                    let warmup_start
                      init:
                        intrinsic time_now : _
                          args: []
                          kwargs: []
                    let warmup_deadline
                      init:
                        binop + : _
                          lhs:
                            locator warmup_start : _
                          rhs:
                            locator warmup_secs : _
                    let mut warmup_iters
                      init:
                        value 0 : _
                    expr_stmt (value)
                      while : _
                        cond:
                          binop < : _
                            lhs:
                              intrinsic time_now : _
                                args: []
                                kwargs: []
                            rhs:
                              locator warmup_deadline : _
                        body:
                          block (3 stmts) : _
                            let warm_ok
                              init:
                                intrinsic catch_unwind : _
                                  args:
                                    select .run [unknown] : _
                                      object:
                                        locator bench : _
                                  kwargs: []
                            expr_stmt (value)
                              if : _
                                cond:
                                  unop ! : _
                                    value:
                                      locator warm_ok : _
                                then:
                                  block (2 stmts) : _
                                    expr_stmt ;
                                      assign : _
                                        target:
                                          locator ok : _
                                        value:
                                          value false : _
                                    expr_stmt ;
                                      break : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator warmup_iters : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator warmup_iters : _
                                    rhs:
                                      value 1 : _
                    let measure_start
                      init:
                        intrinsic time_now : _
                          args: []
                          kwargs: []
                    let measure_deadline
                      init:
                        binop + : _
                          lhs:
                            locator measure_start : _
                          rhs:
                            locator measure_secs : _
                    let mut measure_iters
                      init:
                        value 0 : _
                    expr_stmt (value)
                      if : _
                        cond:
                          locator ok : _
                        then:
                          block (1 stmt) : _
                            expr_stmt (value)
                              while : _
                                cond:
                                  binop || : _
                                    lhs:
                                      binop < : _
                                        lhs:
                                          intrinsic time_now : _
                                            args: []
                                            kwargs: []
                                        rhs:
                                          locator measure_deadline : _
                                    rhs:
                                      binop == : _
                                        lhs:
                                          locator measure_iters : _
                                        rhs:
                                          value 0 : _
                                body:
                                  block (3 stmts) : _
                                    let run_ok
                                      init:
                                        intrinsic catch_unwind : _
                                          args:
                                            select .run [unknown] : _
                                              object:
                                                locator bench : _
                                          kwargs: []
                                    expr_stmt (value)
                                      if : _
                                        cond:
                                          unop ! : _
                                            value:
                                              locator run_ok : _
                                        then:
                                          block (2 stmts) : _
                                            expr_stmt ;
                                              assign : _
                                                target:
                                                  locator ok : _
                                                value:
                                                  value false : _
                                            expr_stmt ;
                                              break : _
                                    expr_stmt ;
                                      assign : _
                                        target:
                                          locator measure_iters : _
                                        value:
                                          binop + : _
                                            lhs:
                                              locator measure_iters : _
                                            rhs:
                                              value 1 : _
                    let measure_end
                      init:
                        intrinsic time_now : _
                          args: []
                          kwargs: []
                    let elapsed
                      init:
                        binop - : _
                          lhs:
                            locator measure_end : _
                          rhs:
                            locator measure_start : _
                    expr_stmt (value)
                      if : _
                        cond:
                          locator ok : _
                        then:
                          block (4 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator passed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator passed : _
                                    rhs:
                                      value 1 : _
                            let iters_f
                              init:
                                cast : _ -> Expr(f64)
                                  locator measure_iters : _
                            let ns_per_iter
                              init:
                                if : _
                                  cond:
                                    binop > : _
                                      lhs:
                                        locator iters_f : _
                                      rhs:
                                        value 0 : _
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt (value)
                                        binop * : _
                                          lhs:
                                            binop / : _
                                              lhs:
                                                locator elapsed : _
                                              rhs:
                                                locator iters_f : _
                                          rhs:
                                            value 1000000000 : _
                                  else:
                                    block (1 stmt) : _
                                      expr_stmt (value)
                                        value 0 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... ok (iters: {}, time: {:.6}s, ns/iter: {:.2})" : _
                                  select .name [unknown] : _
                                    object:
                                      locator bench : _
                                  locator measure_iters : _
                                  locator elapsed : _
                                  locator ns_per_iter : _
                                kwargs: []
                        else:
                          block (2 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator failed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator failed : _
                                    rhs:
                                      value 1 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... FAILED" : _
                                  select .name [unknown] : _
                                    object:
                                      locator bench : _
                                kwargs: []
                    expr_stmt ;
                      assign : _
                        target:
                          locator idx : _
                        value:
                          binop + : _
                            lhs:
                              locator idx : _
                            rhs:
                              value 1 : _
            let total
              init:
                binop + : _
                  lhs:
                    locator passed : _
                  rhs:
                    locator failed : _
            expr_stmt ;
              intrinsic println : _
                args:
                  format_string "bench result: {} passed; {} failed; {} total" : _
                  locator passed : _
                  locator failed : _
                  locator total : _
                kwargs: []
            expr_stmt (value)
              struct BenchReport : _
                total:
                  locator total : _
                passed:
                  locator passed : _
                failed:
                  locator failed : _
      }
      pub module collections : _ {
        pub struct HashMapEntry : _ {
          key: Expr(K)
          value: Expr(V)
        }
        pub struct HashMap : _ {
          entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>
        }
        impl HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })> : _ {
          pub fn from(entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>) -> Expr(HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>) : _
            block (1 stmt) : _
              expr_stmt (value)
                struct HashMap : _
                  entries:
                    locator entries : _
          pub fn len(&self) -> Expr(i64) : _
            block (1 stmt) : _
              expr_stmt (value)
                invoke : _
                  target: self.entries.len
          pub fn get_unchecked(&self, key: Expr(K)) -> Expr(V) : _
            block (3 stmts) : _
              let mut idx
                init:
                  value 0 : _
              expr_stmt (value)
                while : _
                  cond:
                    binop < : _
                      lhs:
                        locator idx : _
                      rhs:
                        invoke : _
                          target: self.entries.len
                  body:
                    block (3 stmts) : _
                      let entry
                        init:
                          index : _
                            value:
                              select .entries [unknown] : _
                                object:
                                  locator self : _
                            index:
                              locator idx : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop == : _
                              lhs:
                                select .key [unknown] : _
                                  object:
                                    locator entry : _
                              rhs:
                                locator key : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                return : _
                                  select .value [unknown] : _
                                    object:
                                      locator entry : _
                      expr_stmt ;
                        assign : _
                          target:
                            locator idx : _
                          value:
                            binop + : _
                              lhs:
                                locator idx : _
                              rhs:
                                value 1 : _
              expr_stmt (value)
                loop : _
                  block (0 stmts) : _
        }
      }
      pub module ffi : _ {
        pub struct CStr : _ {
        }
      }
      pub module future : _ {
        pub fn sleep(seconds: Expr(f64)) -> Expr(std::task::Future<Unit(TypeUnit)>) : _
          block (1 stmt) : _
            expr_stmt (value)
              struct std::task::Future : _
                handle:
                  async : _
                    block (2 stmts) : _
                      expr_stmt ;
                        intrinsic sleep : _
                          args:
                            locator seconds : _
                          kwargs: []
                      expr_stmt (value)
                        value () : _
      }
      pub module json : _ {
        pub struct JsonField : _ {
          key: &Expr(str)
          value: Expr(JsonValue)
        }
        pub enum JsonValue : _ {
          Null: ()
          Bool: (Expr(bool))
          Number: (&Expr(str))
          String: (&Expr(str))
          Array: (Vec<Expr(JsonValue)>)
          Object: (Vec<Expr(JsonField)>)
        }
        pub fn parse(input: &Expr(str)) -> Expr(JsonValue) : _
          block (2 stmts) : _
            let mut parser
              init:
                invoke : _
                  target: Parser::new
                  args:
                    locator input : _
            expr_stmt (value)
              invoke : _
                target: parser.parse_value
        pub fn print(value: Expr(JsonValue)) : _
          block (1 stmt) : _
            expr_stmt ;
              invoke : _
                target: print_value
                args:
                  reference (mutable: unspecified) : _
                    locator value : _
        pub fn print_value(value: &Expr(JsonValue)) : _
          block (1 stmt) : _
            expr_stmt (value)
              match : _
                case #0
                  cond:
                    value true : _
                  body:
                    intrinsic print : _
                      args:
                        format_string "null" : _
                      kwargs: []
                case #1
                  cond:
                    value true : _
                  body:
                    block (1 stmt) : _
                      expr_stmt (value)
                        if : _
                          cond:
                            locator b : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "true" : _
                                  kwargs: []
                          else:
                            block (1 stmt) : _
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "false" : _
                                  kwargs: []
                case #2
                  cond:
                    value true : _
                  body:
                    intrinsic print : _
                      args:
                        format_string "{}" : _
                        locator n : _
                      kwargs: []
                case #3
                  cond:
                    value true : _
                  body:
                    block (3 stmts) : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "\"" : _
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "{}" : _
                            locator s : _
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "\"" : _
                          kwargs: []
                case #4
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "[" : _
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : _
                      let items_len
                        init:
                          invoke : _
                            target: items.len
                      expr_stmt (value)
                        while : _
                          cond:
                            binop < : _
                              lhs:
                                locator idx : _
                              rhs:
                                locator items_len : _
                          body:
                            block (4 stmts) : _
                              expr_stmt (value)
                                if : _
                                  cond:
                                    binop > : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 0 : _
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt ;
                                        intrinsic print : _
                                          args:
                                            format_string "," : _
                                          kwargs: []
                              let item
                                init:
                                  index : _
                                    value:
                                      locator items : _
                                    index:
                                      locator idx : _
                              expr_stmt ;
                                invoke : _
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : _
                                      locator item : _
                              expr_stmt ;
                                assign : _
                                  target:
                                    locator idx : _
                                  value:
                                    binop + : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 1 : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "]" : _
                          kwargs: []
                case #5
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "{" : _
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : _
                      let fields_len
                        init:
                          invoke : _
                            target: fields.len
                      expr_stmt (value)
                        while : _
                          cond:
                            binop < : _
                              lhs:
                                locator idx : _
                              rhs:
                                locator fields_len : _
                          body:
                            block (7 stmts) : _
                              expr_stmt (value)
                                if : _
                                  cond:
                                    binop > : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 0 : _
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt ;
                                        intrinsic print : _
                                          args:
                                            format_string "," : _
                                          kwargs: []
                              let field
                                init:
                                  index : _
                                    value:
                                      locator fields : _
                                    index:
                                      locator idx : _
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "\"" : _
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "{}" : _
                                    select .key [unknown] : _
                                      object:
                                        locator field : _
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "\":" : _
                                  kwargs: []
                              expr_stmt ;
                                invoke : _
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : _
                                      select .value [unknown] : _
                                        object:
                                          locator field : _
                              expr_stmt ;
                                assign : _
                                  target:
                                    locator idx : _
                                  value:
                                    binop + : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 1 : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "}" : _
                          kwargs: []
        pub struct Parser : _ {
          src: Vec<&Expr(str)>
          pos: Expr(i64)
        }
        impl Parser : _ {
          pub fn new(src: &Expr(str)) -> Expr(Parser) : _
            block (5 stmts) : _
              let mut chars
                init:
                  value [0 values] : _
              let mut idx
                init:
                  value 0 : _
              let src_len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: src.len
              expr_stmt (value)
                while : _
                  cond:
                    binop < : _
                      lhs:
                        locator idx : _
                      rhs:
                        locator src_len : _
                  body:
                    block (4 stmts) : _
                      let offset
                        init:
                          cast : _ -> Expr(usize)
                            locator idx : _
                      let ch
                        init:
                          index : _
                            value:
                              locator src : _
                            index:
                              range [exclusive] : _
                                start:
                                  locator offset : _
                                end:
                                  binop + : _
                                    lhs:
                                      locator offset : _
                                    rhs:
                                      value 1 : _
                      expr_stmt ;
                        invoke : _
                          target: chars.push
                          args:
                            locator ch : _
                      expr_stmt ;
                        assign : _
                          target:
                            locator idx : _
                          value:
                            binop + : _
                              lhs:
                                locator idx : _
                              rhs:
                                value 1 : _
              expr_stmt (value)
                struct Parser : _
                  src:
                    locator chars : _
                  pos:
                    value 0 : _
          pub fn bump(&mut self, amount: Expr(i64)) : _
            block (1 stmt) : _
              expr_stmt ;
                assign : _
                  target:
                    select .pos [unknown] : _
                      object:
                        locator self : _
                  value:
                    binop + : _
                      lhs:
                        select .pos [unknown] : _
                          object:
                            locator self : _
                      rhs:
                        locator amount : _
          pub fn parse_value(&mut self) -> Expr(JsonValue) : _
            block (9 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.skip_ws
              let ch
                init:
                  invoke : _
                    target: self.peek
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        locator ch : _
                      rhs:
                        value "{" : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: self.parse_object
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        locator ch : _
                      rhs:
                        value "[" : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: self.parse_array
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        locator ch : _
                      rhs:
                        value "\"" : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::String
                            args:
                              invoke : _
                                target: self.parse_string
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.starts_with
                      args:
                        value "true" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 4 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Bool
                            args:
                              value true : _
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.starts_with
                      args:
                        value "false" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 5 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Bool
                            args:
                              value false : _
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.starts_with
                      args:
                        value "null" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 4 : _
                      expr_stmt ;
                        return : _
                          locator JsonValue::Null : _
              expr_stmt (value)
                invoke : _
                  target: JsonValue::Number
                  args:
                    invoke : _
                      target: self.parse_number
          pub fn parse_array(&mut self) -> Expr(JsonValue) : _
            block (6 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.expect_char
                  args:
                    value "[" : _
              expr_stmt ;
                invoke : _
                  target: self.skip_ws
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        invoke : _
                          target: self.peek
                      rhs:
                        value "]" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Array
                            args:
                              value [0 values] : _
              let mut items
                init:
                  value [0 values] : _
              expr_stmt (value)
                loop : _
                  block (6 stmts) : _
                    let value
                      init:
                        invoke : _
                          target: self.parse_value
                    expr_stmt ;
                      invoke : _
                        target: items.push
                        args:
                          locator value : _
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : _
                          target: self.peek
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "," : _
                        then:
                          block (3 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              invoke : _
                                target: self.skip_ws
                            expr_stmt ;
                              continue : _
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "]" : _
                        then:
                          block (2 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              break : _
              expr_stmt (value)
                invoke : _
                  target: JsonValue::Array
                  args:
                    locator items : _
          pub fn parse_object(&mut self) -> Expr(JsonValue) : _
            block (6 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.expect_char
                  args:
                    value "{" : _
              expr_stmt ;
                invoke : _
                  target: self.skip_ws
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        invoke : _
                          target: self.peek
                      rhs:
                        value "}" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Object
                            args:
                              value [0 values] : _
              let mut fields
                init:
                  value [0 values] : _
              expr_stmt (value)
                loop : _
                  block (10 stmts) : _
                    let key
                      init:
                        invoke : _
                          target: self.parse_string
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    expr_stmt ;
                      invoke : _
                        target: self.expect_char
                        args:
                          value ":" : _
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    let value
                      init:
                        invoke : _
                          target: self.parse_value
                    expr_stmt ;
                      invoke : _
                        target: fields.push
                        args:
                          struct JsonField : _
                            key:
                              locator key : _
                            value:
                              locator value : _
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : _
                          target: self.peek
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "," : _
                        then:
                          block (3 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              invoke : _
                                target: self.skip_ws
                            expr_stmt ;
                              continue : _
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "}" : _
                        then:
                          block (2 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              break : _
              expr_stmt (value)
                invoke : _
                  target: JsonValue::Object
                  args:
                    locator fields : _
          pub fn parse_string(&mut self) -> &Expr(str) : _
            block (4 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.expect_char
                  args:
                    value "\"" : _
              let start
                init:
                  cast : _ -> Expr(usize)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              expr_stmt (value)
                while : _
                  cond:
                    unop ! : _
                      value:
                        invoke : _
                          target: self.is_eof
                  body:
                    block (4 stmts) : _
                      let ch
                        init:
                          invoke : _
                            target: self.peek
                      expr_stmt (value)
                        if : _
                          cond:
                            binop == : _
                              lhs:
                                locator ch : _
                              rhs:
                                value "\"" : _
                          then:
                            block (3 stmts) : _
                              let value
                                init:
                                  index : _
                                    value:
                                      select .src [unknown] : _
                                        object:
                                          locator self : _
                                    index:
                                      range [exclusive] : _
                                        start:
                                          locator start : _
                                        end:
                                          cast : _ -> Expr(usize)
                                            select .pos [unknown] : _
                                              object:
                                                locator self : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                              expr_stmt ;
                                return : _
                                  locator value : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop == : _
                              lhs:
                                locator ch : _
                              rhs:
                                value "\\" : _
                          then:
                            block (3 stmts) : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                              expr_stmt (value)
                                if : _
                                  cond:
                                    unop ! : _
                                      value:
                                        invoke : _
                                          target: self.is_eof
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt ;
                                        invoke : _
                                          target: self.bump
                                          args:
                                            value 1 : _
                              expr_stmt ;
                                continue : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
              expr_stmt (value)
                index : _
                  value:
                    select .src [unknown] : _
                      object:
                        locator self : _
                  index:
                    range [exclusive] : _
                      start:
                        locator start : _
                      end:
                        cast : _ -> Expr(usize)
                          select .pos [unknown] : _
                            object:
                              locator self : _
          pub fn parse_number(&mut self) -> &Expr(str) : _
            block (3 stmts) : _
              let start
                init:
                  cast : _ -> Expr(usize)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              expr_stmt (value)
                while : _
                  cond:
                    unop ! : _
                      value:
                        invoke : _
                          target: self.is_eof
                  body:
                    block (2 stmts) : _
                      let ch
                        init:
                          invoke : _
                            target: self.peek
                      expr_stmt (value)
                        if : _
                          cond:
                            invoke : _
                              target: is_number_char
                              args:
                                locator ch : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                          else:
                            block (1 stmt) : _
                              expr_stmt ;
                                break : _
              expr_stmt (value)
                index : _
                  value:
                    select .src [unknown] : _
                      object:
                        locator self : _
                  index:
                    range [exclusive] : _
                      start:
                        locator start : _
                      end:
                        cast : _ -> Expr(usize)
                          select .pos [unknown] : _
                            object:
                              locator self : _
          pub fn skip_ws(&mut self) : _
            block (1 stmt) : _
              expr_stmt (value)
                while : _
                  cond:
                    unop ! : _
                      value:
                        invoke : _
                          target: self.is_eof
                  body:
                    block (2 stmts) : _
                      let ch
                        init:
                          invoke : _
                            target: self.peek
                      expr_stmt (value)
                        if : _
                          cond:
                            binop || : _
                              lhs:
                                binop || : _
                                  lhs:
                                    binop || : _
                                      lhs:
                                        binop == : _
                                          lhs:
                                            locator ch : _
                                          rhs:
                                            value " " : _
                                      rhs:
                                        binop == : _
                                          lhs:
                                            locator ch : _
                                          rhs:
                                            value "\n" : _
                                  rhs:
                                    binop == : _
                                      lhs:
                                        locator ch : _
                                      rhs:
                                        value "\t" : _
                              rhs:
                                binop == : _
                                  lhs:
                                    locator ch : _
                                  rhs:
                                    value "\r" : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                          else:
                            block (1 stmt) : _
                              expr_stmt ;
                                break : _
          pub fn expect_char(&mut self, ch: &Expr(str)) : _
            block (1 stmt) : _
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        invoke : _
                          target: self.peek
                      rhs:
                        locator ch : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
          pub fn starts_with(&self, literal: &Expr(str)) -> Expr(bool) : _
            block (7 stmts) : _
              let pos
                init:
                  cast : _ -> Expr(usize)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              let mut idx
                init:
                  value 0 : _
              let literal_len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: literal.len
              let src_len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: self.src.len
              let pos_i64
                init:
                  cast : _ -> Expr(i64)
                    locator pos : _
              expr_stmt (value)
                while : _
                  cond:
                    binop < : _
                      lhs:
                        locator idx : _
                      rhs:
                        locator literal_len : _
                  body:
                    block (4 stmts) : _
                      let offset
                        init:
                          cast : _ -> Expr(usize)
                            locator idx : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop >= : _
                              lhs:
                                binop + : _
                                  lhs:
                                    locator pos_i64 : _
                                  rhs:
                                    locator idx : _
                              rhs:
                                locator src_len : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                return : _
                                  value false : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop != : _
                              lhs:
                                index : _
                                  value:
                                    select .src [unknown] : _
                                      object:
                                        locator self : _
                                  index:
                                    binop + : _
                                      lhs:
                                        locator pos : _
                                      rhs:
                                        locator offset : _
                              rhs:
                                index : _
                                  value:
                                    locator literal : _
                                  index:
                                    range [exclusive] : _
                                      start:
                                        locator offset : _
                                      end:
                                        binop + : _
                                          lhs:
                                            locator offset : _
                                          rhs:
                                            value 1 : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                return : _
                                  value false : _
                      expr_stmt ;
                        assign : _
                          target:
                            locator idx : _
                          value:
                            binop + : _
                              lhs:
                                locator idx : _
                              rhs:
                                value 1 : _
              expr_stmt (value)
                value true : _
          pub fn peek(&self) -> &Expr(str) : _
            block (2 stmts) : _
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.is_eof
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          value "" : _
              expr_stmt (value)
                index : _
                  value:
                    select .src [unknown] : _
                      object:
                        locator self : _
                  index:
                    cast : _ -> Expr(usize)
                      select .pos [unknown] : _
                        object:
                          locator self : _
          pub fn is_eof(&self) -> Expr(bool) : _
            block (3 stmts) : _
              let pos
                init:
                  cast : _ -> Expr(i64)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              let len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: self.src.len
              expr_stmt (value)
                binop >= : _
                  lhs:
                    locator pos : _
                  rhs:
                    locator len : _
        }
        pub fn is_number_char(ch: &Expr(str)) -> Expr(bool) : _
          block (1 stmt) : _
            expr_stmt (value)
              match : _
                case #0
                  cond:
                    value true : _
                  body:
                    value true : _
                case #1
                  cond:
                    value true : _
                  body:
                    value true : _
                case #2
                  cond:
                    value true : _
                  body:
                    value true : _
                case #3
                  cond:
                    value true : _
                  body:
                    value true : _
                case #4
                  cond:
                    value true : _
                  body:
                    value true : _
                case #5
                  cond:
                    value true : _
                  body:
                    value true : _
                case #6
                  cond:
                    value true : _
                  body:
                    value true : _
                case #7
                  cond:
                    value true : _
                  body:
                    value true : _
                case #8
                  cond:
                    value true : _
                  body:
                    value true : _
                case #9
                  cond:
                    value true : _
                  body:
                    value true : _
                case #10
                  cond:
                    value true : _
                  body:
                    value true : _
                case #11
                  cond:
                    value true : _
                  body:
                    value true : _
                case #12
                  cond:
                    value true : _
                  body:
                    value true : _
                case #13
                  cond:
                    value true : _
                  body:
                    value true : _
                case #14
                  cond:
                    value true : _
                  body:
                    value true : _
                case #15
                  cond:
                    value true : _
                  body:
                    value false : _
      }
      pub module intrinsics : _ {
        pub [attrs] const fn create_struct(name: &Expr(str)) -> type : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "create_struct is a compiler intrinsic" : _
                kwargs: []
        pub [attrs] const fn addfield(ty: type, name: &Expr(str), field_ty: type) -> type : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "addfield is a compiler intrinsic" : _
                kwargs: []
      }
      pub module meta : _ {
        pub struct TypeBuilder : _ {
          ty: type
        }
        impl TypeBuilder : _ {
          pub const fn new(name: &Expr(str)) -> Expr(TypeBuilder) : _
            block (1 stmt) : _
              expr_stmt (value)
                struct TypeBuilder : _
                  ty:
                    intrinsic create_struct : _
                      args:
                        locator name : _
                      kwargs: []
          pub const fn from(ty: type) -> Expr(TypeBuilder) : _
            block (1 stmt) : _
              expr_stmt (value)
                struct TypeBuilder : _
                  ty:
                    locator ty : _
          pub const fn with_field(self, name: &Expr(str), field_ty: type) -> Expr(TypeBuilder) : _
            block (2 stmts) : _
              let ty
                init:
                  intrinsic add_field : _
                    args:
                      select .ty [unknown] : _
                        object:
                          locator self : _
                      locator name : _
                      locator field_ty : _
                    kwargs: []
              expr_stmt (value)
                struct TypeBuilder : _
                  ty:
                    locator ty : _
          pub const fn build(self) -> type : _
            block (1 stmt) : _
              expr_stmt (value)
                select .ty [unknown] : _
                  object:
                    locator self : _
        }
      }
      pub module net : _ {
        pub module addr : _ {
          pub struct SocketAddr : _ {
          }
        }
        pub module tcp : _ {
          pub import std::net::addr::SocketAddr : _
          pub struct TcpStream : _ {
          }
          impl TcpStream : _ {
            pub fn connect(addr: Expr(SocketAddr)) -> Expr(TcpStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn shutdown(&mut self) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct TcpListener : _ {
          }
          impl TcpListener : _ {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(TcpListener) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn accept(&mut self) -> Expr(TcpStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
        pub module udp : _ {
          pub import std::net::addr::SocketAddr : _
          pub struct UdpSocket : _ {
          }
          impl UdpSocket : _ {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(UdpSocket) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn send_to(&mut self, buf: &[Expr(u8)], addr: Expr(SocketAddr)) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn recv_from(&mut self, buf: &mut [Expr(u8)]) -> (Expr(i64), Expr(SocketAddr)) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
        pub module tls : _ {
          pub import std::net::tcp::TcpStream : _
          pub struct TlsConnector : _ {
          }
          impl TlsConnector : _ {
            pub fn connect(&self, domain: &Expr(str), stream: Expr(TcpStream)) -> Expr(TlsStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct TlsAcceptor : _ {
          }
          impl TlsAcceptor : _ {
            pub fn accept(&self, stream: Expr(TcpStream)) -> Expr(TlsStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct TlsStream : _ {
          }
          impl TlsStream : _ {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn shutdown(&mut self) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
        pub module http : _ {
          pub struct HttpClient : _ {
          }
          impl HttpClient : _ {
            pub fn send(&self, request: Expr(HttpRequest)) -> Expr(HttpResponse) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct HttpRequest : _ {
          }
          impl HttpRequest : _ {
            pub fn get(url: &Expr(str)) -> Expr(HttpRequest) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
            pub fn post(url: &Expr(str), body: &[Expr(u8)]) -> Expr(HttpRequest) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
          }
          pub struct HttpResponse : _ {
          }
          impl HttpResponse : _ {
            pub fn status(&self) -> Expr(i64) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
            pub fn body(&self) -> &[Expr(u8)] : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
          }
        }
        pub module ws : _ {
          pub struct WsStream : _ {
          }
          impl WsStream : _ {
            pub fn connect(url: &Expr(str)) -> Expr(WsStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn send(&mut self, message: Expr(WsMessage)) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn recv(&mut self) -> Expr(WsMessage) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct WsMessage : _ {
          }
          impl WsMessage : _ {
            pub fn text(value: &Expr(str)) -> Expr(WsMessage) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
            pub fn binary(value: &[Expr(u8)]) -> Expr(WsMessage) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
          }
        }
        pub module quic : _ {
          pub import std::net::addr::SocketAddr : _
          pub struct QuicConnection : _ {
          }
          impl QuicConnection : _ {
            pub fn connect(addr: Expr(SocketAddr), server_name: &Expr(str)) -> Expr(QuicConnection) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn open_bi(&mut self) -> Expr(QuicStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct QuicListener : _ {
          }
          impl QuicListener : _ {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(QuicListener) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn accept(&mut self) -> Expr(QuicConnection) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct QuicStream : _ {
          }
          impl QuicStream : _ {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn finish(&mut self) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
      }
      pub module proc_macro : _ {
        pub enum Delimiter : _ {
          Parenthesis: ()
          Brace: ()
          Bracket: ()
        }
        pub struct Group : _ {
          delimiter: Expr(Delimiter)
          tokens: Vec<Expr(TokenTree)>
        }
        pub struct Ident : _ {
          text: Expr(str)
        }
        pub struct Punct : _ {
          text: Expr(str)
        }
        pub struct Literal : _ {
          text: Expr(str)
        }
        pub enum TokenTree : _ {
          Token: (Expr(str))
          Group: (Expr(Group))
        }
        pub struct TokenStream : _ {
        }
        pub const fn token_stream_from_str(text: Expr(str)) -> Expr(TokenStream) : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic token_stream_from_str : _
                args:
                  locator text : _
                kwargs: []
        pub const fn token_stream_to_string(stream: Expr(TokenStream)) -> Expr(str) : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic token_stream_to_string : _
                args:
                  locator stream : _
                kwargs: []
        impl TokenStream : _ {
          pub fn from_str(text: Expr(str)) -> Expr(TokenStream) : _
            block (1 stmt) : _
              expr_stmt (value)
                intrinsic token_stream_from_str : _
                  args:
                    locator text : _
                  kwargs: []
          pub fn to_string(self) -> Expr(str) : _
            block (1 stmt) : _
              expr_stmt (value)
                intrinsic token_stream_to_string : _
                  args:
                    locator self : _
                  kwargs: []
        }
      }
      pub module task : _ {
        pub struct Future : _ {
          handle: Expr(any)
        }
        pub struct Task : _ {
          handle: Expr(any)
        }
        pub fn<T> spawn(fut: Expr(any)) -> Expr(Task<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "T" })) })>) : _
          block (1 stmt) : _
            expr_stmt (value)
              struct Task : _
                handle:
                  intrinsic spawn : _
                    args:
                      locator fut : _
                    kwargs: []
        expr_item : _
          value () : _
        expr_item : _
          value () : _
      }
      pub module test : _ {
        pub struct TestCase : _ {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<Expr(TestCase)> : _
          value [0 values] : Vec<Expr(TestCase)>
        pub struct TestReport : _ {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_tests() -> Expr(TestReport) : _
          block (8 stmts) : _
            let tests: Vec<Expr(TestCase)>
              init:
                value [0 values] : _
            let mut passed
              init:
                value 0 : _
            let mut failed
              init:
                value 0 : _
            let mut idx
              init:
                value 0 : _
            expr_stmt (value)
              while : _
                cond:
                  binop < : _
                    lhs:
                      locator idx : _
                    rhs:
                      invoke : _
                        target: tests.len
                body:
                  block (4 stmts) : _
                    let test: Expr(TestCase)
                      init:
                        index : _
                          value:
                            locator tests : _
                          index:
                            locator idx : _
                    let ok
                      init:
                        intrinsic catch_unwind : _
                          args:
                            select .run [unknown] : _
                              object:
                                locator test : _
                          kwargs: []
                    expr_stmt (value)
                      if : _
                        cond:
                          locator ok : _
                        then:
                          block (2 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator passed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator passed : _
                                    rhs:
                                      value 1 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... ok" : _
                                  select .name [unknown] : _
                                    object:
                                      locator test : _
                                kwargs: []
                        else:
                          block (2 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator failed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator failed : _
                                    rhs:
                                      value 1 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... FAILED" : _
                                  select .name [unknown] : _
                                    object:
                                      locator test : _
                                kwargs: []
                    expr_stmt ;
                      assign : _
                        target:
                          locator idx : _
                        value:
                          binop + : _
                            lhs:
                              locator idx : _
                            rhs:
                              value 1 : _
            let total
              init:
                binop + : _
                  lhs:
                    locator passed : _
                  rhs:
                    locator failed : _
            expr_stmt ;
              intrinsic println : _
                args:
                  format_string "test result: {} passed; {} failed; {} total" : _
                  locator passed : _
                  locator failed : _
                  locator total : _
                kwargs: []
            expr_stmt (value)
              struct TestReport : _
                total:
                  locator total : _
                passed:
                  locator passed : _
                failed:
                  locator failed : _
        pub fn run() -> Expr(TestReport) : _
          block (1 stmt) : _
            expr_stmt (value)
              invoke : _
                target: run_tests
      }
      pub module time : _ {
        pub [attrs] fn now() -> Expr(f64) : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic time_now : _
                args: []
                kwargs: []
        pub fn sleep(seconds: Expr(f64)) -> () : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic sleep : _
                args:
                  locator seconds : _
                kwargs: []
      }
      pub module bench : _ {
        pub struct BenchCase : _ {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<Expr(BenchCase)> : _
          value [0 values] : Vec<Expr(BenchCase)>
        pub struct BenchReport : _ {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_benches() -> Expr(BenchReport) : _
          block (8 stmts) : _
            let benches: Vec<Expr(BenchCase)>
              init:
                value [0 values] : _
            let mut passed
              init:
                value 0 : _
            let mut failed
              init:
                value 0 : _
            let mut idx
              init:
                value 0 : _
            expr_stmt (value)
              while : _
                cond:
                  binop < : _
                    lhs:
                      locator idx : _
                    rhs:
                      invoke : _
                        target: benches.len
                body:
                  block (16 stmts) : _
                    let bench: Expr(BenchCase)
                      init:
                        index : _
                          value:
                            locator benches : _
                          index:
                            locator idx : _
                    let mut ok
                      init:
                        value true : _
                    let warmup_secs
                      init:
                        value 5 : _
                    let measure_secs
                      init:
                        value 15 : _
                    let warmup_start
                      init:
                        intrinsic time_now : _
                          args: []
                          kwargs: []
                    let warmup_deadline
                      init:
                        binop + : _
                          lhs:
                            locator warmup_start : _
                          rhs:
                            locator warmup_secs : _
                    let mut warmup_iters
                      init:
                        value 0 : _
                    expr_stmt (value)
                      while : _
                        cond:
                          binop < : _
                            lhs:
                              intrinsic time_now : _
                                args: []
                                kwargs: []
                            rhs:
                              locator warmup_deadline : _
                        body:
                          block (3 stmts) : _
                            let warm_ok
                              init:
                                intrinsic catch_unwind : _
                                  args:
                                    select .run [unknown] : _
                                      object:
                                        locator bench : _
                                  kwargs: []
                            expr_stmt (value)
                              if : _
                                cond:
                                  unop ! : _
                                    value:
                                      locator warm_ok : _
                                then:
                                  block (2 stmts) : _
                                    expr_stmt ;
                                      assign : _
                                        target:
                                          locator ok : _
                                        value:
                                          value false : _
                                    expr_stmt ;
                                      break : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator warmup_iters : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator warmup_iters : _
                                    rhs:
                                      value 1 : _
                    let measure_start
                      init:
                        intrinsic time_now : _
                          args: []
                          kwargs: []
                    let measure_deadline
                      init:
                        binop + : _
                          lhs:
                            locator measure_start : _
                          rhs:
                            locator measure_secs : _
                    let mut measure_iters
                      init:
                        value 0 : _
                    expr_stmt (value)
                      if : _
                        cond:
                          locator ok : _
                        then:
                          block (1 stmt) : _
                            expr_stmt (value)
                              while : _
                                cond:
                                  binop || : _
                                    lhs:
                                      binop < : _
                                        lhs:
                                          intrinsic time_now : _
                                            args: []
                                            kwargs: []
                                        rhs:
                                          locator measure_deadline : _
                                    rhs:
                                      binop == : _
                                        lhs:
                                          locator measure_iters : _
                                        rhs:
                                          value 0 : _
                                body:
                                  block (3 stmts) : _
                                    let run_ok
                                      init:
                                        intrinsic catch_unwind : _
                                          args:
                                            select .run [unknown] : _
                                              object:
                                                locator bench : _
                                          kwargs: []
                                    expr_stmt (value)
                                      if : _
                                        cond:
                                          unop ! : _
                                            value:
                                              locator run_ok : _
                                        then:
                                          block (2 stmts) : _
                                            expr_stmt ;
                                              assign : _
                                                target:
                                                  locator ok : _
                                                value:
                                                  value false : _
                                            expr_stmt ;
                                              break : _
                                    expr_stmt ;
                                      assign : _
                                        target:
                                          locator measure_iters : _
                                        value:
                                          binop + : _
                                            lhs:
                                              locator measure_iters : _
                                            rhs:
                                              value 1 : _
                    let measure_end
                      init:
                        intrinsic time_now : _
                          args: []
                          kwargs: []
                    let elapsed
                      init:
                        binop - : _
                          lhs:
                            locator measure_end : _
                          rhs:
                            locator measure_start : _
                    expr_stmt (value)
                      if : _
                        cond:
                          locator ok : _
                        then:
                          block (4 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator passed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator passed : _
                                    rhs:
                                      value 1 : _
                            let iters_f
                              init:
                                cast : _ -> Expr(f64)
                                  locator measure_iters : _
                            let ns_per_iter
                              init:
                                if : _
                                  cond:
                                    binop > : _
                                      lhs:
                                        locator iters_f : _
                                      rhs:
                                        value 0 : _
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt (value)
                                        binop * : _
                                          lhs:
                                            binop / : _
                                              lhs:
                                                locator elapsed : _
                                              rhs:
                                                locator iters_f : _
                                          rhs:
                                            value 1000000000 : _
                                  else:
                                    block (1 stmt) : _
                                      expr_stmt (value)
                                        value 0 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... ok (iters: {}, time: {:.6}s, ns/iter: {:.2})" : _
                                  select .name [unknown] : _
                                    object:
                                      locator bench : _
                                  locator measure_iters : _
                                  locator elapsed : _
                                  locator ns_per_iter : _
                                kwargs: []
                        else:
                          block (2 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator failed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator failed : _
                                    rhs:
                                      value 1 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... FAILED" : _
                                  select .name [unknown] : _
                                    object:
                                      locator bench : _
                                kwargs: []
                    expr_stmt ;
                      assign : _
                        target:
                          locator idx : _
                        value:
                          binop + : _
                            lhs:
                              locator idx : _
                            rhs:
                              value 1 : _
            let total
              init:
                binop + : _
                  lhs:
                    locator passed : _
                  rhs:
                    locator failed : _
            expr_stmt ;
              intrinsic println : _
                args:
                  format_string "bench result: {} passed; {} failed; {} total" : _
                  locator passed : _
                  locator failed : _
                  locator total : _
                kwargs: []
            expr_stmt (value)
              struct BenchReport : _
                total:
                  locator total : _
                passed:
                  locator passed : _
                failed:
                  locator failed : _
      }
      pub module collections : _ {
        pub struct HashMapEntry : _ {
          key: Expr(K)
          value: Expr(V)
        }
        pub struct HashMap : _ {
          entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>
        }
        impl HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })> : _ {
          pub fn from(entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>) -> Expr(HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>) : _
            block (1 stmt) : _
              expr_stmt (value)
                struct HashMap : _
                  entries:
                    locator entries : _
          pub fn len(&self) -> Expr(i64) : _
            block (1 stmt) : _
              expr_stmt (value)
                invoke : _
                  target: self.entries.len
          pub fn get_unchecked(&self, key: Expr(K)) -> Expr(V) : _
            block (3 stmts) : _
              let mut idx
                init:
                  value 0 : _
              expr_stmt (value)
                while : _
                  cond:
                    binop < : _
                      lhs:
                        locator idx : _
                      rhs:
                        invoke : _
                          target: self.entries.len
                  body:
                    block (3 stmts) : _
                      let entry
                        init:
                          index : _
                            value:
                              select .entries [unknown] : _
                                object:
                                  locator self : _
                            index:
                              locator idx : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop == : _
                              lhs:
                                select .key [unknown] : _
                                  object:
                                    locator entry : _
                              rhs:
                                locator key : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                return : _
                                  select .value [unknown] : _
                                    object:
                                      locator entry : _
                      expr_stmt ;
                        assign : _
                          target:
                            locator idx : _
                          value:
                            binop + : _
                              lhs:
                                locator idx : _
                              rhs:
                                value 1 : _
              expr_stmt (value)
                loop : _
                  block (0 stmts) : _
        }
      }
      pub module ffi : _ {
        pub struct CStr : _ {
        }
      }
      pub module future : _ {
        pub fn sleep(seconds: Expr(f64)) -> Expr(std::task::Future<Unit(TypeUnit)>) : _
          block (1 stmt) : _
            expr_stmt (value)
              struct std::task::Future : _
                handle:
                  async : _
                    block (2 stmts) : _
                      expr_stmt ;
                        intrinsic sleep : _
                          args:
                            locator seconds : _
                          kwargs: []
                      expr_stmt (value)
                        value () : _
      }
      pub module json : _ {
        pub struct JsonField : _ {
          key: &Expr(str)
          value: Expr(JsonValue)
        }
        pub enum JsonValue : _ {
          Null: ()
          Bool: (Expr(bool))
          Number: (&Expr(str))
          String: (&Expr(str))
          Array: (Vec<Expr(JsonValue)>)
          Object: (Vec<Expr(JsonField)>)
        }
        pub fn parse(input: &Expr(str)) -> Expr(JsonValue) : _
          block (2 stmts) : _
            let mut parser
              init:
                invoke : _
                  target: Parser::new
                  args:
                    locator input : &Expr(str)
            expr_stmt (value)
              invoke : _
                target: parser.parse_value
        pub fn print(value: Expr(JsonValue)) : _
          block (1 stmt) : _
            expr_stmt ;
              invoke : _
                target: print_value
                args:
                  reference (mutable: unspecified) : &Expr(JsonValue)
                    locator value : _
        pub fn print_value(value: &Expr(JsonValue)) : _
          block (1 stmt) : _
            expr_stmt (value)
              match : _
                case #0
                  cond:
                    value true : _
                  body:
                    intrinsic print : _
                      args:
                        format_string "null" : _
                      kwargs: []
                case #1
                  cond:
                    value true : _
                  body:
                    block (1 stmt) : _
                      expr_stmt (value)
                        if : _
                          cond:
                            locator b : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "true" : _
                                  kwargs: []
                          else:
                            block (1 stmt) : _
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "false" : _
                                  kwargs: []
                case #2
                  cond:
                    value true : _
                  body:
                    intrinsic print : _
                      args:
                        format_string "{}" : _
                        locator n : _
                      kwargs: []
                case #3
                  cond:
                    value true : _
                  body:
                    block (3 stmts) : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "\"" : _
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "{}" : _
                            locator s : _
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "\"" : _
                          kwargs: []
                case #4
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "[" : _
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : _
                      let items_len
                        init:
                          invoke : _
                            target: items.len
                      expr_stmt (value)
                        while : _
                          cond:
                            binop < : _
                              lhs:
                                locator idx : _
                              rhs:
                                locator items_len : _
                          body:
                            block (4 stmts) : _
                              expr_stmt (value)
                                if : _
                                  cond:
                                    binop > : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 0 : _
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt ;
                                        intrinsic print : _
                                          args:
                                            format_string "," : _
                                          kwargs: []
                              let item
                                init:
                                  index : _
                                    value:
                                      locator items : _
                                    index:
                                      locator idx : _
                              expr_stmt ;
                                invoke : _
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : &Expr(JsonValue)
                                      locator item : _
                              expr_stmt ;
                                assign : _
                                  target:
                                    locator idx : _
                                  value:
                                    binop + : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 1 : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "]" : _
                          kwargs: []
                case #5
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "{" : _
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : _
                      let fields_len
                        init:
                          invoke : _
                            target: fields.len
                      expr_stmt (value)
                        while : _
                          cond:
                            binop < : _
                              lhs:
                                locator idx : _
                              rhs:
                                locator fields_len : _
                          body:
                            block (7 stmts) : _
                              expr_stmt (value)
                                if : _
                                  cond:
                                    binop > : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 0 : _
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt ;
                                        intrinsic print : _
                                          args:
                                            format_string "," : _
                                          kwargs: []
                              let field
                                init:
                                  index : _
                                    value:
                                      locator fields : _
                                    index:
                                      locator idx : _
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "\"" : _
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "{}" : _
                                    select .key [unknown] : _
                                      object:
                                        locator field : _
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : _
                                  args:
                                    format_string "\":" : _
                                  kwargs: []
                              expr_stmt ;
                                invoke : _
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : &Expr(JsonValue)
                                      select .value [unknown] : _
                                        object:
                                          locator field : _
                              expr_stmt ;
                                assign : _
                                  target:
                                    locator idx : _
                                  value:
                                    binop + : _
                                      lhs:
                                        locator idx : _
                                      rhs:
                                        value 1 : _
                      expr_stmt ;
                        intrinsic print : _
                          args:
                            format_string "}" : _
                          kwargs: []
        pub struct Parser : _ {
          src: Vec<&Expr(str)>
          pos: Expr(i64)
        }
        impl Parser : _ {
          pub fn new(src: &Expr(str)) -> Expr(Parser) : _
            block (5 stmts) : _
              let mut chars
                init:
                  value [0 values] : _
              let mut idx
                init:
                  value 0 : _
              let src_len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: src.len
              expr_stmt (value)
                while : _
                  cond:
                    binop < : _
                      lhs:
                        locator idx : _
                      rhs:
                        locator src_len : _
                  body:
                    block (4 stmts) : _
                      let offset
                        init:
                          cast : _ -> Expr(usize)
                            locator idx : _
                      let ch
                        init:
                          index : _
                            value:
                              locator src : _
                            index:
                              range [exclusive] : _
                                start:
                                  locator offset : _
                                end:
                                  binop + : _
                                    lhs:
                                      locator offset : _
                                    rhs:
                                      value 1 : _
                      expr_stmt ;
                        invoke : _
                          target: chars.push
                          args:
                            locator ch : _
                      expr_stmt ;
                        assign : _
                          target:
                            locator idx : _
                          value:
                            binop + : _
                              lhs:
                                locator idx : _
                              rhs:
                                value 1 : _
              expr_stmt (value)
                struct Parser : _
                  src:
                    locator chars : _
                  pos:
                    value 0 : _
          pub fn bump(&mut self, amount: Expr(i64)) : _
            block (1 stmt) : _
              expr_stmt ;
                assign : _
                  target:
                    select .pos [unknown] : _
                      object:
                        locator self : _
                  value:
                    binop + : _
                      lhs:
                        select .pos [unknown] : _
                          object:
                            locator self : _
                      rhs:
                        locator amount : _
          pub fn parse_value(&mut self) -> Expr(JsonValue) : _
            block (9 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.skip_ws
              let ch
                init:
                  invoke : _
                    target: self.peek
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        locator ch : _
                      rhs:
                        value "{" : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: self.parse_object
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        locator ch : _
                      rhs:
                        value "[" : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: self.parse_array
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        locator ch : _
                      rhs:
                        value "\"" : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::String
                            args:
                              invoke : _
                                target: self.parse_string
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.starts_with
                      args:
                        value "true" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 4 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Bool
                            args:
                              value true : _
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.starts_with
                      args:
                        value "false" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 5 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Bool
                            args:
                              value false : _
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.starts_with
                      args:
                        value "null" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 4 : _
                      expr_stmt ;
                        return : _
                          locator JsonValue::Null : _
              expr_stmt (value)
                invoke : _
                  target: JsonValue::Number
                  args:
                    invoke : _
                      target: self.parse_number
          pub fn parse_array(&mut self) -> Expr(JsonValue) : _
            block (6 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.expect_char
                  args:
                    value "[" : _
              expr_stmt ;
                invoke : _
                  target: self.skip_ws
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        invoke : _
                          target: self.peek
                      rhs:
                        value "]" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Array
                            args:
                              value [0 values] : _
              let mut items
                init:
                  value [0 values] : _
              expr_stmt (value)
                loop : _
                  block (6 stmts) : _
                    let value
                      init:
                        invoke : _
                          target: self.parse_value
                    expr_stmt ;
                      invoke : _
                        target: items.push
                        args:
                          locator value : _
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : _
                          target: self.peek
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "," : _
                        then:
                          block (3 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              invoke : _
                                target: self.skip_ws
                            expr_stmt ;
                              continue : _
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "]" : _
                        then:
                          block (2 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              break : _
              expr_stmt (value)
                invoke : _
                  target: JsonValue::Array
                  args:
                    locator items : _
          pub fn parse_object(&mut self) -> Expr(JsonValue) : _
            block (6 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.expect_char
                  args:
                    value "{" : _
              expr_stmt ;
                invoke : _
                  target: self.skip_ws
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        invoke : _
                          target: self.peek
                      rhs:
                        value "}" : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
                      expr_stmt ;
                        return : _
                          invoke : _
                            target: JsonValue::Object
                            args:
                              value [0 values] : _
              let mut fields
                init:
                  value [0 values] : _
              expr_stmt (value)
                loop : _
                  block (10 stmts) : _
                    let key
                      init:
                        invoke : _
                          target: self.parse_string
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    expr_stmt ;
                      invoke : _
                        target: self.expect_char
                        args:
                          value ":" : _
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    let value
                      init:
                        invoke : _
                          target: self.parse_value
                    expr_stmt ;
                      invoke : _
                        target: fields.push
                        args:
                          struct JsonField : _
                            key:
                              locator key : _
                            value:
                              locator value : _
                    expr_stmt ;
                      invoke : _
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : _
                          target: self.peek
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "," : _
                        then:
                          block (3 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              invoke : _
                                target: self.skip_ws
                            expr_stmt ;
                              continue : _
                    expr_stmt (value)
                      if : _
                        cond:
                          binop == : _
                            lhs:
                              locator ch : _
                            rhs:
                              value "}" : _
                        then:
                          block (2 stmts) : _
                            expr_stmt ;
                              invoke : _
                                target: self.bump
                                args:
                                  value 1 : _
                            expr_stmt ;
                              break : _
              expr_stmt (value)
                invoke : _
                  target: JsonValue::Object
                  args:
                    locator fields : _
          pub fn parse_string(&mut self) -> &Expr(str) : _
            block (4 stmts) : _
              expr_stmt ;
                invoke : _
                  target: self.expect_char
                  args:
                    value "\"" : _
              let start
                init:
                  cast : _ -> Expr(usize)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              expr_stmt (value)
                while : _
                  cond:
                    unop ! : _
                      value:
                        invoke : _
                          target: self.is_eof
                  body:
                    block (4 stmts) : _
                      let ch
                        init:
                          invoke : _
                            target: self.peek
                      expr_stmt (value)
                        if : _
                          cond:
                            binop == : _
                              lhs:
                                locator ch : _
                              rhs:
                                value "\"" : _
                          then:
                            block (3 stmts) : _
                              let value
                                init:
                                  index : _
                                    value:
                                      select .src [unknown] : _
                                        object:
                                          locator self : _
                                    index:
                                      range [exclusive] : _
                                        start:
                                          locator start : _
                                        end:
                                          cast : _ -> Expr(usize)
                                            select .pos [unknown] : _
                                              object:
                                                locator self : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                              expr_stmt ;
                                return : _
                                  locator value : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop == : _
                              lhs:
                                locator ch : _
                              rhs:
                                value "\\" : _
                          then:
                            block (3 stmts) : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                              expr_stmt (value)
                                if : _
                                  cond:
                                    unop ! : _
                                      value:
                                        invoke : _
                                          target: self.is_eof
                                  then:
                                    block (1 stmt) : _
                                      expr_stmt ;
                                        invoke : _
                                          target: self.bump
                                          args:
                                            value 1 : _
                              expr_stmt ;
                                continue : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
              expr_stmt (value)
                index : _
                  value:
                    select .src [unknown] : _
                      object:
                        locator self : _
                  index:
                    range [exclusive] : _
                      start:
                        locator start : _
                      end:
                        cast : _ -> Expr(usize)
                          select .pos [unknown] : _
                            object:
                              locator self : _
          pub fn parse_number(&mut self) -> &Expr(str) : _
            block (3 stmts) : _
              let start
                init:
                  cast : _ -> Expr(usize)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              expr_stmt (value)
                while : _
                  cond:
                    unop ! : _
                      value:
                        invoke : _
                          target: self.is_eof
                  body:
                    block (2 stmts) : _
                      let ch
                        init:
                          invoke : _
                            target: self.peek
                      expr_stmt (value)
                        if : _
                          cond:
                            invoke : _
                              target: is_number_char
                              args:
                                locator ch : &Expr(str)
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                          else:
                            block (1 stmt) : _
                              expr_stmt ;
                                break : _
              expr_stmt (value)
                index : _
                  value:
                    select .src [unknown] : _
                      object:
                        locator self : _
                  index:
                    range [exclusive] : _
                      start:
                        locator start : _
                      end:
                        cast : _ -> Expr(usize)
                          select .pos [unknown] : _
                            object:
                              locator self : _
          pub fn skip_ws(&mut self) : _
            block (1 stmt) : _
              expr_stmt (value)
                while : _
                  cond:
                    unop ! : _
                      value:
                        invoke : _
                          target: self.is_eof
                  body:
                    block (2 stmts) : _
                      let ch
                        init:
                          invoke : _
                            target: self.peek
                      expr_stmt (value)
                        if : _
                          cond:
                            binop || : _
                              lhs:
                                binop || : _
                                  lhs:
                                    binop || : _
                                      lhs:
                                        binop == : _
                                          lhs:
                                            locator ch : _
                                          rhs:
                                            value " " : _
                                      rhs:
                                        binop == : _
                                          lhs:
                                            locator ch : _
                                          rhs:
                                            value "\n" : _
                                  rhs:
                                    binop == : _
                                      lhs:
                                        locator ch : _
                                      rhs:
                                        value "\t" : _
                              rhs:
                                binop == : _
                                  lhs:
                                    locator ch : _
                                  rhs:
                                    value "\r" : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                invoke : _
                                  target: self.bump
                                  args:
                                    value 1 : _
                          else:
                            block (1 stmt) : _
                              expr_stmt ;
                                break : _
          pub fn expect_char(&mut self, ch: &Expr(str)) : _
            block (1 stmt) : _
              expr_stmt (value)
                if : _
                  cond:
                    binop == : _
                      lhs:
                        invoke : _
                          target: self.peek
                      rhs:
                        locator ch : _
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        invoke : _
                          target: self.bump
                          args:
                            value 1 : _
          pub fn starts_with(&self, literal: &Expr(str)) -> Expr(bool) : _
            block (7 stmts) : _
              let pos
                init:
                  cast : _ -> Expr(usize)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              let mut idx
                init:
                  value 0 : _
              let literal_len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: literal.len
              let src_len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: self.src.len
              let pos_i64
                init:
                  cast : _ -> Expr(i64)
                    locator pos : _
              expr_stmt (value)
                while : _
                  cond:
                    binop < : _
                      lhs:
                        locator idx : _
                      rhs:
                        locator literal_len : _
                  body:
                    block (4 stmts) : _
                      let offset
                        init:
                          cast : _ -> Expr(usize)
                            locator idx : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop >= : _
                              lhs:
                                binop + : _
                                  lhs:
                                    locator pos_i64 : _
                                  rhs:
                                    locator idx : _
                              rhs:
                                locator src_len : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                return : _
                                  value false : _
                      expr_stmt (value)
                        if : _
                          cond:
                            binop != : _
                              lhs:
                                index : _
                                  value:
                                    select .src [unknown] : _
                                      object:
                                        locator self : _
                                  index:
                                    binop + : _
                                      lhs:
                                        locator pos : _
                                      rhs:
                                        locator offset : _
                              rhs:
                                index : _
                                  value:
                                    locator literal : _
                                  index:
                                    range [exclusive] : _
                                      start:
                                        locator offset : _
                                      end:
                                        binop + : _
                                          lhs:
                                            locator offset : _
                                          rhs:
                                            value 1 : _
                          then:
                            block (1 stmt) : _
                              expr_stmt ;
                                return : _
                                  value false : _
                      expr_stmt ;
                        assign : _
                          target:
                            locator idx : _
                          value:
                            binop + : _
                              lhs:
                                locator idx : _
                              rhs:
                                value 1 : _
              expr_stmt (value)
                value true : _
          pub fn peek(&self) -> &Expr(str) : _
            block (2 stmts) : _
              expr_stmt (value)
                if : _
                  cond:
                    invoke : _
                      target: self.is_eof
                  then:
                    block (1 stmt) : _
                      expr_stmt ;
                        return : _
                          value "" : _
              expr_stmt (value)
                index : _
                  value:
                    select .src [unknown] : _
                      object:
                        locator self : _
                  index:
                    cast : _ -> Expr(usize)
                      select .pos [unknown] : _
                        object:
                          locator self : _
          pub fn is_eof(&self) -> Expr(bool) : _
            block (3 stmts) : _
              let pos
                init:
                  cast : _ -> Expr(i64)
                    select .pos [unknown] : _
                      object:
                        locator self : _
              let len
                init:
                  cast : _ -> Expr(i64)
                    invoke : _
                      target: self.src.len
              expr_stmt (value)
                binop >= : _
                  lhs:
                    locator pos : _
                  rhs:
                    locator len : _
        }
        pub fn is_number_char(ch: &Expr(str)) -> Expr(bool) : _
          block (1 stmt) : _
            expr_stmt (value)
              match : _
                case #0
                  cond:
                    value true : _
                  body:
                    value true : _
                case #1
                  cond:
                    value true : _
                  body:
                    value true : _
                case #2
                  cond:
                    value true : _
                  body:
                    value true : _
                case #3
                  cond:
                    value true : _
                  body:
                    value true : _
                case #4
                  cond:
                    value true : _
                  body:
                    value true : _
                case #5
                  cond:
                    value true : _
                  body:
                    value true : _
                case #6
                  cond:
                    value true : _
                  body:
                    value true : _
                case #7
                  cond:
                    value true : _
                  body:
                    value true : _
                case #8
                  cond:
                    value true : _
                  body:
                    value true : _
                case #9
                  cond:
                    value true : _
                  body:
                    value true : _
                case #10
                  cond:
                    value true : _
                  body:
                    value true : _
                case #11
                  cond:
                    value true : _
                  body:
                    value true : _
                case #12
                  cond:
                    value true : _
                  body:
                    value true : _
                case #13
                  cond:
                    value true : _
                  body:
                    value true : _
                case #14
                  cond:
                    value true : _
                  body:
                    value true : _
                case #15
                  cond:
                    value true : _
                  body:
                    value false : _
      }
      pub module intrinsics : _ {
        pub [attrs] const fn create_struct(name: &Expr(str)) -> type : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "create_struct is a compiler intrinsic" : _
                kwargs: []
        pub [attrs] const fn addfield(ty: type, name: &Expr(str), field_ty: type) -> type : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "addfield is a compiler intrinsic" : _
                kwargs: []
      }
      pub module meta : _ {
        pub struct TypeBuilder : _ {
          ty: type
        }
        impl TypeBuilder : _ {
          pub const fn new(name: &Expr(str)) -> Expr(TypeBuilder) : _
            block (1 stmt) : _
              expr_stmt (value)
                struct TypeBuilder : _
                  ty:
                    intrinsic create_struct : _
                      args:
                        locator name : _
                      kwargs: []
          pub const fn from(ty: type) -> Expr(TypeBuilder) : _
            block (1 stmt) : _
              expr_stmt (value)
                struct TypeBuilder : _
                  ty:
                    locator ty : _
          pub const fn with_field(self, name: &Expr(str), field_ty: type) -> Expr(TypeBuilder) : _
            block (2 stmts) : _
              let ty
                init:
                  intrinsic add_field : _
                    args:
                      select .ty [unknown] : _
                        object:
                          locator self : _
                      locator name : _
                      locator field_ty : _
                    kwargs: []
              expr_stmt (value)
                struct TypeBuilder : _
                  ty:
                    locator ty : _
          pub const fn build(self) -> type : _
            block (1 stmt) : _
              expr_stmt (value)
                select .ty [unknown] : _
                  object:
                    locator self : _
        }
      }
      pub module net : _ {
        pub module addr : _ {
          pub struct SocketAddr : _ {
          }
        }
        pub module tcp : _ {
          pub import std::net::addr::SocketAddr : _
          pub struct TcpStream : _ {
          }
          impl TcpStream : _ {
            pub fn connect(addr: Expr(SocketAddr)) -> Expr(TcpStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn shutdown(&mut self) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct TcpListener : _ {
          }
          impl TcpListener : _ {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(TcpListener) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn accept(&mut self) -> Expr(TcpStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
        pub module udp : _ {
          pub import std::net::addr::SocketAddr : _
          pub struct UdpSocket : _ {
          }
          impl UdpSocket : _ {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(UdpSocket) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn send_to(&mut self, buf: &[Expr(u8)], addr: Expr(SocketAddr)) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn recv_from(&mut self, buf: &mut [Expr(u8)]) -> (Expr(i64), Expr(SocketAddr)) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
        pub module tls : _ {
          pub import std::net::tcp::TcpStream : _
          pub struct TlsConnector : _ {
          }
          impl TlsConnector : _ {
            pub fn connect(&self, domain: &Expr(str), stream: Expr(TcpStream)) -> Expr(TlsStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct TlsAcceptor : _ {
          }
          impl TlsAcceptor : _ {
            pub fn accept(&self, stream: Expr(TcpStream)) -> Expr(TlsStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct TlsStream : _ {
          }
          impl TlsStream : _ {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn shutdown(&mut self) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
        pub module http : _ {
          pub struct HttpClient : _ {
          }
          impl HttpClient : _ {
            pub fn send(&self, request: Expr(HttpRequest)) -> Expr(HttpResponse) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct HttpRequest : _ {
          }
          impl HttpRequest : _ {
            pub fn get(url: &Expr(str)) -> Expr(HttpRequest) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
            pub fn post(url: &Expr(str), body: &[Expr(u8)]) -> Expr(HttpRequest) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
          }
          pub struct HttpResponse : _ {
          }
          impl HttpResponse : _ {
            pub fn status(&self) -> Expr(i64) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
            pub fn body(&self) -> &[Expr(u8)] : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
          }
        }
        pub module ws : _ {
          pub struct WsStream : _ {
          }
          impl WsStream : _ {
            pub fn connect(url: &Expr(str)) -> Expr(WsStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn send(&mut self, message: Expr(WsMessage)) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn recv(&mut self) -> Expr(WsMessage) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct WsMessage : _ {
          }
          impl WsMessage : _ {
            pub fn text(value: &Expr(str)) -> Expr(WsMessage) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
            pub fn binary(value: &[Expr(u8)]) -> Expr(WsMessage) : _
              block (1 stmt) : _
                expr_stmt (value)
                  loop : _
                    block (0 stmts) : _
          }
        }
        pub module quic : _ {
          pub import std::net::addr::SocketAddr : _
          pub struct QuicConnection : _ {
          }
          impl QuicConnection : _ {
            pub fn connect(addr: Expr(SocketAddr), server_name: &Expr(str)) -> Expr(QuicConnection) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn open_bi(&mut self) -> Expr(QuicStream) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct QuicListener : _ {
          }
          impl QuicListener : _ {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(QuicListener) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn accept(&mut self) -> Expr(QuicConnection) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
          pub struct QuicStream : _ {
          }
          impl QuicStream : _ {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
            pub fn finish(&mut self) -> () : _
              async : _
                block (1 stmt) : _
                  expr_stmt (value)
                    loop : _
                      block (0 stmts) : _
          }
        }
      }
      pub module proc_macro : _ {
        pub enum Delimiter : _ {
          Parenthesis: ()
          Brace: ()
          Bracket: ()
        }
        pub struct Group : _ {
          delimiter: Expr(Delimiter)
          tokens: Vec<Expr(TokenTree)>
        }
        pub struct Ident : _ {
          text: Expr(str)
        }
        pub struct Punct : _ {
          text: Expr(str)
        }
        pub struct Literal : _ {
          text: Expr(str)
        }
        pub enum TokenTree : _ {
          Token: (Expr(str))
          Group: (Expr(Group))
        }
        pub struct TokenStream : _ {
        }
        pub const fn token_stream_from_str(text: Expr(str)) -> Expr(TokenStream) : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic token_stream_from_str : _
                args:
                  locator text : _
                kwargs: []
        pub const fn token_stream_to_string(stream: Expr(TokenStream)) -> Expr(str) : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic token_stream_to_string : _
                args:
                  locator stream : _
                kwargs: []
        impl TokenStream : _ {
          pub fn from_str(text: Expr(str)) -> Expr(TokenStream) : _
            block (1 stmt) : _
              expr_stmt (value)
                intrinsic token_stream_from_str : _
                  args:
                    locator text : _
                  kwargs: []
          pub fn to_string(self) -> Expr(str) : _
            block (1 stmt) : _
              expr_stmt (value)
                intrinsic token_stream_to_string : _
                  args:
                    locator self : _
                  kwargs: []
        }
      }
      pub module task : _ {
        pub struct Future : _ {
          handle: Expr(any)
        }
        pub struct Task : _ {
          handle: Expr(any)
        }
        pub fn<T> spawn(fut: Expr(any)) -> Expr(Task<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "T" })) })>) : _
          block (1 stmt) : _
            expr_stmt (value)
              struct Task : _
                handle:
                  intrinsic spawn : _
                    args:
                      locator fut : _
                    kwargs: []
        expr_item : _
          value () : _
        expr_item : _
          value () : _
      }
      pub module test : _ {
        pub struct TestCase : _ {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<Expr(TestCase)> : _
          value [0 values] : Vec<Expr(TestCase)>
        pub struct TestReport : _ {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_tests() -> Expr(TestReport) : _
          block (8 stmts) : _
            let tests: Vec<Expr(TestCase)>
              init:
                value [0 values] : _
            let mut passed
              init:
                value 0 : _
            let mut failed
              init:
                value 0 : _
            let mut idx
              init:
                value 0 : _
            expr_stmt (value)
              while : _
                cond:
                  binop < : _
                    lhs:
                      locator idx : _
                    rhs:
                      invoke : _
                        target: tests.len
                body:
                  block (4 stmts) : _
                    let test: Expr(TestCase)
                      init:
                        index : _
                          value:
                            locator tests : _
                          index:
                            locator idx : _
                    let ok
                      init:
                        intrinsic catch_unwind : _
                          args:
                            select .run [unknown] : _
                              object:
                                locator test : _
                          kwargs: []
                    expr_stmt (value)
                      if : _
                        cond:
                          locator ok : _
                        then:
                          block (2 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator passed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator passed : _
                                    rhs:
                                      value 1 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... ok" : _
                                  select .name [unknown] : _
                                    object:
                                      locator test : _
                                kwargs: []
                        else:
                          block (2 stmts) : _
                            expr_stmt ;
                              assign : _
                                target:
                                  locator failed : _
                                value:
                                  binop + : _
                                    lhs:
                                      locator failed : _
                                    rhs:
                                      value 1 : _
                            expr_stmt ;
                              intrinsic println : _
                                args:
                                  format_string "  {} ... FAILED" : _
                                  select .name [unknown] : _
                                    object:
                                      locator test : _
                                kwargs: []
                    expr_stmt ;
                      assign : _
                        target:
                          locator idx : _
                        value:
                          binop + : _
                            lhs:
                              locator idx : _
                            rhs:
                              value 1 : _
            let total
              init:
                binop + : _
                  lhs:
                    locator passed : _
                  rhs:
                    locator failed : _
            expr_stmt ;
              intrinsic println : _
                args:
                  format_string "test result: {} passed; {} failed; {} total" : _
                  locator passed : _
                  locator failed : _
                  locator total : _
                kwargs: []
            expr_stmt (value)
              struct TestReport : _
                total:
                  locator total : _
                passed:
                  locator passed : _
                failed:
                  locator failed : _
        pub fn run() -> Expr(TestReport) : _
          block (1 stmt) : _
            expr_stmt (value)
              invoke : _
                target: run_tests
      }
      pub module time : _ {
        pub [attrs] fn now() -> Expr(f64) : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic time_now : _
                args: []
                kwargs: []
        pub fn sleep(seconds: Expr(f64)) -> () : _
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic sleep : _
                args:
                  locator seconds : _
                kwargs: []
      }
    }
    pub struct InAddr : _ {
      s_addr: Expr(u32)
    }
    pub struct SockAddrIn : _ {
      sin_family: Expr(u16)
      sin_port: Expr(u16)
      sin_addr: Expr(InAddr)
      sin_zero0: Expr(u32)
      sin_zero1: Expr(u32)
    }
    pub module libc : _ {
      declare extern "C" fn socket(domain: Expr(i32), sock_type: Expr(i32), protocol: Expr(i32)) -> Expr(i32) : _
      declare extern "C" fn bind(fd: Expr(i32), addr: &Expr(SockAddrIn), addrlen: Expr(u32)) -> Expr(i32) : _
      declare extern "C" fn listen(fd: Expr(i32), backlog: Expr(i32)) -> Expr(i32) : _
      declare extern "C" fn accept(fd: Expr(i32), addr: &mut Expr(SockAddrIn), addrlen: &mut Expr(u32)) -> Expr(i32) : _
      declare extern "C" fn write(fd: Expr(i32), buf: &Expr(u8), count: Expr(usize)) -> Expr(i64) : _
      declare extern "C" fn close(fd: Expr(i32)) -> Expr(i32) : _
      declare extern "C" fn htons(hostshort: Expr(u16)) -> Expr(u16) : _
    }
    pub const AF_INET: Expr(i32) : _
      value 2 : Expr(i32)
    pub const SOCK_STREAM: Expr(i32) : _
      value 1 : Expr(i32)
    pub const INADDR_ANY: Expr(u32) : _
      value 0 : Expr(u32)
    pub const SOCKADDR_LEN: Expr(u32) : _
      value 16 : Expr(u32)
    pub const RESPONSE_LEN: Expr(usize) : _
      value 70 : Expr(usize)
    pub const RESPONSE: [Expr(u8); 70] : _
      value [70 values] : [Expr(u8); 70]
    pub fn make_addr(port: Expr(u16)) -> Expr(SockAddrIn) : _
      block (1 stmt) : _
        expr_stmt (value)
          struct SockAddrIn : _
            sin_family:
              cast : _ -> Expr(u16)
                value 2 : _
            sin_port:
              invoke : _
                target: libc::htons
                args:
                  locator port : _
            sin_addr:
              struct InAddr : _
                s_addr:
                  value 0 : _
            sin_zero0:
              value 0 : _
            sin_zero1:
              value 0 : _
    pub fn main() : _
      block (7 stmts) : _
        let server_fd
          init:
            invoke : _
              target: libc::socket
              args:
                value 2 : _
                value 1 : _
                value 0 : _
        expr_stmt (value)
          if : _
            cond:
              binop < : _
                lhs:
                  locator server_fd : _
                rhs:
                  value 0 : _
            then:
              block (2 stmts) : _
                expr_stmt ;
                  intrinsic println : _
                    args:
                      format_string "socket failed" : _
                    kwargs: []
                expr_stmt ;
                  return : _
        let addr
          init:
            invoke : _
              target: make_addr
              args:
                value 8080 : Expr(u16)
        expr_stmt (value)
          if : _
            cond:
              binop < : _
                lhs:
                  invoke : _
                    target: libc::bind
                    args:
                      locator server_fd : _
                      reference (mutable: unspecified) : _
                        locator addr : _
                      value 16 : _
                rhs:
                  value 0 : _
            then:
              block (3 stmts) : _
                expr_stmt ;
                  intrinsic println : _
                    args:
                      format_string "bind failed" : _
                    kwargs: []
                expr_stmt ;
                  invoke : _
                    target: libc::close
                    args:
                      locator server_fd : _
                expr_stmt ;
                  return : _
        expr_stmt (value)
          if : _
            cond:
              binop < : _
                lhs:
                  invoke : _
                    target: libc::listen
                    args:
                      locator server_fd : _
                      value 16 : _
                rhs:
                  value 0 : _
            then:
              block (3 stmts) : _
                expr_stmt ;
                  intrinsic println : _
                    args:
                      format_string "listen failed" : _
                    kwargs: []
                expr_stmt ;
                  invoke : _
                    target: libc::close
                    args:
                      locator server_fd : _
                expr_stmt ;
                  return : _
        expr_stmt ;
          intrinsic println : _
            args:
              format_string "listening on 0.0.0.0:8080" : _
            kwargs: []
        expr_stmt (value)
          loop : _
            block (6 stmts) : _
              let mut client_addr
                init:
                  invoke : _
                    target: make_addr
                    args:
                      value 0 : Expr(u16)
              let mut client_len: Expr(u32)
                init:
                  value 16 : _
              let client_fd
                init:
                  invoke : _
                    target: libc::accept
                    args:
                      locator server_fd : _
                      reference (mutable: mut) : _
                        locator client_addr : _
                      reference (mutable: mut) : _
                        locator client_len : _
              expr_stmt (value)
                if : _
                  cond:
                    binop < : _
                      lhs:
                        locator client_fd : _
                      rhs:
                        value 0 : _
                  then:
                    block (2 stmts) : _
                      expr_stmt ;
                        intrinsic println : _
                          args:
                            format_string "accept failed" : _
                          kwargs: []
                      expr_stmt ;
                        continue : _
              let _
                init:
                  invoke : _
                    target: libc::write
                    args:
                      locator client_fd : _
                      reference (mutable: unspecified) : _
                        index : _
                          value:
                            value [70 values] : _
                          index:
                            value 0 : _
                      value 70 : _
              expr_stmt ;
                invoke : _
                  target: libc::close
                  args:
                    locator client_fd : _
}
