hir::Program {
    pub struct Pair<T, U> {
        pub first: T,
        pub second: U,
    }

    impl Pair<T, U> {
        fn new(first: T, second: U) -> Self {
            // params: [first: T, second: U]
            {
                Self { first: first, second: second }
            }
        }
    }

    pub enum Option<T> {
        Some,
        None,
    }

    impl Option<T> {
        fn unwrap_or(self: Option<T>, default: T) -> T {
            // params: [self: Option<T>, default: T]
            {
                match (self)
                {
                    Option::Some(v) =>
                        v
                    Option::None =>
                        default
                }
            }
        }
    }

    pub fn max<T>(a: T, b: T) -> T {
        // params: [a: T, b: T]
        {
            if ((a > b))
                {
                    a
                }
            else
                {
                    b
                }
        }
    }

    pub fn main() -> () {
        {
            printf("ðŸ“˜ Tutorial: 17_generics.fp\n");
            printf("ðŸ§­ Focus: Generics: type parameters and monomorphization\n");
            printf("ðŸ§ª What to look for: labeled outputs below\n");
            printf("âœ… Expectation: outputs match labels\n");
            printf("\n");
            let pair = Pair::new(42, "hello");
            std::Println(2 args);
            printf("max(10, 20) = %lld\n", max(10, 20));
            printf("max(3.5, 2.1) = %f\n", max(3.5, 2.1));
            let some: Option<i64> = Option::Some(100);
            let none: Option<i64> = Option::None;
            std::Println(1 args);
            std::Println(1 args);
        }
    }
}
