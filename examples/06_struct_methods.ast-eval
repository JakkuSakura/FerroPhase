ast::File {
  items:
    pub module std : () {
      pub module collections : () {
        pub struct HashMapEntry : HashMapEntry{key: Expr(K), value: Expr(V)} {
          key: Expr(K)
          value: Expr(V)
        }
        pub struct HashMap : HashMap{entries: Vec<Expr(HashMapEntry<K
, V
>)>} {
          entries: Vec<Expr(HashMapEntry<K
, V
>)>
        }
        impl HashMap<K
, V
> : () {
          pub fn from(entries: Vec<Expr(HashMapEntry<K
, V
>)>) -> Expr(HashMap<K
, V
>) : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<K
, V
>)>} : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<K
, V
>)>}
            block (1 stmt) : HashMap{entries: Vec<Expr(HashMapEntry<K
, V
>)>}
              expr_stmt (value)
                struct HashMap : HashMap{entries: Vec<Expr(HashMapEntry<K
, V
>)>}
                  entries:
                    locator entries : Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>
          pub fn len(&self) -> Expr(i64) : fn() -> i64 : fn() -> i64
            block (1 stmt) : i64
              expr_stmt (value)
                invoke : i64
                  target: self.entries.len
          pub fn get_unchecked(&self, key: Expr(K)) -> Expr(V) : fn(any) -> any : fn(any) -> any
            block (3 stmts) : !
              let mut idx
                init:
                  value 0 : i64
              expr_stmt (value)
                while : ()
                  cond:
                    binop < : bool
                      lhs:
                        locator idx : i64
                      rhs:
                        invoke : i64
                          target: self.entries.len
                  body:
                    block (3 stmts) : ()
                      let entry
                        init:
                          index : HashMapEntry{key: Expr(K), value: Expr(V)}
                            value:
                              select .entries [unknown] : Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>
                                object:
                                  locator self : &HashMap{entries: Vec<Expr(HashMapEntry<K
, V
>)>}
                            index:
                              locator idx : i64
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop == : bool
                              lhs:
                                select .key [unknown] : any
                                  object:
                                    locator entry : HashMapEntry{key: Expr(K), value: Expr(V)}
                              rhs:
                                locator key : any
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                intrinsic return : !
                                  args:
                                    select .value [unknown] : any
                                      object:
                                        locator entry : HashMapEntry{key: Expr(K), value: Expr(V)}
                      expr_stmt ;
                        assign : i64
                          target:
                            locator idx : i64
                          value:
                            binop + : i64
                              lhs:
                                locator idx : i64
                              rhs:
                                value 1 : i64
              expr_stmt (value)
                loop : !
                  block (0 stmts) : ()
        }
      }
    }
    pub struct Point : Point{x: Expr(i64), y: Expr(i64)} {
      x: Expr(i64)
      y: Expr(i64)
    }
    impl Point : () {
      pub fn new(x: Expr(i64), y: Expr(i64)) -> Expr(Self) : fn(i64, i64) -> Point{x: Expr(i64), y: Expr(i64)} : fn(i64, i64) -> Point{x: Expr(i64), y: Expr(i64)}
        block (1 stmt) : Point{x: Expr(i64), y: Expr(i64)}
          expr_stmt (value)
            struct Self : Point{x: Expr(i64), y: Expr(i64)}
              x:
                locator x : i64
              y:
                locator y : i64
      pub fn translate(&mut self, dx: Expr(i64), dy: Expr(i64)) -> () : fn(i64, i64) -> () : fn(i64, i64) -> ()
        block (2 stmts) : ()
          expr_stmt ;
            assign : i64
              target:
                select .x [unknown] : i64
                  object:
                    locator self : &Point{x: Expr(i64), y: Expr(i64)}
              value:
                binop + : i64
                  lhs:
                    select .x [unknown] : i64
                      object:
                        locator self : &Point{x: Expr(i64), y: Expr(i64)}
                  rhs:
                    locator dx : i64
          expr_stmt ;
            assign : i64
              target:
                select .y [unknown] : i64
                  object:
                    locator self : &Point{x: Expr(i64), y: Expr(i64)}
              value:
                binop + : i64
                  lhs:
                    select .y [unknown] : i64
                      object:
                        locator self : &Point{x: Expr(i64), y: Expr(i64)}
                  rhs:
                    locator dy : i64
      pub fn distance2(&self, other: &Expr(Self)) -> Expr(i64) : fn(&Point{x: Expr(i64), y: Expr(i64)}) -> i64 : fn(&Point{x: Expr(i64), y: Expr(i64)}) -> i64
        block (3 stmts) : i64
          let dx
            init:
              binop - : i64
                lhs:
                  select .x [unknown] : i64
                    object:
                      locator self : &Point{x: Expr(i64), y: Expr(i64)}
                rhs:
                  select .x [unknown] : i64
                    object:
                      locator other : &Point{x: Expr(i64), y: Expr(i64)}
          let dy
            init:
              binop - : i64
                lhs:
                  select .y [unknown] : i64
                    object:
                      locator self : &Point{x: Expr(i64), y: Expr(i64)}
                rhs:
                  select .y [unknown] : i64
                    object:
                      locator other : &Point{x: Expr(i64), y: Expr(i64)}
          expr_stmt (value)
            binop + : i64
              lhs:
                binop * : i64
                  lhs:
                    locator dx : i64
                  rhs:
                    locator dx : i64
              rhs:
                binop * : i64
                  lhs:
                    locator dy : i64
                  rhs:
                    locator dy : i64
    }
    pub struct Rectangle : Rectangle{width: Expr(i64), height: Expr(i64)} {
      width: Expr(i64)
      height: Expr(i64)
    }
    impl Rectangle : () {
      pub fn new(width: Expr(i64), height: Expr(i64)) -> Expr(Self) : fn(i64, i64) -> Rectangle{width: Expr(i64), height: Expr(i64)} : fn(i64, i64) -> Rectangle{width: Expr(i64), height: Expr(i64)}
        block (1 stmt) : Rectangle{width: Expr(i64), height: Expr(i64)}
          expr_stmt (value)
            struct Self : Rectangle{width: Expr(i64), height: Expr(i64)}
              width:
                locator width : i64
              height:
                locator height : i64
      pub fn area(&self) -> Expr(i64) : fn() -> i64 : fn() -> i64
        block (1 stmt) : i64
          expr_stmt (value)
            binop * : i64
              lhs:
                select .width [unknown] : i64
                  object:
                    locator self : &Rectangle{width: Expr(i64), height: Expr(i64)}
              rhs:
                select .height [unknown] : i64
                  object:
                    locator self : &Rectangle{width: Expr(i64), height: Expr(i64)}
      pub fn perimeter(&self) -> Expr(i64) : fn() -> i64 : fn() -> i64
        block (1 stmt) : i64
          expr_stmt (value)
            binop * : i64
              lhs:
                value 2 : i64
              rhs:
                binop + : i64
                  lhs:
                    select .width [unknown] : i64
                      object:
                        locator self : &Rectangle{width: Expr(i64), height: Expr(i64)}
                  rhs:
                    select .height [unknown] : i64
                      object:
                        locator self : &Rectangle{width: Expr(i64), height: Expr(i64)}
      pub fn is_square(&self) -> Expr(bool) : fn() -> bool : fn() -> bool
        block (1 stmt) : bool
          expr_stmt (value)
            binop == : bool
              lhs:
                select .width [unknown] : i64
                  object:
                    locator self : &Rectangle{width: Expr(i64), height: Expr(i64)}
              rhs:
                select .height [unknown] : i64
                  object:
                    locator self : &Rectangle{width: Expr(i64), height: Expr(i64)}
    }
    pub fn main() -> () : fn() -> () : fn() -> ()
      block (18 stmts) : ()
        expr_stmt ;
          intrinsic println : ()
            template: "ðŸ“˜ Tutorial: 06_struct_methods.fp"
        expr_stmt ;
          intrinsic println : ()
            template: "ðŸ§­ Focus: Struct methods and field access"
        expr_stmt ;
          intrinsic println : ()
            template: "ðŸ§ª What to look for: labeled outputs below"
        expr_stmt ;
          intrinsic println : ()
            template: "âœ… Expectation: outputs match labels"
        expr_stmt ;
          intrinsic println : ()
            template: ""
        expr_stmt ;
          intrinsic println : ()
            template: "=== Struct Operations ==="
        let mut p1
          init:
            invoke : Point{x: Expr(i64), y: Expr(i64)}
              target: Point::new
              args:
                value 10 : i64
                value 20 : i64
        let p2
          init:
            invoke : Point{x: Expr(i64), y: Expr(i64)}
              target: Point::new
              args:
                value 5 : i64
                value 15 : i64
        expr_stmt ;
          intrinsic println : ()
            template: "p1 = ({}, {})" p1.x, p1.y
        expr_stmt ;
          intrinsic println : ()
            template: "p2 = ({}, {})" p2.x, p2.y
        expr_stmt ;
          invoke : ()
            target: p1.translate
            args:
              value 3 : i64
              unop - : i64
                value:
                  value 4 : i64
        expr_stmt ;
          intrinsic println : ()
            template: "p1 after translate = ({}, {})" p1.x, p1.y
        expr_stmt ;
          intrinsic println : ()
            template: "DistanceÂ²(p1, p2) = {}" p1.distance2(<expr>)
        let rect
          init:
            invoke : Rectangle{width: Expr(i64), height: Expr(i64)}
              target: Rectangle::new
              args:
                value 10 : i64
                value 5 : i64
        expr_stmt ;
          intrinsic println : ()
            template: "Rectangle: {}Ã—{}" rect.width, rect.height
        expr_stmt ;
          intrinsic println : ()
            template: "  area = {}" rect.area()
        expr_stmt ;
          intrinsic println : ()
            template: "  perimeter = {}" rect.perimeter()
        expr_stmt ;
          intrinsic println : ()
            template: "  is_square = {}" rect.is_square()
}
