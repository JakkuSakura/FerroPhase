ast::File {
  items:
    pub module std : () {
      pub module bench : () {
        pub struct BenchCase : BenchCase{name: Expr(str), run: fn() -> ()} {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<BenchCase{name: Expr(str), run: fn() -> ()}> : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
          value [0 values] : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
        pub const fn bench(item: Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item>
          block (3 stmts) : Quote<item>
            let name
              init:
                select .name [unknown] : string
                  object:
                    locator item : Quote<item>
            expr_stmt ;
              invoke : ()
                target: REGISTRY.push
                args:
                  struct BenchCase : _
                    name:
                      locator name : _
                    run:
                      select .value [unknown] : _
                        object:
                          locator item : _
            expr_stmt (value)
              locator item : Quote<item>
        pub struct BenchReport : BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_benches() -> Expr(BenchReport) : fn() -> BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} : fn() -> BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts) : BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
            let benches: Vec<Expr(BenchCase)>
              init:
                value [0 values] : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
            let mut passed
              init:
                value 0 : i64
            let mut failed
              init:
                value 0 : i64
            let mut idx
              init:
                value 0 : i64
            expr_stmt (value)
              while : ()
                cond:
                  binop < : bool
                    lhs:
                      locator idx : i64
                    rhs:
                      invoke : i64
                        target: benches.len
                body:
                  block (16 stmts) : ()
                    let bench: Expr(BenchCase)
                      init:
                        index : BenchCase{name: Expr(str), run: fn() -> ()}
                          value:
                            locator benches : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
                          index:
                            locator idx : i64
                    let mut ok
                      init:
                        value true : bool
                    let warmup_secs
                      init:
                        value 5 : f64
                    let measure_secs
                      init:
                        value 15 : f64
                    let warmup_start
                      init:
                        intrinsic time_now : any
                          args: []
                          kwargs: []
                    let warmup_deadline
                      init:
                        binop + : any
                          lhs:
                            locator warmup_start : any
                          rhs:
                            locator warmup_secs : f64
                    let mut warmup_iters
                      init:
                        value 0 : i64
                    expr_stmt (value)
                      while : ()
                        cond:
                          binop < : bool
                            lhs:
                              intrinsic time_now : any
                                args: []
                                kwargs: []
                            rhs:
                              locator warmup_deadline : any
                        body:
                          block (3 stmts) : ()
                            let warm_ok
                              init:
                                intrinsic catch_unwind : bool
                                  args:
                                    select .run [unknown] : fn() -> ()
                                      object:
                                        locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                  kwargs: []
                            expr_stmt (value)
                              if : ()
                                cond:
                                  unop ! : bool
                                    value:
                                      locator warm_ok : bool
                                then:
                                  block (2 stmts) : ()
                                    expr_stmt ;
                                      assign : bool
                                        target:
                                          locator ok : bool
                                        value:
                                          value false : bool
                                    expr_stmt ;
                                      break : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator warmup_iters : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator warmup_iters : i64
                                    rhs:
                                      value 1 : i64
                    let measure_start
                      init:
                        intrinsic time_now : any
                          args: []
                          kwargs: []
                    let measure_deadline
                      init:
                        binop + : any
                          lhs:
                            locator measure_start : any
                          rhs:
                            locator measure_secs : f64
                    let mut measure_iters
                      init:
                        value 0 : i64
                    expr_stmt (value)
                      if : ()
                        cond:
                          locator ok : bool
                        then:
                          block (1 stmt) : ()
                            expr_stmt (value)
                              while : ()
                                cond:
                                  binop || : bool
                                    lhs:
                                      binop < : bool
                                        lhs:
                                          intrinsic time_now : any
                                            args: []
                                            kwargs: []
                                        rhs:
                                          locator measure_deadline : any
                                    rhs:
                                      binop == : bool
                                        lhs:
                                          locator measure_iters : i64
                                        rhs:
                                          value 0 : i64
                                body:
                                  block (3 stmts) : ()
                                    let run_ok
                                      init:
                                        intrinsic catch_unwind : bool
                                          args:
                                            select .run [unknown] : fn() -> ()
                                              object:
                                                locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                          kwargs: []
                                    expr_stmt (value)
                                      if : ()
                                        cond:
                                          unop ! : bool
                                            value:
                                              locator run_ok : bool
                                        then:
                                          block (2 stmts) : ()
                                            expr_stmt ;
                                              assign : bool
                                                target:
                                                  locator ok : bool
                                                value:
                                                  value false : bool
                                            expr_stmt ;
                                              break : ()
                                    expr_stmt ;
                                      assign : i64
                                        target:
                                          locator measure_iters : i64
                                        value:
                                          binop + : i64
                                            lhs:
                                              locator measure_iters : i64
                                            rhs:
                                              value 1 : i64
                    let measure_end
                      init:
                        intrinsic time_now : any
                          args: []
                          kwargs: []
                    let elapsed
                      init:
                        binop - : any
                          lhs:
                            locator measure_end : any
                          rhs:
                            locator measure_start : any
                    expr_stmt (value)
                      if : ()
                        cond:
                          locator ok : bool
                        then:
                          block (4 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator passed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator passed : i64
                                    rhs:
                                      value 1 : i64
                            let iters_f
                              init:
                                cast : f64 -> Expr(f64)
                                  locator measure_iters : i64
                            let ns_per_iter
                              init:
                                if : any
                                  cond:
                                    binop > : bool
                                      lhs:
                                        locator iters_f : f64
                                      rhs:
                                        value 0 : f64
                                  then:
                                    block (1 stmt) : any
                                      expr_stmt (value)
                                        binop * : any
                                          lhs:
                                            binop / : any
                                              lhs:
                                                locator elapsed : any
                                              rhs:
                                                locator iters_f : f64
                                          rhs:
                                            value 1000000000 : f64
                                  else:
                                    block (1 stmt) : f64
                                      expr_stmt (value)
                                        value 0 : f64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... ok (iters: {}, time: {:.6}s, ns/iter: {:.2})" : string
                                  select .name [unknown] : string
                                    object:
                                      locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                  locator measure_iters : i64
                                  locator elapsed : any
                                  locator ns_per_iter : any
                                kwargs: []
                        else:
                          block (2 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator failed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator failed : i64
                                    rhs:
                                      value 1 : i64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... FAILED" : string
                                  select .name [unknown] : string
                                    object:
                                      locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                kwargs: []
                    expr_stmt ;
                      assign : i64
                        target:
                          locator idx : i64
                        value:
                          binop + : i64
                            lhs:
                              locator idx : i64
                            rhs:
                              value 1 : i64
            let total
              init:
                binop + : i64
                  lhs:
                    locator passed : i64
                  rhs:
                    locator failed : i64
            expr_stmt ;
              intrinsic println : ()
                args:
                  format_string "bench result: {} passed; {} failed; {} total" : string
                  locator passed : i64
                  locator failed : i64
                  locator total : i64
                kwargs: []
            expr_stmt (value)
              struct BenchReport : BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
                total:
                  locator total : i64
                passed:
                  locator passed : i64
                failed:
                  locator failed : i64
      }
      pub module collections : () {
        pub struct HashMapEntry : HashMapEntry{key: Expr(K), value: Expr(V)} {
          key: Expr(K)
          value: Expr(V)
        }
        pub struct HashMap : HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>} {
          entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>
        }
        impl HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })> : () {
          pub fn from(entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>) -> Expr(HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>) : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>} : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
            block (1 stmt) : HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
              expr_stmt (value)
                struct HashMap : HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
                  entries:
                    locator entries : Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>
          pub fn len(&self) -> Expr(i64) : fn() -> i64 : fn() -> i64
            block (1 stmt) : i64
              expr_stmt (value)
                invoke : i64
                  target: self.entries.len
          pub fn get_unchecked(&self, key: Expr(K)) -> Expr(V) : fn(any) -> any : fn(any) -> any
            block (3 stmts) : !
              let mut idx
                init:
                  value 0 : i64
              expr_stmt (value)
                while : ()
                  cond:
                    binop < : bool
                      lhs:
                        locator idx : i64
                      rhs:
                        invoke : i64
                          target: self.entries.len
                  body:
                    block (3 stmts) : ()
                      let entry
                        init:
                          index : HashMapEntry{key: Expr(K), value: Expr(V)}
                            value:
                              select .entries [unknown] : Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>
                                object:
                                  locator self : &HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
                            index:
                              locator idx : i64
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop == : bool
                              lhs:
                                select .key [unknown] : any
                                  object:
                                    locator entry : HashMapEntry{key: Expr(K), value: Expr(V)}
                              rhs:
                                locator key : any
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                return : !
                                  select .value [unknown] : any
                                    object:
                                      locator entry : HashMapEntry{key: Expr(K), value: Expr(V)}
                      expr_stmt ;
                        assign : i64
                          target:
                            locator idx : i64
                          value:
                            binop + : i64
                              lhs:
                                locator idx : i64
                              rhs:
                                value 1 : i64
              expr_stmt (value)
                loop : !
                  block (0 stmts) : ()
        }
      }
      pub module json : () {
        pub struct JsonField : JsonField{key: &Expr(str), value: Expr(JsonValue)} {
          key: &Expr(str)
          value: Expr(JsonValue)
        }
        pub enum JsonValue : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] {
          Null: ()
          Bool: (Expr(bool))
          Number: (&Expr(str))
          String: (&Expr(str))
          Array: (Vec<Expr(JsonValue)>)
          Object: (Vec<Expr(JsonField)>)
        }
        pub fn parse(input: &Expr(str)) -> Expr(JsonValue) : fn(&string) -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn(&string) -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
          block (2 stmts) : unknown
            let mut parser
              init:
                invoke : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  target: Parser::new
                  args:
                    locator input : &string
            expr_stmt (value)
              invoke : unknown
                target: parser.parse_value
        pub fn print(value: Expr(JsonValue)) -> () : fn(JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> () : fn(JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt) : ()
            expr_stmt ;
              invoke : ()
                target: print_value
                args:
                  reference (mutable: unspecified) : &JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                    locator value : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
        pub fn print_value(value: &Expr(JsonValue)) -> () : fn(&JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> () : fn(&JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt) : ()
            expr_stmt (value)
              match : ()
                case #0
                  cond:
                    value true : _
                  body:
                    intrinsic print : ()
                      args:
                        format_string "null" : string
                      kwargs: []
                case #1
                  cond:
                    value true : _
                  body:
                    block (1 stmt) : ()
                      expr_stmt (value)
                        if : ()
                          cond:
                            locator b : bool
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "true" : string
                                  kwargs: []
                          else:
                            block (1 stmt) : ()
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "false" : string
                                  kwargs: []
                case #2
                  cond:
                    value true : _
                  body:
                    intrinsic print : ()
                      args:
                        format_string "{}" : string
                        locator n : &string
                      kwargs: []
                case #3
                  cond:
                    value true : _
                  body:
                    block (3 stmts) : ()
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "\"" : string
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "{}" : string
                            locator s : &string
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "\"" : string
                          kwargs: []
                case #4
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : ()
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "[" : string
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : i64
                      let items_len
                        init:
                          invoke : i64
                            target: items.len
                      expr_stmt (value)
                        while : ()
                          cond:
                            binop < : bool
                              lhs:
                                locator idx : i64
                              rhs:
                                locator items_len : i64
                          body:
                            block (4 stmts) : ()
                              expr_stmt (value)
                                if : ()
                                  cond:
                                    binop > : bool
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 0 : i64
                                  then:
                                    block (1 stmt) : ()
                                      expr_stmt ;
                                        intrinsic print : ()
                                          args:
                                            format_string "," : string
                                          kwargs: []
                              let item
                                init:
                                  index : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                    value:
                                      locator items : Vec<JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]>
                                    index:
                                      locator idx : i64
                              expr_stmt ;
                                invoke : ()
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : &JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                      locator item : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                              expr_stmt ;
                                assign : i64
                                  target:
                                    locator idx : i64
                                  value:
                                    binop + : i64
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 1 : i64
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "]" : string
                          kwargs: []
                case #5
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : ()
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "{" : string
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : i64
                      let fields_len
                        init:
                          invoke : i64
                            target: fields.len
                      expr_stmt (value)
                        while : ()
                          cond:
                            binop < : bool
                              lhs:
                                locator idx : i64
                              rhs:
                                locator fields_len : i64
                          body:
                            block (7 stmts) : ()
                              expr_stmt (value)
                                if : ()
                                  cond:
                                    binop > : bool
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 0 : i64
                                  then:
                                    block (1 stmt) : ()
                                      expr_stmt ;
                                        intrinsic print : ()
                                          args:
                                            format_string "," : string
                                          kwargs: []
                              let field
                                init:
                                  index : JsonField{key: &Expr(str), value: Expr(JsonValue)}
                                    value:
                                      locator fields : Vec<JsonField{key: &Expr(str), value: Expr(JsonValue)}>
                                    index:
                                      locator idx : i64
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "\"" : string
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "{}" : string
                                    select .key [unknown] : &string
                                      object:
                                        locator field : JsonField{key: &Expr(str), value: Expr(JsonValue)}
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "\":" : string
                                  kwargs: []
                              expr_stmt ;
                                invoke : ()
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : &JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                      select .value [unknown] : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                        object:
                                          locator field : JsonField{key: &Expr(str), value: Expr(JsonValue)}
                              expr_stmt ;
                                assign : i64
                                  target:
                                    locator idx : i64
                                  value:
                                    binop + : i64
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 1 : i64
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "}" : string
                          kwargs: []
        pub struct Parser : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)} {
          src: Vec<&Expr(str)>
          pos: Expr(i64)
        }
        impl Parser : () {
          pub fn new(src: &Expr(str)) -> Expr(Parser) : fn(&string) -> Parser{src: Vec<&Expr(str)>, pos: Expr(i64)} : fn(&string) -> Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
            block (5 stmts) : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              let mut chars
                init:
                  value [0 values] : Vec<unknown>
              let mut idx
                init:
                  value 0 : i64
              let src_len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: src.len
              expr_stmt (value)
                while : ()
                  cond:
                    binop < : bool
                      lhs:
                        locator idx : i64
                      rhs:
                        locator src_len : i64
                  body:
                    block (4 stmts) : ()
                      let offset
                        init:
                          cast : u64 -> Expr(usize)
                            locator idx : i64
                      let ch
                        init:
                          index : string
                            value:
                              locator src : &string
                            index:
                              range [exclusive] : _
                                start:
                                  locator offset : u64
                                end:
                                  binop + : u64
                                    lhs:
                                      locator offset : u64
                                    rhs:
                                      value 1 : i64
                      expr_stmt ;
                        invoke : ()
                          target: chars.push
                          args:
                            locator ch : _
                      expr_stmt ;
                        assign : i64
                          target:
                            locator idx : i64
                          value:
                            binop + : i64
                              lhs:
                                locator idx : i64
                              rhs:
                                value 1 : i64
              expr_stmt (value)
                struct Parser : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  src:
                    locator chars : Vec<unknown>
                  pos:
                    value 0 : i64
          pub fn bump(&mut self, amount: Expr(i64)) -> () : fn(i64) -> () : fn(i64) -> ()
            block (1 stmt) : ()
              expr_stmt ;
                assign : i64
                  target:
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  value:
                    binop + : i64
                      lhs:
                        select .pos [unknown] : i64
                          object:
                            locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                      rhs:
                        locator amount : i64
          pub fn parse_value(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (9 stmts) : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt ;
                invoke : unknown
                  target: self.skip_ws
              let ch
                init:
                  invoke : unknown
                    target: self.peek
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        locator ch : unknown
                      rhs:
                        value "{" : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          invoke : unknown
                            target: self.parse_object
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        locator ch : unknown
                      rhs:
                        value "[" : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          invoke : unknown
                            target: self.parse_array
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        locator ch : unknown
                      rhs:
                        value "\"" : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::String
                            args:
                              invoke : unknown
                                target: self.parse_string
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : unknown
                      target: self.starts_with
                      args:
                        value "true" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 4 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Bool
                            args:
                              value true : bool
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : bool
                      target: self.starts_with
                      args:
                        value "false" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 5 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Bool
                            args:
                              value false : bool
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : bool
                      target: self.starts_with
                      args:
                        value "null" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 4 : i64
                      expr_stmt ;
                        return : !
                          locator JsonValue::Null : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt (value)
                invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                  target: JsonValue::Number
                  args:
                    invoke : unknown
                      target: self.parse_number
          pub fn parse_array(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts) : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt ;
                invoke : unknown
                  target: self.expect_char
                  args:
                    value "[" : &string
              expr_stmt ;
                invoke : unknown
                  target: self.skip_ws
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        invoke : unknown
                          target: self.peek
                      rhs:
                        value "]" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Array
                            args:
                              value [0 values] : Vec<unknown>
              let mut items
                init:
                  value [0 values] : Vec<unknown>
              expr_stmt (value)
                loop : ()
                  block (6 stmts) : ()
                    let value
                      init:
                        invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                          target: self.parse_value
                    expr_stmt ;
                      invoke : ()
                        target: items.push
                        args:
                          locator value : _
                    expr_stmt ;
                      invoke : unknown
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : &string
                          target: self.peek
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "," : &string
                        then:
                          block (3 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              invoke : unknown
                                target: self.skip_ws
                            expr_stmt ;
                              continue : !
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "]" : &string
                        then:
                          block (2 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              break : ()
              expr_stmt (value)
                invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                  target: JsonValue::Array
                  args:
                    locator items : Vec<unknown>
          pub fn parse_object(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts) : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt ;
                invoke : unknown
                  target: self.expect_char
                  args:
                    value "{" : &string
              expr_stmt ;
                invoke : unknown
                  target: self.skip_ws
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        invoke : &string
                          target: self.peek
                      rhs:
                        value "}" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Object
                            args:
                              value [0 values] : Vec<unknown>
              let mut fields
                init:
                  value [0 values] : Vec<unknown>
              expr_stmt (value)
                loop : ()
                  block (10 stmts) : ()
                    let key
                      init:
                        invoke : &string
                          target: self.parse_string
                    expr_stmt ;
                      invoke : unknown
                        target: self.skip_ws
                    expr_stmt ;
                      invoke : unknown
                        target: self.expect_char
                        args:
                          value ":" : &string
                    expr_stmt ;
                      invoke : unknown
                        target: self.skip_ws
                    let value
                      init:
                        invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                          target: self.parse_value
                    expr_stmt ;
                      invoke : ()
                        target: fields.push
                        args:
                          struct JsonField : _
                            key:
                              locator key : _
                            value:
                              locator value : _
                    expr_stmt ;
                      invoke : unknown
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : &string
                          target: self.peek
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "," : &string
                        then:
                          block (3 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              invoke : unknown
                                target: self.skip_ws
                            expr_stmt ;
                              continue : !
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "}" : &string
                        then:
                          block (2 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              break : ()
              expr_stmt (value)
                invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                  target: JsonValue::Object
                  args:
                    locator fields : Vec<unknown>
          pub fn parse_string(&mut self) -> &Expr(str) : fn() -> &string : fn() -> &string
            block (4 stmts) : string
              expr_stmt ;
                invoke : unknown
                  target: self.expect_char
                  args:
                    value "\"" : &string
              let start
                init:
                  cast : u64 -> Expr(usize)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              expr_stmt (value)
                while : ()
                  cond:
                    unop ! : bool
                      value:
                        invoke : unknown
                          target: self.is_eof
                  body:
                    block (4 stmts) : ()
                      let ch
                        init:
                          invoke : &string
                            target: self.peek
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop == : bool
                              lhs:
                                locator ch : &string
                              rhs:
                                value "\"" : &string
                          then:
                            block (3 stmts) : ()
                              let value
                                init:
                                  index : string
                                    value:
                                      select .src [unknown] : Vec<&string>
                                        object:
                                          locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                                    index:
                                      range [exclusive] : _
                                        start:
                                          locator start : u64
                                        end:
                                          cast : u64 -> Expr(usize)
                                            select .pos [unknown] : i64
                                              object:
                                                locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                              expr_stmt ;
                                return : !
                                  locator value : string
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop == : bool
                              lhs:
                                locator ch : &string
                              rhs:
                                value "\\" : &string
                          then:
                            block (3 stmts) : ()
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                              expr_stmt (value)
                                if : ()
                                  cond:
                                    unop ! : bool
                                      value:
                                        invoke : bool
                                          target: self.is_eof
                                  then:
                                    block (1 stmt) : ()
                                      expr_stmt ;
                                        invoke : ()
                                          target: self.bump
                                          args:
                                            value 1 : i64
                              expr_stmt ;
                                continue : !
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
              expr_stmt (value)
                index : string
                  value:
                    select .src [unknown] : Vec<&string>
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  index:
                    range [exclusive] : _
                      start:
                        locator start : u64
                      end:
                        cast : u64 -> Expr(usize)
                          select .pos [unknown] : i64
                            object:
                              locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
          pub fn parse_number(&mut self) -> &Expr(str) : fn() -> &string : fn() -> &string
            block (3 stmts) : string
              let start
                init:
                  cast : u64 -> Expr(usize)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              expr_stmt (value)
                while : ()
                  cond:
                    unop ! : bool
                      value:
                        invoke : bool
                          target: self.is_eof
                  body:
                    block (2 stmts) : ()
                      let ch
                        init:
                          invoke : &string
                            target: self.peek
                      expr_stmt (value)
                        if : ()
                          cond:
                            invoke : bool
                              target: is_number_char
                              args:
                                locator ch : &string
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                          else:
                            block (1 stmt) : ()
                              expr_stmt ;
                                break : ()
              expr_stmt (value)
                index : string
                  value:
                    select .src [unknown] : Vec<&string>
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  index:
                    range [exclusive] : _
                      start:
                        locator start : u64
                      end:
                        cast : u64 -> Expr(usize)
                          select .pos [unknown] : i64
                            object:
                              locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
          pub fn skip_ws(&mut self) -> () : fn() -> () : fn() -> ()
            block (1 stmt) : ()
              expr_stmt (value)
                while : ()
                  cond:
                    unop ! : bool
                      value:
                        invoke : bool
                          target: self.is_eof
                  body:
                    block (2 stmts) : ()
                      let ch
                        init:
                          invoke : &string
                            target: self.peek
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop || : bool
                              lhs:
                                binop || : bool
                                  lhs:
                                    binop || : bool
                                      lhs:
                                        binop == : bool
                                          lhs:
                                            locator ch : &string
                                          rhs:
                                            value " " : &string
                                      rhs:
                                        binop == : bool
                                          lhs:
                                            locator ch : &string
                                          rhs:
                                            value "\n" : &string
                                  rhs:
                                    binop == : bool
                                      lhs:
                                        locator ch : &string
                                      rhs:
                                        value "\t" : &string
                              rhs:
                                binop == : bool
                                  lhs:
                                    locator ch : &string
                                  rhs:
                                    value "\r" : &string
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                          else:
                            block (1 stmt) : ()
                              expr_stmt ;
                                break : ()
          pub fn expect_char(&mut self, ch: &Expr(str)) -> () : fn(&string) -> () : fn(&string) -> ()
            block (1 stmt) : ()
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        invoke : &string
                          target: self.peek
                      rhs:
                        locator ch : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
          pub fn starts_with(&self, literal: &Expr(str)) -> Expr(bool) : fn(&string) -> bool : fn(&string) -> bool
            block (7 stmts) : bool
              let pos
                init:
                  cast : u64 -> Expr(usize)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              let mut idx
                init:
                  value 0 : i64
              let literal_len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: literal.len
              let src_len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: self.src.len
              let pos_i64
                init:
                  cast : i64 -> Expr(i64)
                    locator pos : u64
              expr_stmt (value)
                while : ()
                  cond:
                    binop < : bool
                      lhs:
                        locator idx : i64
                      rhs:
                        locator literal_len : i64
                  body:
                    block (4 stmts) : ()
                      let offset
                        init:
                          cast : u64 -> Expr(usize)
                            locator idx : i64
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop >= : bool
                              lhs:
                                binop + : i64
                                  lhs:
                                    locator pos_i64 : i64
                                  rhs:
                                    locator idx : i64
                              rhs:
                                locator src_len : i64
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                return : !
                                  value false : bool
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop != : bool
                              lhs:
                                index : &string
                                  value:
                                    select .src [unknown] : Vec<&string>
                                      object:
                                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                                  index:
                                    binop + : u64
                                      lhs:
                                        locator pos : u64
                                      rhs:
                                        locator offset : u64
                              rhs:
                                index : string
                                  value:
                                    locator literal : &string
                                  index:
                                    range [exclusive] : _
                                      start:
                                        locator offset : u64
                                      end:
                                        binop + : u64
                                          lhs:
                                            locator offset : u64
                                          rhs:
                                            value 1 : i64
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                return : !
                                  value false : bool
                      expr_stmt ;
                        assign : i64
                          target:
                            locator idx : i64
                          value:
                            binop + : i64
                              lhs:
                                locator idx : i64
                              rhs:
                                value 1 : i64
              expr_stmt (value)
                value true : bool
          pub fn peek(&self) -> &Expr(str) : fn() -> &string : fn() -> &string
            block (2 stmts) : &string
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : bool
                      target: self.is_eof
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          value "" : &string
              expr_stmt (value)
                index : &string
                  value:
                    select .src [unknown] : Vec<&string>
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  index:
                    cast : u64 -> Expr(usize)
                      select .pos [unknown] : i64
                        object:
                          locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
          pub fn is_eof(&self) -> Expr(bool) : fn() -> bool : fn() -> bool
            block (3 stmts) : bool
              let pos
                init:
                  cast : i64 -> Expr(i64)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              let len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: self.src.len
              expr_stmt (value)
                binop >= : bool
                  lhs:
                    locator pos : i64
                  rhs:
                    locator len : i64
        }
        pub fn is_number_char(ch: &Expr(str)) -> Expr(bool) : fn(&string) -> bool : fn(&string) -> bool
          block (1 stmt) : bool
            expr_stmt (value)
              match : bool
                case #0
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #1
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #2
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #3
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #4
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #5
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #6
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #7
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #8
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #9
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #10
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #11
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #12
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #13
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #14
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #15
                  cond:
                    value true : _
                  body:
                    value false : bool
      }
      pub module intrinsic : () {
        pub [attrs] const fn create_struct(name: &Expr(str)) -> type : fn(&string) -> type : fn(&string) -> type
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "create_struct is a compiler intrinsic" : _
                kwargs: []
        pub [attrs] const fn addfield(ty: type, name: &Expr(str), field_ty: type) -> type : fn(type, &string, type) -> type : fn(type, &string, type) -> type
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "addfield is a compiler intrinsic" : _
                kwargs: []
      }
      pub module meta : () {
        pub struct TypeBuilder : TypeBuilder{ty: type} {
          ty: type
        }
        impl TypeBuilder : () {
          pub const fn new(name: &Expr(str)) -> Expr(TypeBuilder) : fn(&string) -> TypeBuilder{ty: type} : fn(&string) -> TypeBuilder{ty: type}
            block (1 stmt) : TypeBuilder{ty: type}
              expr_stmt (value)
                struct TypeBuilder : TypeBuilder{ty: type}
                  ty:
                    intrinsic create_struct : type
                      args:
                        locator name : &string
                      kwargs: []
          pub const fn from(ty: type) -> Expr(TypeBuilder) : fn(type) -> TypeBuilder{ty: type} : fn(type) -> TypeBuilder{ty: type}
            block (1 stmt) : TypeBuilder{ty: type}
              expr_stmt (value)
                struct TypeBuilder : TypeBuilder{ty: type}
                  ty:
                    locator ty : type
          pub const fn with_field(self, name: &Expr(str), field_ty: type) -> Expr(TypeBuilder) : fn(&string, type) -> TypeBuilder{ty: type} : fn(&string, type) -> TypeBuilder{ty: type}
            block (2 stmts) : TypeBuilder{ty: type}
              let ty
                init:
                  intrinsic add_field : type
                    args:
                      select .ty [unknown] : type
                        object:
                          locator self : TypeBuilder{ty: type}
                      locator name : &string
                      locator field_ty : type
                    kwargs: []
              expr_stmt (value)
                struct TypeBuilder : TypeBuilder{ty: type}
                  ty:
                    locator ty : type
          pub const fn build(self) -> type : fn() -> type : fn() -> type
            block (1 stmt) : type
              expr_stmt (value)
                select .ty [unknown] : type
                  object:
                    locator self : TypeBuilder{ty: type}
        }
      }
      pub module proc_macro : () {
        pub enum Delimiter : Delimiter [Parenthesis: () | Brace: () | Bracket: ()] {
          Parenthesis: ()
          Brace: ()
          Bracket: ()
        }
        pub struct Group : Group{delimiter: Expr(Delimiter), tokens: Vec<Expr(TokenTree)>} {
          delimiter: Expr(Delimiter)
          tokens: Vec<Expr(TokenTree)>
        }
        pub struct Ident : Ident{text: Expr(str)} {
          text: Expr(str)
        }
        pub struct Punct : Punct{text: Expr(str)} {
          text: Expr(str)
        }
        pub struct Literal : Literal{text: Expr(str)} {
          text: Expr(str)
        }
        pub enum TokenTree : TokenTree [Token: (Expr(str)) | Group: (Expr(Group))] {
          Token: (Expr(str))
          Group: (Expr(Group))
        }
        pub struct TokenStream : TokenStream {
        }
        pub const fn token_stream_from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream : fn(string) -> TokenStream
          block (1 stmt) : any
            expr_stmt (value)
              intrinsic token_stream_from_str : any
                args:
                  locator text : string
                kwargs: []
        pub const fn token_stream_to_string(stream: Expr(TokenStream)) -> Expr(str) : fn(TokenStream) -> string : fn(TokenStream) -> string
          block (1 stmt) : any
            expr_stmt (value)
              intrinsic token_stream_to_string : any
                args:
                  locator stream : TokenStream
                kwargs: []
        impl TokenStream : () {
          pub fn from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream : fn(string) -> TokenStream
            block (1 stmt) : any
              expr_stmt (value)
                intrinsic token_stream_from_str : any
                  args:
                    locator text : string
                  kwargs: []
          pub fn to_string(self) -> Expr(str) : fn() -> string : fn() -> string
            block (1 stmt) : any
              expr_stmt (value)
                intrinsic token_stream_to_string : any
                  args:
                    locator self : TokenStream
                  kwargs: []
        }
      }
      pub module test : () {
        pub struct TestCase : TestCase{name: Expr(str), run: fn() -> ()} {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<TestCase{name: Expr(str), run: fn() -> ()}> : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
          value [0 values] : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
        pub const fn test(item: Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item>
          block (3 stmts) : Quote<item>
            let name
              init:
                select .name [unknown] : string
                  object:
                    locator item : Quote<item>
            expr_stmt ;
              invoke : ()
                target: REGISTRY.push
                args:
                  struct TestCase : _
                    name:
                      locator name : _
                    run:
                      select .value [unknown] : _
                        object:
                          locator item : _
            expr_stmt (value)
              locator item : Quote<item>
        pub struct TestReport : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_tests() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts) : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
            let tests: Vec<Expr(TestCase)>
              init:
                value [0 values] : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
            let mut passed
              init:
                value 0 : i64
            let mut failed
              init:
                value 0 : i64
            let mut idx
              init:
                value 0 : i64
            expr_stmt (value)
              while : ()
                cond:
                  binop < : bool
                    lhs:
                      locator idx : i64
                    rhs:
                      invoke : i64
                        target: tests.len
                body:
                  block (4 stmts) : ()
                    let test: Expr(TestCase)
                      init:
                        index : TestCase{name: Expr(str), run: fn() -> ()}
                          value:
                            locator tests : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
                          index:
                            locator idx : i64
                    let ok
                      init:
                        intrinsic catch_unwind : bool
                          args:
                            select .run [unknown] : fn() -> ()
                              object:
                                locator test : TestCase{name: Expr(str), run: fn() -> ()}
                          kwargs: []
                    expr_stmt (value)
                      if : ()
                        cond:
                          locator ok : bool
                        then:
                          block (2 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator passed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator passed : i64
                                    rhs:
                                      value 1 : i64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... ok" : string
                                  select .name [unknown] : string
                                    object:
                                      locator test : TestCase{name: Expr(str), run: fn() -> ()}
                                kwargs: []
                        else:
                          block (2 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator failed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator failed : i64
                                    rhs:
                                      value 1 : i64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... FAILED" : string
                                  select .name [unknown] : string
                                    object:
                                      locator test : TestCase{name: Expr(str), run: fn() -> ()}
                                kwargs: []
                    expr_stmt ;
                      assign : i64
                        target:
                          locator idx : i64
                        value:
                          binop + : i64
                            lhs:
                              locator idx : i64
                            rhs:
                              value 1 : i64
            let total
              init:
                binop + : i64
                  lhs:
                    locator passed : i64
                  rhs:
                    locator failed : i64
            expr_stmt ;
              intrinsic println : ()
                args:
                  format_string "test result: {} passed; {} failed; {} total" : string
                  locator passed : i64
                  locator failed : i64
                  locator total : i64
                kwargs: []
            expr_stmt (value)
              struct TestReport : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
                total:
                  locator total : i64
                passed:
                  locator passed : i64
                failed:
                  locator failed : i64
        pub fn run() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (1 stmt) : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
            expr_stmt (value)
              invoke : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
                target: run_tests
      }
      pub module time : () {
        pub [attrs] fn now() -> Expr(f64) : fn() -> f64 : fn() -> f64
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic time_now : _
                args: []
                kwargs: []
      }
      pub module bench : () {
        pub struct BenchCase : BenchCase{name: Expr(str), run: fn() -> ()} {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const mut REGISTRY: Vec<BenchCase{name: Expr(str), run: fn() -> ()}> : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
          intrinsic_container : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
            const_block : _
              invoke : _
                target: Vec::from
                args:
                  array (0 values) : _
        pub const fn bench(item: Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item>
          block (3 stmts) : Quote<item>
            let name
              init:
                select .name [unknown] : string
                  object:
                    locator item : Quote<item>
            expr_stmt ;
              invoke : ()
                target: REGISTRY.push
                args:
                  struct BenchCase : _
                    name:
                      locator name : _
                    run:
                      select .value [unknown] : _
                        object:
                          locator item : _
            expr_stmt (value)
              locator item : Quote<item>
        pub struct BenchReport : BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_benches() -> Expr(BenchReport) : fn() -> BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} : fn() -> BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts) : BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
            let benches: Vec<Expr(BenchCase)>
              init:
                locator REGISTRY : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
            let mut passed
              init:
                value 0 : i64
            let mut failed
              init:
                value 0 : i64
            let mut idx
              init:
                value 0 : i64
            expr_stmt (value)
              while : ()
                cond:
                  binop < : bool
                    lhs:
                      locator idx : i64
                    rhs:
                      invoke : i64
                        target: benches.len
                body:
                  block (16 stmts) : ()
                    let bench: Expr(BenchCase)
                      init:
                        index : BenchCase{name: Expr(str), run: fn() -> ()}
                          value:
                            locator benches : Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
                          index:
                            locator idx : i64
                    let mut ok
                      init:
                        value true : bool
                    let warmup_secs
                      init:
                        value 5 : f64
                    let measure_secs
                      init:
                        value 15 : f64
                    let warmup_start
                      init:
                        intrinsic time_now : any
                          args: []
                          kwargs: []
                    let warmup_deadline
                      init:
                        binop + : any
                          lhs:
                            locator warmup_start : any
                          rhs:
                            locator warmup_secs : f64
                    let mut warmup_iters
                      init:
                        value 0 : i64
                    expr_stmt (value)
                      while : ()
                        cond:
                          binop < : bool
                            lhs:
                              intrinsic time_now : any
                                args: []
                                kwargs: []
                            rhs:
                              locator warmup_deadline : any
                        body:
                          block (3 stmts) : ()
                            let warm_ok
                              init:
                                intrinsic catch_unwind : bool
                                  args:
                                    select .run [unknown] : fn() -> ()
                                      object:
                                        locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                  kwargs: []
                            expr_stmt (value)
                              if : ()
                                cond:
                                  unop ! : bool
                                    value:
                                      locator warm_ok : bool
                                then:
                                  block (2 stmts) : ()
                                    expr_stmt ;
                                      assign : bool
                                        target:
                                          locator ok : bool
                                        value:
                                          value false : bool
                                    expr_stmt ;
                                      break : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator warmup_iters : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator warmup_iters : i64
                                    rhs:
                                      value 1 : i64
                    let measure_start
                      init:
                        intrinsic time_now : any
                          args: []
                          kwargs: []
                    let measure_deadline
                      init:
                        binop + : any
                          lhs:
                            locator measure_start : any
                          rhs:
                            locator measure_secs : f64
                    let mut measure_iters
                      init:
                        value 0 : i64
                    expr_stmt (value)
                      if : ()
                        cond:
                          locator ok : bool
                        then:
                          block (1 stmt) : ()
                            expr_stmt (value)
                              while : ()
                                cond:
                                  binop || : bool
                                    lhs:
                                      binop < : bool
                                        lhs:
                                          intrinsic time_now : any
                                            args: []
                                            kwargs: []
                                        rhs:
                                          locator measure_deadline : any
                                    rhs:
                                      binop == : bool
                                        lhs:
                                          locator measure_iters : i64
                                        rhs:
                                          value 0 : i64
                                body:
                                  block (3 stmts) : ()
                                    let run_ok
                                      init:
                                        intrinsic catch_unwind : bool
                                          args:
                                            select .run [unknown] : fn() -> ()
                                              object:
                                                locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                          kwargs: []
                                    expr_stmt (value)
                                      if : ()
                                        cond:
                                          unop ! : bool
                                            value:
                                              locator run_ok : bool
                                        then:
                                          block (2 stmts) : ()
                                            expr_stmt ;
                                              assign : bool
                                                target:
                                                  locator ok : bool
                                                value:
                                                  value false : bool
                                            expr_stmt ;
                                              break : ()
                                    expr_stmt ;
                                      assign : i64
                                        target:
                                          locator measure_iters : i64
                                        value:
                                          binop + : i64
                                            lhs:
                                              locator measure_iters : i64
                                            rhs:
                                              value 1 : i64
                    let measure_end
                      init:
                        intrinsic time_now : any
                          args: []
                          kwargs: []
                    let elapsed
                      init:
                        binop - : any
                          lhs:
                            locator measure_end : any
                          rhs:
                            locator measure_start : any
                    expr_stmt (value)
                      if : ()
                        cond:
                          locator ok : bool
                        then:
                          block (4 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator passed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator passed : i64
                                    rhs:
                                      value 1 : i64
                            let iters_f
                              init:
                                cast : f64 -> Expr(f64)
                                  locator measure_iters : i64
                            let ns_per_iter
                              init:
                                if : any
                                  cond:
                                    binop > : bool
                                      lhs:
                                        locator iters_f : f64
                                      rhs:
                                        value 0 : f64
                                  then:
                                    block (1 stmt) : any
                                      expr_stmt (value)
                                        binop * : any
                                          lhs:
                                            binop / : any
                                              lhs:
                                                locator elapsed : any
                                              rhs:
                                                locator iters_f : f64
                                          rhs:
                                            value 1000000000 : f64
                                  else:
                                    block (1 stmt) : f64
                                      expr_stmt (value)
                                        value 0 : f64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... ok (iters: {}, time: {:.6}s, ns/iter: {:.2})" : string
                                  select .name [unknown] : string
                                    object:
                                      locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                  locator measure_iters : i64
                                  locator elapsed : any
                                  locator ns_per_iter : any
                                kwargs: []
                        else:
                          block (2 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator failed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator failed : i64
                                    rhs:
                                      value 1 : i64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... FAILED" : string
                                  select .name [unknown] : string
                                    object:
                                      locator bench : BenchCase{name: Expr(str), run: fn() -> ()}
                                kwargs: []
                    expr_stmt ;
                      assign : i64
                        target:
                          locator idx : i64
                        value:
                          binop + : i64
                            lhs:
                              locator idx : i64
                            rhs:
                              value 1 : i64
            let total
              init:
                binop + : i64
                  lhs:
                    locator passed : i64
                  rhs:
                    locator failed : i64
            expr_stmt ;
              intrinsic println : ()
                args:
                  format_string "bench result: {} passed; {} failed; {} total" : string
                  locator passed : i64
                  locator failed : i64
                  locator total : i64
                kwargs: []
            expr_stmt (value)
              struct BenchReport : BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
                total:
                  locator total : i64
                passed:
                  locator passed : i64
                failed:
                  locator failed : i64
      }
      pub module collections : () {
        pub struct HashMapEntry : HashMapEntry{key: Expr(K), value: Expr(V)} {
          key: Expr(K)
          value: Expr(V)
        }
        pub struct HashMap : HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>} {
          entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>
        }
        impl HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })> : () {
          pub fn from(entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>) -> Expr(HashMap<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>) : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>} : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
            block (1 stmt) : HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
              expr_stmt (value)
                struct HashMap : HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
                  entries:
                    locator entries : Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>
          pub fn len(&self) -> Expr(i64) : fn() -> i64 : fn() -> i64
            block (1 stmt) : i64
              expr_stmt (value)
                invoke : i64
                  target: self.entries.len
          pub fn get_unchecked(&self, key: Expr(K)) -> Expr(V) : fn(any) -> any : fn(any) -> any
            block (3 stmts) : !
              let mut idx
                init:
                  value 0 : i64
              expr_stmt (value)
                while : ()
                  cond:
                    binop < : bool
                      lhs:
                        locator idx : i64
                      rhs:
                        invoke : i64
                          target: self.entries.len
                  body:
                    block (3 stmts) : ()
                      let entry
                        init:
                          index : HashMapEntry{key: Expr(K), value: Expr(V)}
                            value:
                              select .entries [unknown] : Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>
                                object:
                                  locator self : &HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Locator(Ident(Ident { name: "V" })) })>)>}
                            index:
                              locator idx : i64
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop == : bool
                              lhs:
                                select .key [unknown] : any
                                  object:
                                    locator entry : HashMapEntry{key: Expr(K), value: Expr(V)}
                              rhs:
                                locator key : any
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                return : !
                                  select .value [unknown] : any
                                    object:
                                      locator entry : HashMapEntry{key: Expr(K), value: Expr(V)}
                      expr_stmt ;
                        assign : i64
                          target:
                            locator idx : i64
                          value:
                            binop + : i64
                              lhs:
                                locator idx : i64
                              rhs:
                                value 1 : i64
              expr_stmt (value)
                loop : !
                  block (0 stmts) : ()
        }
      }
      pub module json : () {
        pub struct JsonField : JsonField{key: &Expr(str), value: Expr(JsonValue)} {
          key: &Expr(str)
          value: Expr(JsonValue)
        }
        pub enum JsonValue : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] {
          Null: ()
          Bool: (Expr(bool))
          Number: (&Expr(str))
          String: (&Expr(str))
          Array: (Vec<Expr(JsonValue)>)
          Object: (Vec<Expr(JsonField)>)
        }
        pub fn parse(input: &Expr(str)) -> Expr(JsonValue) : fn(&string) -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn(&string) -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
          block (2 stmts) : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            let mut parser
              init:
                invoke : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  target: Parser::new
                  args:
                    locator input : &string
            expr_stmt (value)
              invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                target: parser.parse_value
        pub fn print(value: Expr(JsonValue)) -> () : fn(JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> () : fn(JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt) : ()
            expr_stmt ;
              invoke : ()
                target: print_value
                args:
                  reference (mutable: unspecified) : &JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                    locator value : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
        pub fn print_value(value: &Expr(JsonValue)) -> () : fn(&JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> () : fn(&JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt) : ()
            expr_stmt (value)
              match : ()
                case #0
                  cond:
                    value true : _
                  body:
                    intrinsic print : ()
                      args:
                        format_string "null" : string
                      kwargs: []
                case #1
                  cond:
                    value true : _
                  body:
                    block (1 stmt) : ()
                      expr_stmt (value)
                        if : ()
                          cond:
                            locator b : bool
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "true" : string
                                  kwargs: []
                          else:
                            block (1 stmt) : ()
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "false" : string
                                  kwargs: []
                case #2
                  cond:
                    value true : _
                  body:
                    intrinsic print : ()
                      args:
                        format_string "{}" : string
                        locator n : &string
                      kwargs: []
                case #3
                  cond:
                    value true : _
                  body:
                    block (3 stmts) : ()
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "\"" : string
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "{}" : string
                            locator s : &string
                          kwargs: []
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "\"" : string
                          kwargs: []
                case #4
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : ()
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "[" : string
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : i64
                      let items_len
                        init:
                          invoke : i64
                            target: items.len
                      expr_stmt (value)
                        while : ()
                          cond:
                            binop < : bool
                              lhs:
                                locator idx : i64
                              rhs:
                                locator items_len : i64
                          body:
                            block (4 stmts) : ()
                              expr_stmt (value)
                                if : ()
                                  cond:
                                    binop > : bool
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 0 : i64
                                  then:
                                    block (1 stmt) : ()
                                      expr_stmt ;
                                        intrinsic print : ()
                                          args:
                                            format_string "," : string
                                          kwargs: []
                              let item
                                init:
                                  index : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                    value:
                                      locator items : Vec<JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]>
                                    index:
                                      locator idx : i64
                              expr_stmt ;
                                invoke : ()
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : &JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                      locator item : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                              expr_stmt ;
                                assign : i64
                                  target:
                                    locator idx : i64
                                  value:
                                    binop + : i64
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 1 : i64
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "]" : string
                          kwargs: []
                case #5
                  cond:
                    value true : _
                  body:
                    block (5 stmts) : ()
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "{" : string
                          kwargs: []
                      let mut idx
                        init:
                          value 0 : i64
                      let fields_len
                        init:
                          invoke : i64
                            target: fields.len
                      expr_stmt (value)
                        while : ()
                          cond:
                            binop < : bool
                              lhs:
                                locator idx : i64
                              rhs:
                                locator fields_len : i64
                          body:
                            block (7 stmts) : ()
                              expr_stmt (value)
                                if : ()
                                  cond:
                                    binop > : bool
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 0 : i64
                                  then:
                                    block (1 stmt) : ()
                                      expr_stmt ;
                                        intrinsic print : ()
                                          args:
                                            format_string "," : string
                                          kwargs: []
                              let field
                                init:
                                  index : JsonField{key: &Expr(str), value: Expr(JsonValue)}
                                    value:
                                      locator fields : Vec<JsonField{key: &Expr(str), value: Expr(JsonValue)}>
                                    index:
                                      locator idx : i64
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "\"" : string
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "{}" : string
                                    select .key [unknown] : &string
                                      object:
                                        locator field : JsonField{key: &Expr(str), value: Expr(JsonValue)}
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print : ()
                                  args:
                                    format_string "\":" : string
                                  kwargs: []
                              expr_stmt ;
                                invoke : ()
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified) : &JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                      select .value [unknown] : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                                        object:
                                          locator field : JsonField{key: &Expr(str), value: Expr(JsonValue)}
                              expr_stmt ;
                                assign : i64
                                  target:
                                    locator idx : i64
                                  value:
                                    binop + : i64
                                      lhs:
                                        locator idx : i64
                                      rhs:
                                        value 1 : i64
                      expr_stmt ;
                        intrinsic print : ()
                          args:
                            format_string "}" : string
                          kwargs: []
        pub struct Parser : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)} {
          src: Vec<&Expr(str)>
          pos: Expr(i64)
        }
        impl Parser : () {
          pub fn new(src: &Expr(str)) -> Expr(Parser) : fn(&string) -> Parser{src: Vec<&Expr(str)>, pos: Expr(i64)} : fn(&string) -> Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
            block (5 stmts) : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              let mut chars
                init:
                  value [0 values] : Vec<unknown>
              let mut idx
                init:
                  value 0 : i64
              let src_len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: src.len
              expr_stmt (value)
                while : ()
                  cond:
                    binop < : bool
                      lhs:
                        locator idx : i64
                      rhs:
                        locator src_len : i64
                  body:
                    block (4 stmts) : ()
                      let offset
                        init:
                          cast : u64 -> Expr(usize)
                            locator idx : i64
                      let ch
                        init:
                          index : string
                            value:
                              locator src : &string
                            index:
                              range [exclusive] : _
                                start:
                                  locator offset : u64
                                end:
                                  binop + : u64
                                    lhs:
                                      locator offset : u64
                                    rhs:
                                      value 1 : i64
                      expr_stmt ;
                        invoke : ()
                          target: chars.push
                          args:
                            locator ch : _
                      expr_stmt ;
                        assign : i64
                          target:
                            locator idx : i64
                          value:
                            binop + : i64
                              lhs:
                                locator idx : i64
                              rhs:
                                value 1 : i64
              expr_stmt (value)
                struct Parser : Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  src:
                    locator chars : Vec<unknown>
                  pos:
                    value 0 : i64
          pub fn bump(&mut self, amount: Expr(i64)) -> () : fn(i64) -> () : fn(i64) -> ()
            block (1 stmt) : ()
              expr_stmt ;
                assign : i64
                  target:
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  value:
                    binop + : i64
                      lhs:
                        select .pos [unknown] : i64
                          object:
                            locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                      rhs:
                        locator amount : i64
          pub fn parse_value(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (9 stmts) : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt ;
                invoke : ()
                  target: self.skip_ws
              let ch
                init:
                  invoke : &string
                    target: self.peek
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        locator ch : &string
                      rhs:
                        value "{" : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: self.parse_object
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        locator ch : &string
                      rhs:
                        value "[" : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: self.parse_array
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        locator ch : &string
                      rhs:
                        value "\"" : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::String
                            args:
                              invoke : &string
                                target: self.parse_string
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : bool
                      target: self.starts_with
                      args:
                        value "true" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 4 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Bool
                            args:
                              value true : bool
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : bool
                      target: self.starts_with
                      args:
                        value "false" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 5 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Bool
                            args:
                              value false : bool
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : bool
                      target: self.starts_with
                      args:
                        value "null" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 4 : i64
                      expr_stmt ;
                        return : !
                          locator JsonValue::Null : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt (value)
                invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                  target: JsonValue::Number
                  args:
                    invoke : &string
                      target: self.parse_number
          pub fn parse_array(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts) : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt ;
                invoke : ()
                  target: self.expect_char
                  args:
                    value "[" : &string
              expr_stmt ;
                invoke : ()
                  target: self.skip_ws
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        invoke : &string
                          target: self.peek
                      rhs:
                        value "]" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Array
                            args:
                              value [0 values] : Vec<unknown>
              let mut items
                init:
                  value [0 values] : Vec<unknown>
              expr_stmt (value)
                loop : ()
                  block (6 stmts) : ()
                    let value
                      init:
                        invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                          target: self.parse_value
                    expr_stmt ;
                      invoke : ()
                        target: items.push
                        args:
                          locator value : _
                    expr_stmt ;
                      invoke : ()
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : &string
                          target: self.peek
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "," : &string
                        then:
                          block (3 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              invoke : ()
                                target: self.skip_ws
                            expr_stmt ;
                              continue : !
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "]" : &string
                        then:
                          block (2 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              break : ()
              expr_stmt (value)
                invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                  target: JsonValue::Array
                  args:
                    locator items : Vec<unknown>
          pub fn parse_object(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)] : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts) : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
              expr_stmt ;
                invoke : ()
                  target: self.expect_char
                  args:
                    value "{" : &string
              expr_stmt ;
                invoke : ()
                  target: self.skip_ws
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        invoke : &string
                          target: self.peek
                      rhs:
                        value "}" : &string
                  then:
                    block (2 stmts) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
                      expr_stmt ;
                        return : !
                          invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                            target: JsonValue::Object
                            args:
                              value [0 values] : Vec<unknown>
              let mut fields
                init:
                  value [0 values] : Vec<unknown>
              expr_stmt (value)
                loop : ()
                  block (10 stmts) : ()
                    let key
                      init:
                        invoke : &string
                          target: self.parse_string
                    expr_stmt ;
                      invoke : ()
                        target: self.skip_ws
                    expr_stmt ;
                      invoke : ()
                        target: self.expect_char
                        args:
                          value ":" : &string
                    expr_stmt ;
                      invoke : ()
                        target: self.skip_ws
                    let value
                      init:
                        invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                          target: self.parse_value
                    expr_stmt ;
                      invoke : ()
                        target: fields.push
                        args:
                          struct JsonField : _
                            key:
                              locator key : _
                            value:
                              locator value : _
                    expr_stmt ;
                      invoke : ()
                        target: self.skip_ws
                    let ch
                      init:
                        invoke : &string
                          target: self.peek
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "," : &string
                        then:
                          block (3 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              invoke : ()
                                target: self.skip_ws
                            expr_stmt ;
                              continue : !
                    expr_stmt (value)
                      if : ()
                        cond:
                          binop == : bool
                            lhs:
                              locator ch : &string
                            rhs:
                              value "}" : &string
                        then:
                          block (2 stmts) : ()
                            expr_stmt ;
                              invoke : ()
                                target: self.bump
                                args:
                                  value 1 : i64
                            expr_stmt ;
                              break : ()
              expr_stmt (value)
                invoke : JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
                  target: JsonValue::Object
                  args:
                    locator fields : Vec<unknown>
          pub fn parse_string(&mut self) -> &Expr(str) : fn() -> &string : fn() -> &string
            block (4 stmts) : string
              expr_stmt ;
                invoke : ()
                  target: self.expect_char
                  args:
                    value "\"" : &string
              let start
                init:
                  cast : u64 -> Expr(usize)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              expr_stmt (value)
                while : ()
                  cond:
                    unop ! : bool
                      value:
                        invoke : bool
                          target: self.is_eof
                  body:
                    block (4 stmts) : ()
                      let ch
                        init:
                          invoke : &string
                            target: self.peek
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop == : bool
                              lhs:
                                locator ch : &string
                              rhs:
                                value "\"" : &string
                          then:
                            block (3 stmts) : ()
                              let value
                                init:
                                  index : string
                                    value:
                                      select .src [unknown] : Vec<&string>
                                        object:
                                          locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                                    index:
                                      range [exclusive] : _
                                        start:
                                          locator start : u64
                                        end:
                                          cast : u64 -> Expr(usize)
                                            select .pos [unknown] : i64
                                              object:
                                                locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                              expr_stmt ;
                                return : !
                                  locator value : string
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop == : bool
                              lhs:
                                locator ch : &string
                              rhs:
                                value "\\" : &string
                          then:
                            block (3 stmts) : ()
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                              expr_stmt (value)
                                if : ()
                                  cond:
                                    unop ! : bool
                                      value:
                                        invoke : bool
                                          target: self.is_eof
                                  then:
                                    block (1 stmt) : ()
                                      expr_stmt ;
                                        invoke : ()
                                          target: self.bump
                                          args:
                                            value 1 : i64
                              expr_stmt ;
                                continue : !
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
              expr_stmt (value)
                index : string
                  value:
                    select .src [unknown] : Vec<&string>
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  index:
                    range [exclusive] : _
                      start:
                        locator start : u64
                      end:
                        cast : u64 -> Expr(usize)
                          select .pos [unknown] : i64
                            object:
                              locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
          pub fn parse_number(&mut self) -> &Expr(str) : fn() -> &string : fn() -> &string
            block (3 stmts) : string
              let start
                init:
                  cast : u64 -> Expr(usize)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              expr_stmt (value)
                while : ()
                  cond:
                    unop ! : bool
                      value:
                        invoke : bool
                          target: self.is_eof
                  body:
                    block (2 stmts) : ()
                      let ch
                        init:
                          invoke : &string
                            target: self.peek
                      expr_stmt (value)
                        if : ()
                          cond:
                            invoke : bool
                              target: is_number_char
                              args:
                                locator ch : &string
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                          else:
                            block (1 stmt) : ()
                              expr_stmt ;
                                break : ()
              expr_stmt (value)
                index : string
                  value:
                    select .src [unknown] : Vec<&string>
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  index:
                    range [exclusive] : _
                      start:
                        locator start : u64
                      end:
                        cast : u64 -> Expr(usize)
                          select .pos [unknown] : i64
                            object:
                              locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
          pub fn skip_ws(&mut self) -> () : fn() -> () : fn() -> ()
            block (1 stmt) : ()
              expr_stmt (value)
                while : ()
                  cond:
                    unop ! : bool
                      value:
                        invoke : bool
                          target: self.is_eof
                  body:
                    block (2 stmts) : ()
                      let ch
                        init:
                          invoke : &string
                            target: self.peek
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop || : bool
                              lhs:
                                binop || : bool
                                  lhs:
                                    binop || : bool
                                      lhs:
                                        binop == : bool
                                          lhs:
                                            locator ch : &string
                                          rhs:
                                            value " " : &string
                                      rhs:
                                        binop == : bool
                                          lhs:
                                            locator ch : &string
                                          rhs:
                                            value "\n" : &string
                                  rhs:
                                    binop == : bool
                                      lhs:
                                        locator ch : &string
                                      rhs:
                                        value "\t" : &string
                              rhs:
                                binop == : bool
                                  lhs:
                                    locator ch : &string
                                  rhs:
                                    value "\r" : &string
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                invoke : ()
                                  target: self.bump
                                  args:
                                    value 1 : i64
                          else:
                            block (1 stmt) : ()
                              expr_stmt ;
                                break : ()
          pub fn expect_char(&mut self, ch: &Expr(str)) -> () : fn(&string) -> () : fn(&string) -> ()
            block (1 stmt) : ()
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        invoke : &string
                          target: self.peek
                      rhs:
                        locator ch : &string
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        invoke : ()
                          target: self.bump
                          args:
                            value 1 : i64
          pub fn starts_with(&self, literal: &Expr(str)) -> Expr(bool) : fn(&string) -> bool : fn(&string) -> bool
            block (7 stmts) : bool
              let pos
                init:
                  cast : u64 -> Expr(usize)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              let mut idx
                init:
                  value 0 : i64
              let literal_len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: literal.len
              let src_len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: self.src.len
              let pos_i64
                init:
                  cast : i64 -> Expr(i64)
                    locator pos : u64
              expr_stmt (value)
                while : ()
                  cond:
                    binop < : bool
                      lhs:
                        locator idx : i64
                      rhs:
                        locator literal_len : i64
                  body:
                    block (4 stmts) : ()
                      let offset
                        init:
                          cast : u64 -> Expr(usize)
                            locator idx : i64
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop >= : bool
                              lhs:
                                binop + : i64
                                  lhs:
                                    locator pos_i64 : i64
                                  rhs:
                                    locator idx : i64
                              rhs:
                                locator src_len : i64
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                return : !
                                  value false : bool
                      expr_stmt (value)
                        if : ()
                          cond:
                            binop != : bool
                              lhs:
                                index : &string
                                  value:
                                    select .src [unknown] : Vec<&string>
                                      object:
                                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                                  index:
                                    binop + : u64
                                      lhs:
                                        locator pos : u64
                                      rhs:
                                        locator offset : u64
                              rhs:
                                index : string
                                  value:
                                    locator literal : &string
                                  index:
                                    range [exclusive] : _
                                      start:
                                        locator offset : u64
                                      end:
                                        binop + : u64
                                          lhs:
                                            locator offset : u64
                                          rhs:
                                            value 1 : i64
                          then:
                            block (1 stmt) : ()
                              expr_stmt ;
                                return : !
                                  value false : bool
                      expr_stmt ;
                        assign : i64
                          target:
                            locator idx : i64
                          value:
                            binop + : i64
                              lhs:
                                locator idx : i64
                              rhs:
                                value 1 : i64
              expr_stmt (value)
                value true : bool
          pub fn peek(&self) -> &Expr(str) : fn() -> &string : fn() -> &string
            block (2 stmts) : &string
              expr_stmt (value)
                if : ()
                  cond:
                    invoke : bool
                      target: self.is_eof
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        return : !
                          value "" : &string
              expr_stmt (value)
                index : &string
                  value:
                    select .src [unknown] : Vec<&string>
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
                  index:
                    cast : u64 -> Expr(usize)
                      select .pos [unknown] : i64
                        object:
                          locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
          pub fn is_eof(&self) -> Expr(bool) : fn() -> bool : fn() -> bool
            block (3 stmts) : bool
              let pos
                init:
                  cast : i64 -> Expr(i64)
                    select .pos [unknown] : i64
                      object:
                        locator self : &Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
              let len
                init:
                  cast : i64 -> Expr(i64)
                    invoke : i64
                      target: self.src.len
              expr_stmt (value)
                binop >= : bool
                  lhs:
                    locator pos : i64
                  rhs:
                    locator len : i64
        }
        pub fn is_number_char(ch: &Expr(str)) -> Expr(bool) : fn(&string) -> bool : fn(&string) -> bool
          block (1 stmt) : bool
            expr_stmt (value)
              match : bool
                case #0
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #1
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #2
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #3
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #4
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #5
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #6
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #7
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #8
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #9
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #10
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #11
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #12
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #13
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #14
                  cond:
                    value true : _
                  body:
                    value true : bool
                case #15
                  cond:
                    value true : _
                  body:
                    value false : bool
      }
      pub module intrinsic : () {
        pub [attrs] const fn create_struct(name: &Expr(str)) -> type : fn(&string) -> type : fn(&string) -> type
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "create_struct is a compiler intrinsic" : _
                kwargs: []
        pub [attrs] const fn addfield(ty: type, name: &Expr(str), field_ty: type) -> type : fn(type, &string, type) -> type : fn(type, &string, type) -> type
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic compile_error : _
                args:
                  value "addfield is a compiler intrinsic" : _
                kwargs: []
      }
      pub module meta : () {
        pub struct TypeBuilder : TypeBuilder{ty: type} {
          ty: type
        }
        impl TypeBuilder : () {
          pub const fn new(name: &Expr(str)) -> Expr(TypeBuilder) : fn(&string) -> TypeBuilder{ty: type} : fn(&string) -> TypeBuilder{ty: type}
            block (1 stmt) : TypeBuilder{ty: type}
              expr_stmt (value)
                struct TypeBuilder : TypeBuilder{ty: type}
                  ty:
                    intrinsic create_struct : type
                      args:
                        locator name : &string
                      kwargs: []
          pub const fn from(ty: type) -> Expr(TypeBuilder) : fn(type) -> TypeBuilder{ty: type} : fn(type) -> TypeBuilder{ty: type}
            block (1 stmt) : TypeBuilder{ty: type}
              expr_stmt (value)
                struct TypeBuilder : TypeBuilder{ty: type}
                  ty:
                    locator ty : type
          pub const fn with_field(self, name: &Expr(str), field_ty: type) -> Expr(TypeBuilder) : fn(&string, type) -> TypeBuilder{ty: type} : fn(&string, type) -> TypeBuilder{ty: type}
            block (2 stmts) : TypeBuilder{ty: type}
              let ty
                init:
                  intrinsic add_field : type
                    args:
                      select .ty [unknown] : type
                        object:
                          locator self : TypeBuilder{ty: type}
                      locator name : &string
                      locator field_ty : type
                    kwargs: []
              expr_stmt (value)
                struct TypeBuilder : TypeBuilder{ty: type}
                  ty:
                    locator ty : type
          pub const fn build(self) -> type : fn() -> type : fn() -> type
            block (1 stmt) : type
              expr_stmt (value)
                select .ty [unknown] : type
                  object:
                    locator self : TypeBuilder{ty: type}
        }
      }
      pub module proc_macro : () {
        pub enum Delimiter : Delimiter [Parenthesis: () | Brace: () | Bracket: ()] {
          Parenthesis: ()
          Brace: ()
          Bracket: ()
        }
        pub struct Group : Group{delimiter: Expr(Delimiter), tokens: Vec<Expr(TokenTree)>} {
          delimiter: Expr(Delimiter)
          tokens: Vec<Expr(TokenTree)>
        }
        pub struct Ident : Ident{text: Expr(str)} {
          text: Expr(str)
        }
        pub struct Punct : Punct{text: Expr(str)} {
          text: Expr(str)
        }
        pub struct Literal : Literal{text: Expr(str)} {
          text: Expr(str)
        }
        pub enum TokenTree : TokenTree [Token: (Expr(str)) | Group: (Expr(Group))] {
          Token: (Expr(str))
          Group: (Expr(Group))
        }
        pub struct TokenStream : TokenStream {
        }
        pub const fn token_stream_from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream : fn(string) -> TokenStream
          block (1 stmt) : any
            expr_stmt (value)
              intrinsic token_stream_from_str : any
                args:
                  locator text : string
                kwargs: []
        pub const fn token_stream_to_string(stream: Expr(TokenStream)) -> Expr(str) : fn(TokenStream) -> string : fn(TokenStream) -> string
          block (1 stmt) : any
            expr_stmt (value)
              intrinsic token_stream_to_string : any
                args:
                  locator stream : TokenStream
                kwargs: []
        impl TokenStream : () {
          pub fn from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream : fn(string) -> TokenStream
            block (1 stmt) : any
              expr_stmt (value)
                intrinsic token_stream_from_str : any
                  args:
                    locator text : string
                  kwargs: []
          pub fn to_string(self) -> Expr(str) : fn() -> string : fn() -> string
            block (1 stmt) : any
              expr_stmt (value)
                intrinsic token_stream_to_string : any
                  args:
                    locator self : TokenStream
                  kwargs: []
        }
      }
      pub module test : () {
        pub struct TestCase : TestCase{name: Expr(str), run: fn() -> ()} {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<TestCase{name: Expr(str), run: fn() -> ()}> : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
          value [0 values] : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
        pub const fn test(item: Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item> : fn(Quote<item>) -> Quote<item>
          block (3 stmts) : Quote<item>
            let name
              init:
                select .name [unknown] : string
                  object:
                    locator item : Quote<item>
            expr_stmt ;
              invoke : ()
                target: REGISTRY.push
                args:
                  struct TestCase : _
                    name:
                      locator name : _
                    run:
                      select .value [unknown] : _
                        object:
                          locator item : _
            expr_stmt (value)
              locator item : Quote<item>
        pub struct TestReport : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_tests() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts) : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
            let tests: Vec<Expr(TestCase)>
              init:
                locator REGISTRY : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
            let mut passed
              init:
                value 0 : i64
            let mut failed
              init:
                value 0 : i64
            let mut idx
              init:
                value 0 : i64
            expr_stmt (value)
              while : ()
                cond:
                  binop < : bool
                    lhs:
                      locator idx : i64
                    rhs:
                      invoke : i64
                        target: tests.len
                body:
                  block (4 stmts) : ()
                    let test: Expr(TestCase)
                      init:
                        index : TestCase{name: Expr(str), run: fn() -> ()}
                          value:
                            locator tests : Vec<TestCase{name: Expr(str), run: fn() -> ()}>
                          index:
                            locator idx : i64
                    let ok
                      init:
                        intrinsic catch_unwind : bool
                          args:
                            select .run [unknown] : fn() -> ()
                              object:
                                locator test : TestCase{name: Expr(str), run: fn() -> ()}
                          kwargs: []
                    expr_stmt (value)
                      if : ()
                        cond:
                          locator ok : bool
                        then:
                          block (2 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator passed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator passed : i64
                                    rhs:
                                      value 1 : i64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... ok" : string
                                  select .name [unknown] : string
                                    object:
                                      locator test : TestCase{name: Expr(str), run: fn() -> ()}
                                kwargs: []
                        else:
                          block (2 stmts) : ()
                            expr_stmt ;
                              assign : i64
                                target:
                                  locator failed : i64
                                value:
                                  binop + : i64
                                    lhs:
                                      locator failed : i64
                                    rhs:
                                      value 1 : i64
                            expr_stmt ;
                              intrinsic println : ()
                                args:
                                  format_string "  {} ... FAILED" : string
                                  select .name [unknown] : string
                                    object:
                                      locator test : TestCase{name: Expr(str), run: fn() -> ()}
                                kwargs: []
                    expr_stmt ;
                      assign : i64
                        target:
                          locator idx : i64
                        value:
                          binop + : i64
                            lhs:
                              locator idx : i64
                            rhs:
                              value 1 : i64
            let total
              init:
                binop + : i64
                  lhs:
                    locator passed : i64
                  rhs:
                    locator failed : i64
            expr_stmt ;
              intrinsic println : ()
                args:
                  format_string "test result: {} passed; {} failed; {} total" : string
                  locator passed : i64
                  locator failed : i64
                  locator total : i64
                kwargs: []
            expr_stmt (value)
              struct TestReport : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
                total:
                  locator total : i64
                passed:
                  locator passed : i64
                failed:
                  locator failed : i64
        pub fn run() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)} : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (1 stmt) : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
            expr_stmt (value)
              invoke : TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
                target: run_tests
      }
      pub module time : () {
        pub [attrs] fn now() -> Expr(f64) : fn() -> f64 : fn() -> f64
          block (1 stmt) : _
            expr_stmt (value)
              intrinsic time_now : _
                args: []
                kwargs: []
      }
    }
    pub fn factorial(n: Expr(i64)) -> Expr(i64) : fn(i64) -> i64 : fn(i64) -> i64
      block (4 stmts) : i64
        let mut result
          init:
            value 1 : i64
        let mut i
          init:
            value 1 : i64
        expr_stmt (value)
          while : ()
            cond:
              binop <= : bool
                lhs:
                  locator i : i64
                rhs:
                  locator n : i64
            body:
              block (2 stmts) : ()
                expr_stmt ;
                  assign : i64
                    target:
                      locator result : i64
                    value:
                      binop * : i64
                        lhs:
                          locator result : i64
                        rhs:
                          locator i : i64
                expr_stmt ;
                  assign : i64
                    target:
                      locator i : i64
                    value:
                      binop + : i64
                        lhs:
                          locator i : i64
                        rhs:
                          value 1 : i64
        expr_stmt (value)
          locator result : i64
    pub const fn const_factorial(n: Expr(i64)) -> Expr(i64) : fn(i64) -> i64 : fn(i64) -> i64
      block (1 stmt) : i64
        expr_stmt (value)
          if : i64
            cond:
              binop <= : bool
                lhs:
                  locator n : i64
                rhs:
                  value 1 : i64
            then:
              block (1 stmt) : i64
                expr_stmt (value)
                  value 1 : i64
            else:
              block (1 stmt) : i64
                expr_stmt (value)
                  binop * : i64
                    lhs:
                      locator n : i64
                    rhs:
                      invoke : i64
                        target: const_factorial
                        args:
                          binop - : i64
                            lhs:
                              locator n : i64
                            rhs:
                              value 1 : i64
    pub fn sum_range(start: Expr(i64), end: Expr(i64)) -> Expr(i64) : fn(i64, i64) -> i64 : fn(i64, i64) -> i64
      block (3 stmts) : i64
        let mut sum
          init:
            value 0 : i64
        expr_stmt (value)
          for : ()
            iter:
              range [exclusive] : Vec<i64>
                start:
                  locator start : i64
                end:
                  locator end : i64
            body:
              block (1 stmt) : ()
                expr_stmt ;
                  assign : i64
                    target:
                      locator sum : i64
                    value:
                      binop + : i64
                        lhs:
                          locator sum : i64
                        rhs:
                          locator i : i64
        expr_stmt (value)
          locator sum : i64
    pub fn find_first_divisor(n: Expr(i64)) -> Expr(i64) : fn(i64) -> i64 : fn(i64) -> i64
      block (2 stmts) : i64
        let mut i
          init:
            value 2 : i64
        expr_stmt (value)
          loop : i64
            block (3 stmts) : ()
              expr_stmt (value)
                if : ()
                  cond:
                    binop > : bool
                      lhs:
                        binop * : i64
                          lhs:
                            locator i : i64
                          rhs:
                            locator i : i64
                      rhs:
                        locator n : i64
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        break : i64
                          locator n : i64
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        binop % : i64
                          lhs:
                            locator n : i64
                          rhs:
                            locator i : i64
                      rhs:
                        value 0 : i64
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        break : i64
                          locator i : i64
              expr_stmt ;
                assign : i64
                  target:
                    locator i : i64
                  value:
                    binop + : i64
                      lhs:
                        locator i : i64
                      rhs:
                        value 1 : i64
    pub fn sum_even_numbers(limit: Expr(i64)) -> Expr(i64) : fn(i64) -> i64 : fn(i64) -> i64
      block (4 stmts) : i64
        let mut sum
          init:
            value 0 : i64
        let mut i
          init:
            value 0 : i64
        expr_stmt (value)
          while : ()
            cond:
              binop < : bool
                lhs:
                  locator i : i64
                rhs:
                  locator limit : i64
            body:
              block (3 stmts) : ()
                expr_stmt ;
                  assign : i64
                    target:
                      locator i : i64
                    value:
                      binop + : i64
                        lhs:
                          locator i : i64
                        rhs:
                          value 1 : i64
                expr_stmt (value)
                  if : ()
                    cond:
                      binop != : bool
                        lhs:
                          binop % : i64
                            lhs:
                              locator i : i64
                            rhs:
                              value 2 : i64
                        rhs:
                          value 0 : i64
                    then:
                      block (1 stmt) : ()
                        expr_stmt ;
                          continue : !
                expr_stmt ;
                  assign : i64
                    target:
                      locator sum : i64
                    value:
                      binop + : i64
                        lhs:
                          locator sum : i64
                        rhs:
                          locator i : i64
        expr_stmt (value)
          locator sum : i64
    pub fn main() -> () : fn() -> () : fn() -> ()
      block (25 stmts) : ()
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string " Tutorial: 13_loops.fp" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string " Focus: Loop constructs: while, for, and loop." : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string " What to look for: labeled outputs below" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string " Expectation: outputs match labels" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "=== Loop Constructs ===\n" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "1. While loop - factorial:" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  5! = {}" : string
              invoke : i64
                target: factorial
                args:
                  value 5 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  7! = {}" : string
              invoke : i64
                target: factorial
                args:
                  value 7 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "\n2. For loop - sum range:" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  sum(1..10) = {}" : string
              invoke : i64
                target: sum_range
                args:
                  value 1 : i64
                  value 10 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  sum(5..15) = {}" : string
              invoke : i64
                target: sum_range
                args:
                  value 5 : i64
                  value 15 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "\n3. Loop with break expression:" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  First divisor of 24: {}" : string
              invoke : i64
                target: find_first_divisor
                args:
                  value 24 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  First divisor of 17: {}" : string
              invoke : i64
                target: find_first_divisor
                args:
                  value 17 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "\n4. Loop with continue:" : string
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  Sum of even numbers < 10: {}" : string
              invoke : i64
                target: sum_even_numbers
                args:
                  value 10 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "\n5. Nested loops:" : string
            kwargs: []
        let mut count
          init:
            value 0 : i64
        expr_stmt (value)
          for : ()
            iter:
              range [exclusive] : Vec<i64>
                start:
                  value 1 : i64
                end:
                  value 4 : i64
            body:
              block (1 stmt) : ()
                expr_stmt (value)
                  for : ()
                    iter:
                      range [exclusive] : Vec<i64>
                        start:
                          value 1 : i64
                        end:
                          value 4 : i64
                    body:
                      block (2 stmts) : ()
                        expr_stmt ;
                          assign : i64
                            target:
                              locator count : i64
                            value:
                              binop + : i64
                                lhs:
                                  locator count : i64
                                rhs:
                                  value 1 : i64
                        expr_stmt (value)
                          if : ()
                            cond:
                              binop == : bool
                                lhs:
                                  locator i : i64
                                rhs:
                                  locator j : i64
                            then:
                              block (1 stmt) : ()
                                expr_stmt ;
                                  intrinsic print : ()
                                    args:
                                      format_string "[{}] " : string
                                      locator i : i64
                                    kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "\n  Iterations: {}" : string
              locator count : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "\n6. Compile-time recursion:" : string
            kwargs: []
        pub const FACTORIAL_CONST: i64 : i64
          value 120 : i64
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "  const_factorial(5) = {}" : string
              value 120 : i64
            kwargs: []
        expr_stmt ;
          intrinsic println : ()
            args:
              format_string "\n Loop constructs demonstrated!" : string
            kwargs: []
}
