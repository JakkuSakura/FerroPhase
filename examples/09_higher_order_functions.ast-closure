struct __Closure0{
    pub n : i64
}
fn __closure0_call (__env : struct __Closure0{
    pub n : i64
}
, x : i64) -> i64{
    x + __env . n
}
struct __Closure1{
    pub __fp_no_capture : i8
}
fn __closure1_call (__env : struct __Closure1{
    pub __fp_no_capture : i8
}
, x : i64) -> i64{
    x * 2
}
fn printf (fmt : String , args : dyn Any) -> () ;
fn add__i64 (a : i64 , b : i64) -> i64{
    a + b
}
fn apply__i64_op_add__i64 (a : i64 , b : i64) -> (){
    printf ("%d\n" . to_string () , add__i64 (a , b)) ;
}
fn add__f64 (a : f64 , b : f64) -> f64{
    a + b
}
fn apply__f64_op_add__f64 (a : f64 , b : f64) -> (){
    printf ("%f\n" . to_string () , add__f64 (a , b)) ;
}
fn apply_if__op_add__i64 (cond : bool , a : i64 , b : i64) -> i64{
    if cond{
        add__i64 (a , b)
    }
    else 0
}
use std :: fmt :: Display ;
use std :: ops :: Add ;
fn apply < T : Add + Display > (a : T , b : T , op : fn (T , T) -> T) -> () ;
fn add < T : Add > (a : T , b : T) -> T ;
fn apply_if (cond : bool , a : i64 , b : i64 , op : fn (i64 , i64) -> i64) -> i64 ;
fn make_adder (n : i64) -> struct __Closure0{
    pub n : i64
}
{
    __Closure0{
        n : n
    }
}
fn main () -> (){
    printf ("Generic operations:\n" . to_string ()) ;
    apply__i64_op_add__i64 (10 , 20) ;
    apply__f64_op_add__f64 (1.5 , 2.5) ;
    printf ("\nConditional:\n" . to_string ()) ;
    printf ("%d\n" . to_string () , apply_if__op_add__i64 (true , 5 , 3)) ;
    printf ("%d\n" . to_string () , apply_if__op_add__i64 (false , 5 , 3)) ;
    printf ("\nClosure factory:\n" . to_string ()) ;
    const add_10 : struct __Closure0{
        pub n : i64
    }
    = make_adder (10) ;
    printf ("add_10(5) = %d\n" . to_string () , __closure0_call (add_10 , 5)) ;
    let double = __Closure1{
        __fp_no_capture : 0
    };
    printf ("double(7) = %d\n" . to_string () , __closure1_call (double , 7)) ;
}