ast::File {
  items:
    pub module std {
      pub module bench {
        pub struct BenchCase {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
          value [0 values]
        pub struct BenchReport {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_benches() -> Expr(BenchReport) : fn() -> BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts)
            let benches: Vec<Expr(BenchCase)>
              init:
                value [0 values]
            let mut passed
              init:
                value 0
            let mut failed
              init:
                value 0
            let mut idx
              init:
                value 0
            expr_stmt (value)
              while
                cond:
                  binop <
                    lhs:
                      locator idx
                    rhs:
                      invoke
                        target: benches.len
                body:
                  block (16 stmts)
                    let bench: Expr(BenchCase)
                      init:
                        index
                          value:
                            locator benches
                          index:
                            locator idx
                    let mut ok
                      init:
                        value true
                    let warmup_secs
                      init:
                        value 5
                    let measure_secs
                      init:
                        value 15
                    let warmup_start
                      init:
                        intrinsic time_now
                          args: []
                          kwargs: []
                    let warmup_deadline
                      init:
                        binop +
                          lhs:
                            locator warmup_start
                          rhs:
                            locator warmup_secs
                    let mut warmup_iters
                      init:
                        value 0
                    expr_stmt (value)
                      while
                        cond:
                          binop <
                            lhs:
                              intrinsic time_now
                                args: []
                                kwargs: []
                            rhs:
                              locator warmup_deadline
                        body:
                          block (3 stmts)
                            let warm_ok
                              init:
                                intrinsic catch_unwind
                                  args:
                                    select .run [unknown]
                                      object:
                                        locator bench
                                  kwargs: []
                            expr_stmt (value)
                              if
                                cond:
                                  unop !
                                    value:
                                      locator warm_ok
                                then:
                                  block (2 stmts)
                                    expr_stmt ;
                                      assign
                                        target:
                                          locator ok
                                        value:
                                          value false
                                    expr_stmt ;
                                      break
                            expr_stmt ;
                              assign
                                target:
                                  locator warmup_iters
                                value:
                                  binop +
                                    lhs:
                                      locator warmup_iters
                                    rhs:
                                      value 1
                    let measure_start
                      init:
                        intrinsic time_now
                          args: []
                          kwargs: []
                    let measure_deadline
                      init:
                        binop +
                          lhs:
                            locator measure_start
                          rhs:
                            locator measure_secs
                    let mut measure_iters
                      init:
                        value 0
                    expr_stmt (value)
                      if
                        cond:
                          locator ok
                        then:
                          block (1 stmt)
                            expr_stmt (value)
                              while
                                cond:
                                  binop ||
                                    lhs:
                                      binop <
                                        lhs:
                                          intrinsic time_now
                                            args: []
                                            kwargs: []
                                        rhs:
                                          locator measure_deadline
                                    rhs:
                                      binop ==
                                        lhs:
                                          locator measure_iters
                                        rhs:
                                          value 0
                                body:
                                  block (3 stmts)
                                    let run_ok
                                      init:
                                        intrinsic catch_unwind
                                          args:
                                            select .run [unknown]
                                              object:
                                                locator bench
                                          kwargs: []
                                    expr_stmt (value)
                                      if
                                        cond:
                                          unop !
                                            value:
                                              locator run_ok
                                        then:
                                          block (2 stmts)
                                            expr_stmt ;
                                              assign
                                                target:
                                                  locator ok
                                                value:
                                                  value false
                                            expr_stmt ;
                                              break
                                    expr_stmt ;
                                      assign
                                        target:
                                          locator measure_iters
                                        value:
                                          binop +
                                            lhs:
                                              locator measure_iters
                                            rhs:
                                              value 1
                    let measure_end
                      init:
                        intrinsic time_now
                          args: []
                          kwargs: []
                    let elapsed
                      init:
                        binop -
                          lhs:
                            locator measure_end
                          rhs:
                            locator measure_start
                    expr_stmt (value)
                      if
                        cond:
                          locator ok
                        then:
                          block (4 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator passed
                                value:
                                  binop +
                                    lhs:
                                      locator passed
                                    rhs:
                                      value 1
                            let iters_f
                              init:
                                cast -> Expr(f64)
                                  locator measure_iters
                            let ns_per_iter
                              init:
                                if
                                  cond:
                                    binop >
                                      lhs:
                                        locator iters_f
                                      rhs:
                                        value 0
                                  then:
                                    block (1 stmt)
                                      expr_stmt (value)
                                        binop *
                                          lhs:
                                            binop /
                                              lhs:
                                                locator elapsed
                                              rhs:
                                                locator iters_f
                                          rhs:
                                            value 1000000000
                                  else:
                                    block (1 stmt)
                                      expr_stmt (value)
                                        value 0
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... ok (iters: {}, time: {:.6}s, ns/iter: {:.2})"
                                  select .name [unknown]
                                    object:
                                      locator bench
                                  locator measure_iters
                                  locator elapsed
                                  locator ns_per_iter
                                kwargs: []
                        else:
                          block (2 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator failed
                                value:
                                  binop +
                                    lhs:
                                      locator failed
                                    rhs:
                                      value 1
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... FAILED"
                                  select .name [unknown]
                                    object:
                                      locator bench
                                kwargs: []
                    expr_stmt ;
                      assign
                        target:
                          locator idx
                        value:
                          binop +
                            lhs:
                              locator idx
                            rhs:
                              value 1
            let total
              init:
                binop +
                  lhs:
                    locator passed
                  rhs:
                    locator failed
            expr_stmt ;
              intrinsic println
                args:
                  format_string "bench result: {} passed; {} failed; {} total"
                  locator passed
                  locator failed
                  locator total
                kwargs: []
            expr_stmt (value)
              struct BenchReport
                total:
                  locator total
                passed:
                  locator passed
                failed:
                  locator failed
      }
      pub module collections {
        pub struct HashMapEntry {
          key: Expr(K)
          value: Expr(V)
        }
        pub struct HashMap {
          entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>)>
        }
        impl HashMap<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })> {
          pub fn from(entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>)>) -> Expr(HashMap<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>) : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>)>}
            block (1 stmt)
              expr_stmt (value)
                struct HashMap
                  entries:
                    locator entries
          pub fn len(&self) -> Expr(i64) : fn() -> i64
            block (1 stmt)
              expr_stmt (value)
                invoke
                  target: self.entries.len
          pub fn get_unchecked(&self, key: Expr(K)) -> Expr(V) : fn(any) -> any
            block (3 stmts)
              let mut idx
                init:
                  value 0
              expr_stmt (value)
                while
                  cond:
                    binop <
                      lhs:
                        locator idx
                      rhs:
                        invoke
                          target: self.entries.len
                  body:
                    block (3 stmts)
                      let entry
                        init:
                          index
                            value:
                              select .entries [unknown]
                                object:
                                  locator self
                            index:
                              locator idx
                      expr_stmt (value)
                        if
                          cond:
                            binop ==
                              lhs:
                                select .key [unknown]
                                  object:
                                    locator entry
                              rhs:
                                locator key
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                return
                                  select .value [unknown]
                                    object:
                                      locator entry
                      expr_stmt ;
                        assign
                          target:
                            locator idx
                          value:
                            binop +
                              lhs:
                                locator idx
                              rhs:
                                value 1
              expr_stmt (value)
                loop
                  block (0 stmts)
        }
      }
      pub module ffi {
        pub struct CStr {
        }
      }
      pub module future {
        pub fn sleep(seconds: Expr(f64)) -> Expr(std::task::Future<Unit(TypeUnit)>) : fn(f64) -> Future{handle: Expr(any)}
          block (1 stmt)
            expr_stmt (value)
              struct std::task::Future
                handle:
                  async
                    block (2 stmts)
                      expr_stmt ;
                        intrinsic sleep
                          args:
                            locator seconds
                          kwargs: []
                      expr_stmt (value)
                        value ()
      }
      pub module json {
        pub struct JsonField {
          key: &Expr(str)
          value: Expr(JsonValue)
        }
        pub enum JsonValue {
          Null: ()
          Bool: (Expr(bool))
          Number: (&Expr(str))
          String: (&Expr(str))
          Array: (Vec<Expr(JsonValue)>)
          Object: (Vec<Expr(JsonField)>)
        }
        pub fn parse(input: &Expr(str)) -> Expr(JsonValue) : fn(&string) -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
          block (2 stmts)
            let mut parser
              init:
                invoke
                  target: Parser::new
                  args:
                    locator input
            expr_stmt (value)
              invoke
                target: parser.parse_value
        pub fn print(value: Expr(JsonValue)) -> () : fn(JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt)
            expr_stmt ;
              invoke
                target: print_value
                args:
                  reference (mutable: unspecified)
                    locator value
        pub fn print_value(value: &Expr(JsonValue)) -> () : fn(&JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt)
            expr_stmt (value)
              match
                case #0
                  cond:
                    value true
                  body:
                    intrinsic print
                      args:
                        format_string "null"
                      kwargs: []
                case #1
                  cond:
                    value true
                  body:
                    block (1 stmt)
                      expr_stmt (value)
                        if
                          cond:
                            locator b
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "true"
                                  kwargs: []
                          else:
                            block (1 stmt)
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "false"
                                  kwargs: []
                case #2
                  cond:
                    value true
                  body:
                    intrinsic print
                      args:
                        format_string "{}"
                        locator n
                      kwargs: []
                case #3
                  cond:
                    value true
                  body:
                    block (3 stmts)
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "\""
                          kwargs: []
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "{}"
                            locator s
                          kwargs: []
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "\""
                          kwargs: []
                case #4
                  cond:
                    value true
                  body:
                    block (5 stmts)
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "["
                          kwargs: []
                      let mut idx
                        init:
                          value 0
                      let items_len
                        init:
                          invoke
                            target: items.len
                      expr_stmt (value)
                        while
                          cond:
                            binop <
                              lhs:
                                locator idx
                              rhs:
                                locator items_len
                          body:
                            block (4 stmts)
                              expr_stmt (value)
                                if
                                  cond:
                                    binop >
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 0
                                  then:
                                    block (1 stmt)
                                      expr_stmt ;
                                        intrinsic print
                                          args:
                                            format_string ","
                                          kwargs: []
                              let item
                                init:
                                  index
                                    value:
                                      locator items
                                    index:
                                      locator idx
                              expr_stmt ;
                                invoke
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified)
                                      locator item
                              expr_stmt ;
                                assign
                                  target:
                                    locator idx
                                  value:
                                    binop +
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 1
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "]"
                          kwargs: []
                case #5
                  cond:
                    value true
                  body:
                    block (5 stmts)
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "{"
                          kwargs: []
                      let mut idx
                        init:
                          value 0
                      let fields_len
                        init:
                          invoke
                            target: fields.len
                      expr_stmt (value)
                        while
                          cond:
                            binop <
                              lhs:
                                locator idx
                              rhs:
                                locator fields_len
                          body:
                            block (7 stmts)
                              expr_stmt (value)
                                if
                                  cond:
                                    binop >
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 0
                                  then:
                                    block (1 stmt)
                                      expr_stmt ;
                                        intrinsic print
                                          args:
                                            format_string ","
                                          kwargs: []
                              let field
                                init:
                                  index
                                    value:
                                      locator fields
                                    index:
                                      locator idx
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "\""
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "{}"
                                    select .key [unknown]
                                      object:
                                        locator field
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "\":"
                                  kwargs: []
                              expr_stmt ;
                                invoke
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified)
                                      select .value [unknown]
                                        object:
                                          locator field
                              expr_stmt ;
                                assign
                                  target:
                                    locator idx
                                  value:
                                    binop +
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 1
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "}"
                          kwargs: []
        pub struct Parser {
          src: Vec<&Expr(str)>
          pos: Expr(i64)
        }
        impl Parser {
          pub fn new(src: &Expr(str)) -> Expr(Parser) : fn(&string) -> Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
            block (5 stmts)
              let mut chars
                init:
                  value [0 values]
              let mut idx
                init:
                  value 0
              let src_len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: src.len
              expr_stmt (value)
                while
                  cond:
                    binop <
                      lhs:
                        locator idx
                      rhs:
                        locator src_len
                  body:
                    block (4 stmts)
                      let offset
                        init:
                          cast -> Expr(usize)
                            locator idx
                      let ch
                        init:
                          index
                            value:
                              locator src
                            index:
                              range [exclusive]
                                start:
                                  locator offset
                                end:
                                  binop +
                                    lhs:
                                      locator offset
                                    rhs:
                                      value 1
                      expr_stmt ;
                        invoke
                          target: chars.push
                          args:
                            locator ch
                      expr_stmt ;
                        assign
                          target:
                            locator idx
                          value:
                            binop +
                              lhs:
                                locator idx
                              rhs:
                                value 1
              expr_stmt (value)
                struct Parser
                  src:
                    locator chars
                  pos:
                    value 0
          pub fn bump(&mut self, amount: Expr(i64)) -> () : fn(i64) -> ()
            block (1 stmt)
              expr_stmt ;
                assign
                  target:
                    select .pos [unknown]
                      object:
                        locator self
                  value:
                    binop +
                      lhs:
                        select .pos [unknown]
                          object:
                            locator self
                      rhs:
                        locator amount
          pub fn parse_value(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (9 stmts)
              expr_stmt ;
                invoke
                  target: self.skip_ws
              let ch
                init:
                  invoke
                    target: self.peek
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        locator ch
                      rhs:
                        value "{"
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          invoke
                            target: self.parse_object
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        locator ch
                      rhs:
                        value "["
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          invoke
                            target: self.parse_array
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        locator ch
                      rhs:
                        value "\""
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::String
                            args:
                              invoke
                                target: self.parse_string
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.starts_with
                      args:
                        value "true"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 4
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Bool
                            args:
                              value true
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.starts_with
                      args:
                        value "false"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 5
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Bool
                            args:
                              value false
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.starts_with
                      args:
                        value "null"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 4
                      expr_stmt ;
                        return
                          locator JsonValue::Null
              expr_stmt (value)
                invoke
                  target: JsonValue::Number
                  args:
                    invoke
                      target: self.parse_number
          pub fn parse_array(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts)
              expr_stmt ;
                invoke
                  target: self.expect_char
                  args:
                    value "["
              expr_stmt ;
                invoke
                  target: self.skip_ws
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        invoke
                          target: self.peek
                      rhs:
                        value "]"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Array
                            args:
                              value [0 values]
              let mut items
                init:
                  value [0 values]
              expr_stmt (value)
                loop
                  block (6 stmts)
                    let value
                      init:
                        invoke
                          target: self.parse_value
                    expr_stmt ;
                      invoke
                        target: items.push
                        args:
                          locator value
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    let ch
                      init:
                        invoke
                          target: self.peek
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value ","
                        then:
                          block (3 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              invoke
                                target: self.skip_ws
                            expr_stmt ;
                              continue
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value "]"
                        then:
                          block (2 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              break
              expr_stmt (value)
                invoke
                  target: JsonValue::Array
                  args:
                    locator items
          pub fn parse_object(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts)
              expr_stmt ;
                invoke
                  target: self.expect_char
                  args:
                    value "{"
              expr_stmt ;
                invoke
                  target: self.skip_ws
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        invoke
                          target: self.peek
                      rhs:
                        value "}"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Object
                            args:
                              value [0 values]
              let mut fields
                init:
                  value [0 values]
              expr_stmt (value)
                loop
                  block (10 stmts)
                    let key
                      init:
                        invoke
                          target: self.parse_string
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    expr_stmt ;
                      invoke
                        target: self.expect_char
                        args:
                          value ":"
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    let value
                      init:
                        invoke
                          target: self.parse_value
                    expr_stmt ;
                      invoke
                        target: fields.push
                        args:
                          struct JsonField
                            key:
                              locator key
                            value:
                              locator value
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    let ch
                      init:
                        invoke
                          target: self.peek
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value ","
                        then:
                          block (3 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              invoke
                                target: self.skip_ws
                            expr_stmt ;
                              continue
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value "}"
                        then:
                          block (2 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              break
              expr_stmt (value)
                invoke
                  target: JsonValue::Object
                  args:
                    locator fields
          pub fn parse_string(&mut self) -> &Expr(str) : fn() -> &string
            block (4 stmts)
              expr_stmt ;
                invoke
                  target: self.expect_char
                  args:
                    value "\""
              let start
                init:
                  cast -> Expr(usize)
                    select .pos [unknown]
                      object:
                        locator self
              expr_stmt (value)
                while
                  cond:
                    unop !
                      value:
                        invoke
                          target: self.is_eof
                  body:
                    block (4 stmts)
                      let ch
                        init:
                          invoke
                            target: self.peek
                      expr_stmt (value)
                        if
                          cond:
                            binop ==
                              lhs:
                                locator ch
                              rhs:
                                value "\""
                          then:
                            block (3 stmts)
                              let value
                                init:
                                  index
                                    value:
                                      select .src [unknown]
                                        object:
                                          locator self
                                    index:
                                      range [exclusive]
                                        start:
                                          locator start
                                        end:
                                          cast -> Expr(usize)
                                            select .pos [unknown]
                                              object:
                                                locator self
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                              expr_stmt ;
                                return
                                  locator value
                      expr_stmt (value)
                        if
                          cond:
                            binop ==
                              lhs:
                                locator ch
                              rhs:
                                value "\\"
                          then:
                            block (3 stmts)
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                              expr_stmt (value)
                                if
                                  cond:
                                    unop !
                                      value:
                                        invoke
                                          target: self.is_eof
                                  then:
                                    block (1 stmt)
                                      expr_stmt ;
                                        invoke
                                          target: self.bump
                                          args:
                                            value 1
                              expr_stmt ;
                                continue
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
              expr_stmt (value)
                index
                  value:
                    select .src [unknown]
                      object:
                        locator self
                  index:
                    range [exclusive]
                      start:
                        locator start
                      end:
                        cast -> Expr(usize)
                          select .pos [unknown]
                            object:
                              locator self
          pub fn parse_number(&mut self) -> &Expr(str) : fn() -> &string
            block (3 stmts)
              let start
                init:
                  cast -> Expr(usize)
                    select .pos [unknown]
                      object:
                        locator self
              expr_stmt (value)
                while
                  cond:
                    unop !
                      value:
                        invoke
                          target: self.is_eof
                  body:
                    block (2 stmts)
                      let ch
                        init:
                          invoke
                            target: self.peek
                      expr_stmt (value)
                        if
                          cond:
                            invoke
                              target: is_number_char
                              args:
                                locator ch
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                          else:
                            block (1 stmt)
                              expr_stmt ;
                                break
              expr_stmt (value)
                index
                  value:
                    select .src [unknown]
                      object:
                        locator self
                  index:
                    range [exclusive]
                      start:
                        locator start
                      end:
                        cast -> Expr(usize)
                          select .pos [unknown]
                            object:
                              locator self
          pub fn skip_ws(&mut self) -> () : fn() -> ()
            block (1 stmt)
              expr_stmt (value)
                while
                  cond:
                    unop !
                      value:
                        invoke
                          target: self.is_eof
                  body:
                    block (2 stmts)
                      let ch
                        init:
                          invoke
                            target: self.peek
                      expr_stmt (value)
                        if
                          cond:
                            binop ||
                              lhs:
                                binop ||
                                  lhs:
                                    binop ||
                                      lhs:
                                        binop ==
                                          lhs:
                                            locator ch
                                          rhs:
                                            value " "
                                      rhs:
                                        binop ==
                                          lhs:
                                            locator ch
                                          rhs:
                                            value "\n"
                                  rhs:
                                    binop ==
                                      lhs:
                                        locator ch
                                      rhs:
                                        value "\t"
                              rhs:
                                binop ==
                                  lhs:
                                    locator ch
                                  rhs:
                                    value "\r"
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                          else:
                            block (1 stmt)
                              expr_stmt ;
                                break
          pub fn expect_char(&mut self, ch: &Expr(str)) -> () : fn(&string) -> ()
            block (1 stmt)
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        invoke
                          target: self.peek
                      rhs:
                        locator ch
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
          pub fn starts_with(&self, literal: &Expr(str)) -> Expr(bool) : fn(&string) -> bool
            block (7 stmts)
              let pos
                init:
                  cast -> Expr(usize)
                    select .pos [unknown]
                      object:
                        locator self
              let mut idx
                init:
                  value 0
              let literal_len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: literal.len
              let src_len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: self.src.len
              let pos_i64
                init:
                  cast -> Expr(i64)
                    locator pos
              expr_stmt (value)
                while
                  cond:
                    binop <
                      lhs:
                        locator idx
                      rhs:
                        locator literal_len
                  body:
                    block (4 stmts)
                      let offset
                        init:
                          cast -> Expr(usize)
                            locator idx
                      expr_stmt (value)
                        if
                          cond:
                            binop >=
                              lhs:
                                binop +
                                  lhs:
                                    locator pos_i64
                                  rhs:
                                    locator idx
                              rhs:
                                locator src_len
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                return
                                  value false
                      expr_stmt (value)
                        if
                          cond:
                            binop !=
                              lhs:
                                index
                                  value:
                                    select .src [unknown]
                                      object:
                                        locator self
                                  index:
                                    binop +
                                      lhs:
                                        locator pos
                                      rhs:
                                        locator offset
                              rhs:
                                index
                                  value:
                                    locator literal
                                  index:
                                    range [exclusive]
                                      start:
                                        locator offset
                                      end:
                                        binop +
                                          lhs:
                                            locator offset
                                          rhs:
                                            value 1
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                return
                                  value false
                      expr_stmt ;
                        assign
                          target:
                            locator idx
                          value:
                            binop +
                              lhs:
                                locator idx
                              rhs:
                                value 1
              expr_stmt (value)
                value true
          pub fn peek(&self) -> &Expr(str) : fn() -> &string
            block (2 stmts)
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.is_eof
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          value ""
              expr_stmt (value)
                index
                  value:
                    select .src [unknown]
                      object:
                        locator self
                  index:
                    cast -> Expr(usize)
                      select .pos [unknown]
                        object:
                          locator self
          pub fn is_eof(&self) -> Expr(bool) : fn() -> bool
            block (3 stmts)
              let pos
                init:
                  cast -> Expr(i64)
                    select .pos [unknown]
                      object:
                        locator self
              let len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: self.src.len
              expr_stmt (value)
                binop >=
                  lhs:
                    locator pos
                  rhs:
                    locator len
        }
        pub fn is_number_char(ch: &Expr(str)) -> Expr(bool) : fn(&string) -> bool
          block (1 stmt)
            expr_stmt (value)
              match
                case #0
                  cond:
                    value true
                  body:
                    value true
                case #1
                  cond:
                    value true
                  body:
                    value true
                case #2
                  cond:
                    value true
                  body:
                    value true
                case #3
                  cond:
                    value true
                  body:
                    value true
                case #4
                  cond:
                    value true
                  body:
                    value true
                case #5
                  cond:
                    value true
                  body:
                    value true
                case #6
                  cond:
                    value true
                  body:
                    value true
                case #7
                  cond:
                    value true
                  body:
                    value true
                case #8
                  cond:
                    value true
                  body:
                    value true
                case #9
                  cond:
                    value true
                  body:
                    value true
                case #10
                  cond:
                    value true
                  body:
                    value true
                case #11
                  cond:
                    value true
                  body:
                    value true
                case #12
                  cond:
                    value true
                  body:
                    value true
                case #13
                  cond:
                    value true
                  body:
                    value true
                case #14
                  cond:
                    value true
                  body:
                    value true
                case #15
                  cond:
                    value true
                  body:
                    value false
      }
      pub module intrinsics {
        pub [attrs] const fn create_struct(name: &Expr(str)) -> type : fn(&string) -> type
          block (1 stmt)
            expr_stmt (value)
              intrinsic compile_error
                args:
                  value "create_struct is a compiler intrinsic"
                kwargs: []
        pub [attrs] const fn addfield(ty: type, name: &Expr(str), field_ty: type) -> type : fn(type, &string, type) -> type
          block (1 stmt)
            expr_stmt (value)
              intrinsic compile_error
                args:
                  value "addfield is a compiler intrinsic"
                kwargs: []
      }
      pub module meta {
        pub struct TypeBuilder {
          ty: type
        }
        impl TypeBuilder {
          pub const fn new(name: &Expr(str)) -> Expr(TypeBuilder) : fn(&string) -> TypeBuilder{ty: type}
            block (1 stmt)
              expr_stmt (value)
                struct TypeBuilder
                  ty:
                    intrinsic create_struct
                      args:
                        locator name
                      kwargs: []
          pub const fn from(ty: type) -> Expr(TypeBuilder) : fn(type) -> TypeBuilder{ty: type}
            block (1 stmt)
              expr_stmt (value)
                struct TypeBuilder
                  ty:
                    locator ty
          pub const fn with_field(self, name: &Expr(str), field_ty: type) -> Expr(TypeBuilder) : fn(&string, type) -> TypeBuilder{ty: type}
            block (2 stmts)
              let ty
                init:
                  intrinsic add_field
                    args:
                      select .ty [unknown]
                        object:
                          locator self
                      locator name
                      locator field_ty
                    kwargs: []
              expr_stmt (value)
                struct TypeBuilder
                  ty:
                    locator ty
          pub const fn build(self) -> type : fn() -> type
            block (1 stmt)
              expr_stmt (value)
                select .ty [unknown]
                  object:
                    locator self
        }
      }
      pub module net {
        pub module addr {
          pub struct SocketAddr {
          }
        }
        pub module tcp {
          pub import std::net::addr::SocketAddr
          pub struct TcpStream {
          }
          impl TcpStream {
            pub fn connect(addr: Expr(SocketAddr)) -> Expr(TcpStream) : fn(SocketAddr) -> TcpStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn shutdown(&mut self) -> () : fn() -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct TcpListener {
          }
          impl TcpListener {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(TcpListener) : fn(SocketAddr) -> TcpListener
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn accept(&mut self) -> Expr(TcpStream) : fn() -> TcpStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
        pub module udp {
          pub import std::net::addr::SocketAddr
          pub struct UdpSocket {
          }
          impl UdpSocket {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(UdpSocket) : fn(SocketAddr) -> UdpSocket
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn send_to(&mut self, buf: &[Expr(u8)], addr: Expr(SocketAddr)) -> Expr(i64) : fn(&[u8], SocketAddr) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn recv_from(&mut self, buf: &mut [Expr(u8)]) -> (Expr(i64), Expr(SocketAddr)) : fn(&[u8]) -> (i64, SocketAddr)
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
        pub module tls {
          pub import std::net::tcp::TcpStream
          pub struct TlsConnector {
          }
          impl TlsConnector {
            pub fn connect(&self, domain: &Expr(str), stream: Expr(TcpStream)) -> Expr(TlsStream) : fn(&string, TcpStream) -> TlsStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct TlsAcceptor {
          }
          impl TlsAcceptor {
            pub fn accept(&self, stream: Expr(TcpStream)) -> Expr(TlsStream) : fn(TcpStream) -> TlsStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct TlsStream {
          }
          impl TlsStream {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn shutdown(&mut self) -> () : fn() -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
        pub module http {
          pub struct HttpClient {
          }
          impl HttpClient {
            pub fn send(&self, request: Expr(HttpRequest)) -> Expr(HttpResponse) : fn(HttpRequest) -> HttpResponse
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct HttpRequest {
          }
          impl HttpRequest {
            pub fn get(url: &Expr(str)) -> Expr(HttpRequest) : fn(&string) -> HttpRequest
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
            pub fn post(url: &Expr(str), body: &[Expr(u8)]) -> Expr(HttpRequest) : fn(&string, &[u8]) -> HttpRequest
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
          }
          pub struct HttpResponse {
          }
          impl HttpResponse {
            pub fn status(&self) -> Expr(i64) : fn() -> i64
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
            pub fn body(&self) -> &[Expr(u8)] : fn() -> &[u8]
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
          }
        }
        pub module ws {
          pub struct WsStream {
          }
          impl WsStream {
            pub fn connect(url: &Expr(str)) -> Expr(WsStream) : fn(&string) -> WsStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn send(&mut self, message: Expr(WsMessage)) -> () : fn(WsMessage) -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn recv(&mut self) -> Expr(WsMessage) : fn() -> WsMessage
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct WsMessage {
          }
          impl WsMessage {
            pub fn text(value: &Expr(str)) -> Expr(WsMessage) : fn(&string) -> WsMessage
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
            pub fn binary(value: &[Expr(u8)]) -> Expr(WsMessage) : fn(&[u8]) -> WsMessage
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
          }
        }
        pub module quic {
          pub import std::net::addr::SocketAddr
          pub struct QuicConnection {
          }
          impl QuicConnection {
            pub fn connect(addr: Expr(SocketAddr), server_name: &Expr(str)) -> Expr(QuicConnection) : fn(SocketAddr, &string) -> QuicConnection
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn open_bi(&mut self) -> Expr(QuicStream) : fn() -> QuicStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct QuicListener {
          }
          impl QuicListener {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(QuicListener) : fn(SocketAddr) -> QuicListener
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn accept(&mut self) -> Expr(QuicConnection) : fn() -> QuicConnection
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct QuicStream {
          }
          impl QuicStream {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn finish(&mut self) -> () : fn() -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
      }
      pub module proc_macro {
        pub enum Delimiter {
          Parenthesis: ()
          Brace: ()
          Bracket: ()
        }
        pub struct Group {
          delimiter: Expr(Delimiter)
          tokens: Vec<Expr(TokenTree)>
        }
        pub struct Ident {
          text: Expr(str)
        }
        pub struct Punct {
          text: Expr(str)
        }
        pub struct Literal {
          text: Expr(str)
        }
        pub enum TokenTree {
          Token: (Expr(str))
          Group: (Expr(Group))
        }
        pub struct TokenStream {
        }
        pub const fn token_stream_from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream
          block (1 stmt)
            expr_stmt (value)
              intrinsic token_stream_from_str
                args:
                  locator text
                kwargs: []
        pub const fn token_stream_to_string(stream: Expr(TokenStream)) -> Expr(str) : fn(TokenStream) -> string
          block (1 stmt)
            expr_stmt (value)
              intrinsic token_stream_to_string
                args:
                  locator stream
                kwargs: []
        impl TokenStream {
          pub fn from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream
            block (1 stmt)
              expr_stmt (value)
                intrinsic token_stream_from_str
                  args:
                    locator text
                  kwargs: []
          pub fn to_string(self) -> Expr(str) : fn() -> string
            block (1 stmt)
              expr_stmt (value)
                intrinsic token_stream_to_string
                  args:
                    locator self
                  kwargs: []
        }
      }
      pub module task {
        pub struct Future {
          handle: Expr(any)
        }
        pub struct Task {
          handle: Expr(any)
        }
        pub fn<T> spawn(fut: Expr(any)) -> Expr(Task<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "T" })) })>) : fn<T>(any) -> Task{handle: Expr(any)}
          block (1 stmt)
            expr_stmt (value)
              struct Task
                handle:
                  intrinsic spawn
                    args:
                      locator fut
                    kwargs: []
        expr_item
          value ()
        expr_item
          value ()
      }
      pub module test {
        pub struct TestCase {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<TestCase{name: Expr(str), run: fn() -> ()}>
          value [0 values]
        pub struct TestReport {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_tests() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts)
            let tests: Vec<Expr(TestCase)>
              init:
                value [0 values]
            let mut passed
              init:
                value 0
            let mut failed
              init:
                value 0
            let mut idx
              init:
                value 0
            expr_stmt (value)
              while
                cond:
                  binop <
                    lhs:
                      locator idx
                    rhs:
                      invoke
                        target: tests.len
                body:
                  block (4 stmts)
                    let test: Expr(TestCase)
                      init:
                        index
                          value:
                            locator tests
                          index:
                            locator idx
                    let ok
                      init:
                        intrinsic catch_unwind
                          args:
                            select .run [unknown]
                              object:
                                locator test
                          kwargs: []
                    expr_stmt (value)
                      if
                        cond:
                          locator ok
                        then:
                          block (2 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator passed
                                value:
                                  binop +
                                    lhs:
                                      locator passed
                                    rhs:
                                      value 1
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... ok"
                                  select .name [unknown]
                                    object:
                                      locator test
                                kwargs: []
                        else:
                          block (2 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator failed
                                value:
                                  binop +
                                    lhs:
                                      locator failed
                                    rhs:
                                      value 1
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... FAILED"
                                  select .name [unknown]
                                    object:
                                      locator test
                                kwargs: []
                    expr_stmt ;
                      assign
                        target:
                          locator idx
                        value:
                          binop +
                            lhs:
                              locator idx
                            rhs:
                              value 1
            let total
              init:
                binop +
                  lhs:
                    locator passed
                  rhs:
                    locator failed
            expr_stmt ;
              intrinsic println
                args:
                  format_string "test result: {} passed; {} failed; {} total"
                  locator passed
                  locator failed
                  locator total
                kwargs: []
            expr_stmt (value)
              struct TestReport
                total:
                  locator total
                passed:
                  locator passed
                failed:
                  locator failed
        pub fn run() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (1 stmt)
            expr_stmt (value)
              invoke
                target: run_tests
      }
      pub module time {
        pub [attrs] fn now() -> Expr(f64) : fn() -> f64
          block (1 stmt)
            expr_stmt (value)
              intrinsic time_now
                args: []
                kwargs: []
        pub fn sleep(seconds: Expr(f64)) -> () : fn(f64) -> ()
          block (1 stmt)
            expr_stmt (value)
              intrinsic sleep
                args:
                  locator seconds
                kwargs: []
      }
      pub module bench {
        pub struct BenchCase {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<BenchCase{name: Expr(str), run: fn() -> ()}>
          value [0 values]
        pub struct BenchReport {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_benches() -> Expr(BenchReport) : fn() -> BenchReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts)
            let benches: Vec<Expr(BenchCase)>
              init:
                value [0 values]
            let mut passed
              init:
                value 0
            let mut failed
              init:
                value 0
            let mut idx
              init:
                value 0
            expr_stmt (value)
              while
                cond:
                  binop <
                    lhs:
                      locator idx
                    rhs:
                      invoke
                        target: benches.len
                body:
                  block (16 stmts)
                    let bench: Expr(BenchCase)
                      init:
                        index
                          value:
                            locator benches
                          index:
                            locator idx
                    let mut ok
                      init:
                        value true
                    let warmup_secs
                      init:
                        value 5
                    let measure_secs
                      init:
                        value 15
                    let warmup_start
                      init:
                        intrinsic time_now
                          args: []
                          kwargs: []
                    let warmup_deadline
                      init:
                        binop +
                          lhs:
                            locator warmup_start
                          rhs:
                            locator warmup_secs
                    let mut warmup_iters
                      init:
                        value 0
                    expr_stmt (value)
                      while
                        cond:
                          binop <
                            lhs:
                              intrinsic time_now
                                args: []
                                kwargs: []
                            rhs:
                              locator warmup_deadline
                        body:
                          block (3 stmts)
                            let warm_ok
                              init:
                                intrinsic catch_unwind
                                  args:
                                    select .run [unknown]
                                      object:
                                        locator bench
                                  kwargs: []
                            expr_stmt (value)
                              if
                                cond:
                                  unop !
                                    value:
                                      locator warm_ok
                                then:
                                  block (2 stmts)
                                    expr_stmt ;
                                      assign
                                        target:
                                          locator ok
                                        value:
                                          value false
                                    expr_stmt ;
                                      break
                            expr_stmt ;
                              assign
                                target:
                                  locator warmup_iters
                                value:
                                  binop +
                                    lhs:
                                      locator warmup_iters
                                    rhs:
                                      value 1
                    let measure_start
                      init:
                        intrinsic time_now
                          args: []
                          kwargs: []
                    let measure_deadline
                      init:
                        binop +
                          lhs:
                            locator measure_start
                          rhs:
                            locator measure_secs
                    let mut measure_iters
                      init:
                        value 0
                    expr_stmt (value)
                      if
                        cond:
                          locator ok
                        then:
                          block (1 stmt)
                            expr_stmt (value)
                              while
                                cond:
                                  binop ||
                                    lhs:
                                      binop <
                                        lhs:
                                          intrinsic time_now
                                            args: []
                                            kwargs: []
                                        rhs:
                                          locator measure_deadline
                                    rhs:
                                      binop ==
                                        lhs:
                                          locator measure_iters
                                        rhs:
                                          value 0
                                body:
                                  block (3 stmts)
                                    let run_ok
                                      init:
                                        intrinsic catch_unwind
                                          args:
                                            select .run [unknown]
                                              object:
                                                locator bench
                                          kwargs: []
                                    expr_stmt (value)
                                      if
                                        cond:
                                          unop !
                                            value:
                                              locator run_ok
                                        then:
                                          block (2 stmts)
                                            expr_stmt ;
                                              assign
                                                target:
                                                  locator ok
                                                value:
                                                  value false
                                            expr_stmt ;
                                              break
                                    expr_stmt ;
                                      assign
                                        target:
                                          locator measure_iters
                                        value:
                                          binop +
                                            lhs:
                                              locator measure_iters
                                            rhs:
                                              value 1
                    let measure_end
                      init:
                        intrinsic time_now
                          args: []
                          kwargs: []
                    let elapsed
                      init:
                        binop -
                          lhs:
                            locator measure_end
                          rhs:
                            locator measure_start
                    expr_stmt (value)
                      if
                        cond:
                          locator ok
                        then:
                          block (4 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator passed
                                value:
                                  binop +
                                    lhs:
                                      locator passed
                                    rhs:
                                      value 1
                            let iters_f
                              init:
                                cast -> Expr(f64)
                                  locator measure_iters
                            let ns_per_iter
                              init:
                                if
                                  cond:
                                    binop >
                                      lhs:
                                        locator iters_f
                                      rhs:
                                        value 0
                                  then:
                                    block (1 stmt)
                                      expr_stmt (value)
                                        binop *
                                          lhs:
                                            binop /
                                              lhs:
                                                locator elapsed
                                              rhs:
                                                locator iters_f
                                          rhs:
                                            value 1000000000
                                  else:
                                    block (1 stmt)
                                      expr_stmt (value)
                                        value 0
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... ok (iters: {}, time: {:.6}s, ns/iter: {:.2})"
                                  select .name [unknown]
                                    object:
                                      locator bench
                                  locator measure_iters
                                  locator elapsed
                                  locator ns_per_iter
                                kwargs: []
                        else:
                          block (2 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator failed
                                value:
                                  binop +
                                    lhs:
                                      locator failed
                                    rhs:
                                      value 1
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... FAILED"
                                  select .name [unknown]
                                    object:
                                      locator bench
                                kwargs: []
                    expr_stmt ;
                      assign
                        target:
                          locator idx
                        value:
                          binop +
                            lhs:
                              locator idx
                            rhs:
                              value 1
            let total
              init:
                binop +
                  lhs:
                    locator passed
                  rhs:
                    locator failed
            expr_stmt ;
              intrinsic println
                args:
                  format_string "bench result: {} passed; {} failed; {} total"
                  locator passed
                  locator failed
                  locator total
                kwargs: []
            expr_stmt (value)
              struct BenchReport
                total:
                  locator total
                passed:
                  locator passed
                failed:
                  locator failed
      }
      pub module collections {
        pub struct HashMapEntry {
          key: Expr(K)
          value: Expr(V)
        }
        pub struct HashMap {
          entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>)>
        }
        impl HashMap<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })> {
          pub fn from(entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>)>) -> Expr(HashMap<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>) : fn(Vec<HashMapEntry{key: Expr(K), value: Expr(V)}>) -> HashMap{entries: Vec<Expr(HashMapEntry<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "K" })) }), Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "V" })) })>)>}
            block (1 stmt)
              expr_stmt (value)
                struct HashMap
                  entries:
                    locator entries
          pub fn len(&self) -> Expr(i64) : fn() -> i64
            block (1 stmt)
              expr_stmt (value)
                invoke
                  target: self.entries.len
          pub fn get_unchecked(&self, key: Expr(K)) -> Expr(V) : fn(any) -> any
            block (3 stmts)
              let mut idx
                init:
                  value 0
              expr_stmt (value)
                while
                  cond:
                    binop <
                      lhs:
                        locator idx
                      rhs:
                        invoke
                          target: self.entries.len
                  body:
                    block (3 stmts)
                      let entry
                        init:
                          index
                            value:
                              select .entries [unknown]
                                object:
                                  locator self
                            index:
                              locator idx
                      expr_stmt (value)
                        if
                          cond:
                            binop ==
                              lhs:
                                select .key [unknown]
                                  object:
                                    locator entry
                              rhs:
                                locator key
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                return
                                  select .value [unknown]
                                    object:
                                      locator entry
                      expr_stmt ;
                        assign
                          target:
                            locator idx
                          value:
                            binop +
                              lhs:
                                locator idx
                              rhs:
                                value 1
              expr_stmt (value)
                loop
                  block (0 stmts)
        }
      }
      pub module ffi {
        pub struct CStr {
        }
      }
      pub module future {
        pub fn sleep(seconds: Expr(f64)) -> Expr(std::task::Future<Unit(TypeUnit)>) : fn(f64) -> Future{handle: Expr(any)}
          block (1 stmt)
            expr_stmt (value)
              struct std::task::Future
                handle:
                  async
                    block (2 stmts)
                      expr_stmt ;
                        intrinsic sleep
                          args:
                            locator seconds
                          kwargs: []
                      expr_stmt (value)
                        value ()
      }
      pub module json {
        pub struct JsonField {
          key: &Expr(str)
          value: Expr(JsonValue)
        }
        pub enum JsonValue {
          Null: ()
          Bool: (Expr(bool))
          Number: (&Expr(str))
          String: (&Expr(str))
          Array: (Vec<Expr(JsonValue)>)
          Object: (Vec<Expr(JsonField)>)
        }
        pub fn parse(input: &Expr(str)) -> Expr(JsonValue) : fn(&string) -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
          block (2 stmts)
            let mut parser
              init:
                invoke
                  target: Parser::new
                  args:
                    locator input
            expr_stmt (value)
              invoke
                target: parser.parse_value
        pub fn print(value: Expr(JsonValue)) -> () : fn(JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt)
            expr_stmt ;
              invoke
                target: print_value
                args:
                  reference (mutable: unspecified)
                    locator value
        pub fn print_value(value: &Expr(JsonValue)) -> () : fn(&JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]) -> ()
          block (1 stmt)
            expr_stmt (value)
              match
                case #0
                  cond:
                    value true
                  body:
                    intrinsic print
                      args:
                        format_string "null"
                      kwargs: []
                case #1
                  cond:
                    value true
                  body:
                    block (1 stmt)
                      expr_stmt (value)
                        if
                          cond:
                            locator b
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "true"
                                  kwargs: []
                          else:
                            block (1 stmt)
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "false"
                                  kwargs: []
                case #2
                  cond:
                    value true
                  body:
                    intrinsic print
                      args:
                        format_string "{}"
                        locator n
                      kwargs: []
                case #3
                  cond:
                    value true
                  body:
                    block (3 stmts)
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "\""
                          kwargs: []
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "{}"
                            locator s
                          kwargs: []
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "\""
                          kwargs: []
                case #4
                  cond:
                    value true
                  body:
                    block (5 stmts)
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "["
                          kwargs: []
                      let mut idx
                        init:
                          value 0
                      let items_len
                        init:
                          invoke
                            target: items.len
                      expr_stmt (value)
                        while
                          cond:
                            binop <
                              lhs:
                                locator idx
                              rhs:
                                locator items_len
                          body:
                            block (4 stmts)
                              expr_stmt (value)
                                if
                                  cond:
                                    binop >
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 0
                                  then:
                                    block (1 stmt)
                                      expr_stmt ;
                                        intrinsic print
                                          args:
                                            format_string ","
                                          kwargs: []
                              let item
                                init:
                                  index
                                    value:
                                      locator items
                                    index:
                                      locator idx
                              expr_stmt ;
                                invoke
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified)
                                      locator item
                              expr_stmt ;
                                assign
                                  target:
                                    locator idx
                                  value:
                                    binop +
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 1
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "]"
                          kwargs: []
                case #5
                  cond:
                    value true
                  body:
                    block (5 stmts)
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "{"
                          kwargs: []
                      let mut idx
                        init:
                          value 0
                      let fields_len
                        init:
                          invoke
                            target: fields.len
                      expr_stmt (value)
                        while
                          cond:
                            binop <
                              lhs:
                                locator idx
                              rhs:
                                locator fields_len
                          body:
                            block (7 stmts)
                              expr_stmt (value)
                                if
                                  cond:
                                    binop >
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 0
                                  then:
                                    block (1 stmt)
                                      expr_stmt ;
                                        intrinsic print
                                          args:
                                            format_string ","
                                          kwargs: []
                              let field
                                init:
                                  index
                                    value:
                                      locator fields
                                    index:
                                      locator idx
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "\""
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "{}"
                                    select .key [unknown]
                                      object:
                                        locator field
                                  kwargs: []
                              expr_stmt ;
                                intrinsic print
                                  args:
                                    format_string "\":"
                                  kwargs: []
                              expr_stmt ;
                                invoke
                                  target: print_value
                                  args:
                                    reference (mutable: unspecified)
                                      select .value [unknown]
                                        object:
                                          locator field
                              expr_stmt ;
                                assign
                                  target:
                                    locator idx
                                  value:
                                    binop +
                                      lhs:
                                        locator idx
                                      rhs:
                                        value 1
                      expr_stmt ;
                        intrinsic print
                          args:
                            format_string "}"
                          kwargs: []
        pub struct Parser {
          src: Vec<&Expr(str)>
          pos: Expr(i64)
        }
        impl Parser {
          pub fn new(src: &Expr(str)) -> Expr(Parser) : fn(&string) -> Parser{src: Vec<&Expr(str)>, pos: Expr(i64)}
            block (5 stmts)
              let mut chars
                init:
                  value [0 values]
              let mut idx
                init:
                  value 0
              let src_len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: src.len
              expr_stmt (value)
                while
                  cond:
                    binop <
                      lhs:
                        locator idx
                      rhs:
                        locator src_len
                  body:
                    block (4 stmts)
                      let offset
                        init:
                          cast -> Expr(usize)
                            locator idx
                      let ch
                        init:
                          index
                            value:
                              locator src
                            index:
                              range [exclusive]
                                start:
                                  locator offset
                                end:
                                  binop +
                                    lhs:
                                      locator offset
                                    rhs:
                                      value 1
                      expr_stmt ;
                        invoke
                          target: chars.push
                          args:
                            locator ch
                      expr_stmt ;
                        assign
                          target:
                            locator idx
                          value:
                            binop +
                              lhs:
                                locator idx
                              rhs:
                                value 1
              expr_stmt (value)
                struct Parser
                  src:
                    locator chars
                  pos:
                    value 0
          pub fn bump(&mut self, amount: Expr(i64)) -> () : fn(i64) -> ()
            block (1 stmt)
              expr_stmt ;
                assign
                  target:
                    select .pos [unknown]
                      object:
                        locator self
                  value:
                    binop +
                      lhs:
                        select .pos [unknown]
                          object:
                            locator self
                      rhs:
                        locator amount
          pub fn parse_value(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (9 stmts)
              expr_stmt ;
                invoke
                  target: self.skip_ws
              let ch
                init:
                  invoke
                    target: self.peek
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        locator ch
                      rhs:
                        value "{"
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          invoke
                            target: self.parse_object
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        locator ch
                      rhs:
                        value "["
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          invoke
                            target: self.parse_array
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        locator ch
                      rhs:
                        value "\""
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::String
                            args:
                              invoke
                                target: self.parse_string
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.starts_with
                      args:
                        value "true"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 4
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Bool
                            args:
                              value true
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.starts_with
                      args:
                        value "false"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 5
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Bool
                            args:
                              value false
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.starts_with
                      args:
                        value "null"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 4
                      expr_stmt ;
                        return
                          locator JsonValue::Null
              expr_stmt (value)
                invoke
                  target: JsonValue::Number
                  args:
                    invoke
                      target: self.parse_number
          pub fn parse_array(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts)
              expr_stmt ;
                invoke
                  target: self.expect_char
                  args:
                    value "["
              expr_stmt ;
                invoke
                  target: self.skip_ws
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        invoke
                          target: self.peek
                      rhs:
                        value "]"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Array
                            args:
                              value [0 values]
              let mut items
                init:
                  value [0 values]
              expr_stmt (value)
                loop
                  block (6 stmts)
                    let value
                      init:
                        invoke
                          target: self.parse_value
                    expr_stmt ;
                      invoke
                        target: items.push
                        args:
                          locator value
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    let ch
                      init:
                        invoke
                          target: self.peek
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value ","
                        then:
                          block (3 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              invoke
                                target: self.skip_ws
                            expr_stmt ;
                              continue
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value "]"
                        then:
                          block (2 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              break
              expr_stmt (value)
                invoke
                  target: JsonValue::Array
                  args:
                    locator items
          pub fn parse_object(&mut self) -> Expr(JsonValue) : fn() -> JsonValue [Null: () | Bool: (Expr(bool)) | Number: (&Expr(str)) | String: (&Expr(str)) | Array: (Vec<Expr(JsonValue)>) | Object: (Vec<Expr(JsonField)>)]
            block (6 stmts)
              expr_stmt ;
                invoke
                  target: self.expect_char
                  args:
                    value "{"
              expr_stmt ;
                invoke
                  target: self.skip_ws
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        invoke
                          target: self.peek
                      rhs:
                        value "}"
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
                      expr_stmt ;
                        return
                          invoke
                            target: JsonValue::Object
                            args:
                              value [0 values]
              let mut fields
                init:
                  value [0 values]
              expr_stmt (value)
                loop
                  block (10 stmts)
                    let key
                      init:
                        invoke
                          target: self.parse_string
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    expr_stmt ;
                      invoke
                        target: self.expect_char
                        args:
                          value ":"
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    let value
                      init:
                        invoke
                          target: self.parse_value
                    expr_stmt ;
                      invoke
                        target: fields.push
                        args:
                          struct JsonField
                            key:
                              locator key
                            value:
                              locator value
                    expr_stmt ;
                      invoke
                        target: self.skip_ws
                    let ch
                      init:
                        invoke
                          target: self.peek
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value ","
                        then:
                          block (3 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              invoke
                                target: self.skip_ws
                            expr_stmt ;
                              continue
                    expr_stmt (value)
                      if
                        cond:
                          binop ==
                            lhs:
                              locator ch
                            rhs:
                              value "}"
                        then:
                          block (2 stmts)
                            expr_stmt ;
                              invoke
                                target: self.bump
                                args:
                                  value 1
                            expr_stmt ;
                              break
              expr_stmt (value)
                invoke
                  target: JsonValue::Object
                  args:
                    locator fields
          pub fn parse_string(&mut self) -> &Expr(str) : fn() -> &string
            block (4 stmts)
              expr_stmt ;
                invoke
                  target: self.expect_char
                  args:
                    value "\""
              let start
                init:
                  cast -> Expr(usize)
                    select .pos [unknown]
                      object:
                        locator self
              expr_stmt (value)
                while
                  cond:
                    unop !
                      value:
                        invoke
                          target: self.is_eof
                  body:
                    block (4 stmts)
                      let ch
                        init:
                          invoke
                            target: self.peek
                      expr_stmt (value)
                        if
                          cond:
                            binop ==
                              lhs:
                                locator ch
                              rhs:
                                value "\""
                          then:
                            block (3 stmts)
                              let value
                                init:
                                  index
                                    value:
                                      select .src [unknown]
                                        object:
                                          locator self
                                    index:
                                      range [exclusive]
                                        start:
                                          locator start
                                        end:
                                          cast -> Expr(usize)
                                            select .pos [unknown]
                                              object:
                                                locator self
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                              expr_stmt ;
                                return
                                  locator value
                      expr_stmt (value)
                        if
                          cond:
                            binop ==
                              lhs:
                                locator ch
                              rhs:
                                value "\\"
                          then:
                            block (3 stmts)
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                              expr_stmt (value)
                                if
                                  cond:
                                    unop !
                                      value:
                                        invoke
                                          target: self.is_eof
                                  then:
                                    block (1 stmt)
                                      expr_stmt ;
                                        invoke
                                          target: self.bump
                                          args:
                                            value 1
                              expr_stmt ;
                                continue
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
              expr_stmt (value)
                index
                  value:
                    select .src [unknown]
                      object:
                        locator self
                  index:
                    range [exclusive]
                      start:
                        locator start
                      end:
                        cast -> Expr(usize)
                          select .pos [unknown]
                            object:
                              locator self
          pub fn parse_number(&mut self) -> &Expr(str) : fn() -> &string
            block (3 stmts)
              let start
                init:
                  cast -> Expr(usize)
                    select .pos [unknown]
                      object:
                        locator self
              expr_stmt (value)
                while
                  cond:
                    unop !
                      value:
                        invoke
                          target: self.is_eof
                  body:
                    block (2 stmts)
                      let ch
                        init:
                          invoke
                            target: self.peek
                      expr_stmt (value)
                        if
                          cond:
                            invoke
                              target: is_number_char
                              args:
                                locator ch
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                          else:
                            block (1 stmt)
                              expr_stmt ;
                                break
              expr_stmt (value)
                index
                  value:
                    select .src [unknown]
                      object:
                        locator self
                  index:
                    range [exclusive]
                      start:
                        locator start
                      end:
                        cast -> Expr(usize)
                          select .pos [unknown]
                            object:
                              locator self
          pub fn skip_ws(&mut self) -> () : fn() -> ()
            block (1 stmt)
              expr_stmt (value)
                while
                  cond:
                    unop !
                      value:
                        invoke
                          target: self.is_eof
                  body:
                    block (2 stmts)
                      let ch
                        init:
                          invoke
                            target: self.peek
                      expr_stmt (value)
                        if
                          cond:
                            binop ||
                              lhs:
                                binop ||
                                  lhs:
                                    binop ||
                                      lhs:
                                        binop ==
                                          lhs:
                                            locator ch
                                          rhs:
                                            value " "
                                      rhs:
                                        binop ==
                                          lhs:
                                            locator ch
                                          rhs:
                                            value "\n"
                                  rhs:
                                    binop ==
                                      lhs:
                                        locator ch
                                      rhs:
                                        value "\t"
                              rhs:
                                binop ==
                                  lhs:
                                    locator ch
                                  rhs:
                                    value "\r"
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                invoke
                                  target: self.bump
                                  args:
                                    value 1
                          else:
                            block (1 stmt)
                              expr_stmt ;
                                break
          pub fn expect_char(&mut self, ch: &Expr(str)) -> () : fn(&string) -> ()
            block (1 stmt)
              expr_stmt (value)
                if
                  cond:
                    binop ==
                      lhs:
                        invoke
                          target: self.peek
                      rhs:
                        locator ch
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        invoke
                          target: self.bump
                          args:
                            value 1
          pub fn starts_with(&self, literal: &Expr(str)) -> Expr(bool) : fn(&string) -> bool
            block (7 stmts)
              let pos
                init:
                  cast -> Expr(usize)
                    select .pos [unknown]
                      object:
                        locator self
              let mut idx
                init:
                  value 0
              let literal_len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: literal.len
              let src_len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: self.src.len
              let pos_i64
                init:
                  cast -> Expr(i64)
                    locator pos
              expr_stmt (value)
                while
                  cond:
                    binop <
                      lhs:
                        locator idx
                      rhs:
                        locator literal_len
                  body:
                    block (4 stmts)
                      let offset
                        init:
                          cast -> Expr(usize)
                            locator idx
                      expr_stmt (value)
                        if
                          cond:
                            binop >=
                              lhs:
                                binop +
                                  lhs:
                                    locator pos_i64
                                  rhs:
                                    locator idx
                              rhs:
                                locator src_len
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                return
                                  value false
                      expr_stmt (value)
                        if
                          cond:
                            binop !=
                              lhs:
                                index
                                  value:
                                    select .src [unknown]
                                      object:
                                        locator self
                                  index:
                                    binop +
                                      lhs:
                                        locator pos
                                      rhs:
                                        locator offset
                              rhs:
                                index
                                  value:
                                    locator literal
                                  index:
                                    range [exclusive]
                                      start:
                                        locator offset
                                      end:
                                        binop +
                                          lhs:
                                            locator offset
                                          rhs:
                                            value 1
                          then:
                            block (1 stmt)
                              expr_stmt ;
                                return
                                  value false
                      expr_stmt ;
                        assign
                          target:
                            locator idx
                          value:
                            binop +
                              lhs:
                                locator idx
                              rhs:
                                value 1
              expr_stmt (value)
                value true
          pub fn peek(&self) -> &Expr(str) : fn() -> &string
            block (2 stmts)
              expr_stmt (value)
                if
                  cond:
                    invoke
                      target: self.is_eof
                  then:
                    block (1 stmt)
                      expr_stmt ;
                        return
                          value ""
              expr_stmt (value)
                index
                  value:
                    select .src [unknown]
                      object:
                        locator self
                  index:
                    cast -> Expr(usize)
                      select .pos [unknown]
                        object:
                          locator self
          pub fn is_eof(&self) -> Expr(bool) : fn() -> bool
            block (3 stmts)
              let pos
                init:
                  cast -> Expr(i64)
                    select .pos [unknown]
                      object:
                        locator self
              let len
                init:
                  cast -> Expr(i64)
                    invoke
                      target: self.src.len
              expr_stmt (value)
                binop >=
                  lhs:
                    locator pos
                  rhs:
                    locator len
        }
        pub fn is_number_char(ch: &Expr(str)) -> Expr(bool) : fn(&string) -> bool
          block (1 stmt)
            expr_stmt (value)
              match
                case #0
                  cond:
                    value true
                  body:
                    value true
                case #1
                  cond:
                    value true
                  body:
                    value true
                case #2
                  cond:
                    value true
                  body:
                    value true
                case #3
                  cond:
                    value true
                  body:
                    value true
                case #4
                  cond:
                    value true
                  body:
                    value true
                case #5
                  cond:
                    value true
                  body:
                    value true
                case #6
                  cond:
                    value true
                  body:
                    value true
                case #7
                  cond:
                    value true
                  body:
                    value true
                case #8
                  cond:
                    value true
                  body:
                    value true
                case #9
                  cond:
                    value true
                  body:
                    value true
                case #10
                  cond:
                    value true
                  body:
                    value true
                case #11
                  cond:
                    value true
                  body:
                    value true
                case #12
                  cond:
                    value true
                  body:
                    value true
                case #13
                  cond:
                    value true
                  body:
                    value true
                case #14
                  cond:
                    value true
                  body:
                    value true
                case #15
                  cond:
                    value true
                  body:
                    value false
      }
      pub module intrinsics {
        pub [attrs] const fn create_struct(name: &Expr(str)) -> type : fn(&string) -> type
          block (1 stmt)
            expr_stmt (value)
              intrinsic compile_error
                args:
                  value "create_struct is a compiler intrinsic"
                kwargs: []
        pub [attrs] const fn addfield(ty: type, name: &Expr(str), field_ty: type) -> type : fn(type, &string, type) -> type
          block (1 stmt)
            expr_stmt (value)
              intrinsic compile_error
                args:
                  value "addfield is a compiler intrinsic"
                kwargs: []
      }
      pub module meta {
        pub struct TypeBuilder {
          ty: type
        }
        impl TypeBuilder {
          pub const fn new(name: &Expr(str)) -> Expr(TypeBuilder) : fn(&string) -> TypeBuilder{ty: type}
            block (1 stmt)
              expr_stmt (value)
                struct TypeBuilder
                  ty:
                    intrinsic create_struct
                      args:
                        locator name
                      kwargs: []
          pub const fn from(ty: type) -> Expr(TypeBuilder) : fn(type) -> TypeBuilder{ty: type}
            block (1 stmt)
              expr_stmt (value)
                struct TypeBuilder
                  ty:
                    locator ty
          pub const fn with_field(self, name: &Expr(str), field_ty: type) -> Expr(TypeBuilder) : fn(&string, type) -> TypeBuilder{ty: type}
            block (2 stmts)
              let ty
                init:
                  intrinsic add_field
                    args:
                      select .ty [unknown]
                        object:
                          locator self
                      locator name
                      locator field_ty
                    kwargs: []
              expr_stmt (value)
                struct TypeBuilder
                  ty:
                    locator ty
          pub const fn build(self) -> type : fn() -> type
            block (1 stmt)
              expr_stmt (value)
                select .ty [unknown]
                  object:
                    locator self
        }
      }
      pub module net {
        pub module addr {
          pub struct SocketAddr {
          }
        }
        pub module tcp {
          pub import std::net::addr::SocketAddr
          pub struct TcpStream {
          }
          impl TcpStream {
            pub fn connect(addr: Expr(SocketAddr)) -> Expr(TcpStream) : fn(SocketAddr) -> TcpStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn shutdown(&mut self) -> () : fn() -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct TcpListener {
          }
          impl TcpListener {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(TcpListener) : fn(SocketAddr) -> TcpListener
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn accept(&mut self) -> Expr(TcpStream) : fn() -> TcpStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
        pub module udp {
          pub import std::net::addr::SocketAddr
          pub struct UdpSocket {
          }
          impl UdpSocket {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(UdpSocket) : fn(SocketAddr) -> UdpSocket
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn send_to(&mut self, buf: &[Expr(u8)], addr: Expr(SocketAddr)) -> Expr(i64) : fn(&[u8], SocketAddr) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn recv_from(&mut self, buf: &mut [Expr(u8)]) -> (Expr(i64), Expr(SocketAddr)) : fn(&[u8]) -> (i64, SocketAddr)
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
        pub module tls {
          pub import std::net::tcp::TcpStream
          pub struct TlsConnector {
          }
          impl TlsConnector {
            pub fn connect(&self, domain: &Expr(str), stream: Expr(TcpStream)) -> Expr(TlsStream) : fn(&string, TcpStream) -> TlsStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct TlsAcceptor {
          }
          impl TlsAcceptor {
            pub fn accept(&self, stream: Expr(TcpStream)) -> Expr(TlsStream) : fn(TcpStream) -> TlsStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct TlsStream {
          }
          impl TlsStream {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn shutdown(&mut self) -> () : fn() -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
        pub module http {
          pub struct HttpClient {
          }
          impl HttpClient {
            pub fn send(&self, request: Expr(HttpRequest)) -> Expr(HttpResponse) : fn(HttpRequest) -> HttpResponse
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct HttpRequest {
          }
          impl HttpRequest {
            pub fn get(url: &Expr(str)) -> Expr(HttpRequest) : fn(&string) -> HttpRequest
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
            pub fn post(url: &Expr(str), body: &[Expr(u8)]) -> Expr(HttpRequest) : fn(&string, &[u8]) -> HttpRequest
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
          }
          pub struct HttpResponse {
          }
          impl HttpResponse {
            pub fn status(&self) -> Expr(i64) : fn() -> i64
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
            pub fn body(&self) -> &[Expr(u8)] : fn() -> &[u8]
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
          }
        }
        pub module ws {
          pub struct WsStream {
          }
          impl WsStream {
            pub fn connect(url: &Expr(str)) -> Expr(WsStream) : fn(&string) -> WsStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn send(&mut self, message: Expr(WsMessage)) -> () : fn(WsMessage) -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn recv(&mut self) -> Expr(WsMessage) : fn() -> WsMessage
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct WsMessage {
          }
          impl WsMessage {
            pub fn text(value: &Expr(str)) -> Expr(WsMessage) : fn(&string) -> WsMessage
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
            pub fn binary(value: &[Expr(u8)]) -> Expr(WsMessage) : fn(&[u8]) -> WsMessage
              block (1 stmt)
                expr_stmt (value)
                  loop
                    block (0 stmts)
          }
        }
        pub module quic {
          pub import std::net::addr::SocketAddr
          pub struct QuicConnection {
          }
          impl QuicConnection {
            pub fn connect(addr: Expr(SocketAddr), server_name: &Expr(str)) -> Expr(QuicConnection) : fn(SocketAddr, &string) -> QuicConnection
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn open_bi(&mut self) -> Expr(QuicStream) : fn() -> QuicStream
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct QuicListener {
          }
          impl QuicListener {
            pub fn bind(addr: Expr(SocketAddr)) -> Expr(QuicListener) : fn(SocketAddr) -> QuicListener
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn accept(&mut self) -> Expr(QuicConnection) : fn() -> QuicConnection
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
          pub struct QuicStream {
          }
          impl QuicStream {
            pub fn read(&mut self, buf: &mut [Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn write(&mut self, buf: &[Expr(u8)]) -> Expr(i64) : fn(&[u8]) -> i64
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
            pub fn finish(&mut self) -> () : fn() -> ()
              async
                block (1 stmt)
                  expr_stmt (value)
                    loop
                      block (0 stmts)
          }
        }
      }
      pub module proc_macro {
        pub enum Delimiter {
          Parenthesis: ()
          Brace: ()
          Bracket: ()
        }
        pub struct Group {
          delimiter: Expr(Delimiter)
          tokens: Vec<Expr(TokenTree)>
        }
        pub struct Ident {
          text: Expr(str)
        }
        pub struct Punct {
          text: Expr(str)
        }
        pub struct Literal {
          text: Expr(str)
        }
        pub enum TokenTree {
          Token: (Expr(str))
          Group: (Expr(Group))
        }
        pub struct TokenStream {
        }
        pub const fn token_stream_from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream
          block (1 stmt)
            expr_stmt (value)
              intrinsic token_stream_from_str
                args:
                  locator text
                kwargs: []
        pub const fn token_stream_to_string(stream: Expr(TokenStream)) -> Expr(str) : fn(TokenStream) -> string
          block (1 stmt)
            expr_stmt (value)
              intrinsic token_stream_to_string
                args:
                  locator stream
                kwargs: []
        impl TokenStream {
          pub fn from_str(text: Expr(str)) -> Expr(TokenStream) : fn(string) -> TokenStream
            block (1 stmt)
              expr_stmt (value)
                intrinsic token_stream_from_str
                  args:
                    locator text
                  kwargs: []
          pub fn to_string(self) -> Expr(str) : fn() -> string
            block (1 stmt)
              expr_stmt (value)
                intrinsic token_stream_to_string
                  args:
                    locator self
                  kwargs: []
        }
      }
      pub module task {
        pub struct Future {
          handle: Expr(any)
        }
        pub struct Task {
          handle: Expr(any)
        }
        pub fn<T> spawn(fut: Expr(any)) -> Expr(Task<Expr(Expr { ty: None, span: None, kind: Name(Ident(Ident { name: "T" })) })>) : fn<T>(any) -> Task{handle: Expr(any)}
          block (1 stmt)
            expr_stmt (value)
              struct Task
                handle:
                  intrinsic spawn
                    args:
                      locator fut
                    kwargs: []
        expr_item
          value ()
        expr_item
          value ()
      }
      pub module test {
        pub struct TestCase {
          name: Expr(str)
          run: fn() -> ()
        }
        pub const REGISTRY: Vec<TestCase{name: Expr(str), run: fn() -> ()}>
          value [0 values]
        pub struct TestReport {
          total: Expr(i64)
          passed: Expr(i64)
          failed: Expr(i64)
        }
        pub fn run_tests() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (8 stmts)
            let tests: Vec<Expr(TestCase)>
              init:
                value [0 values]
            let mut passed
              init:
                value 0
            let mut failed
              init:
                value 0
            let mut idx
              init:
                value 0
            expr_stmt (value)
              while
                cond:
                  binop <
                    lhs:
                      locator idx
                    rhs:
                      invoke
                        target: tests.len
                body:
                  block (4 stmts)
                    let test: Expr(TestCase)
                      init:
                        index
                          value:
                            locator tests
                          index:
                            locator idx
                    let ok
                      init:
                        intrinsic catch_unwind
                          args:
                            select .run [unknown]
                              object:
                                locator test
                          kwargs: []
                    expr_stmt (value)
                      if
                        cond:
                          locator ok
                        then:
                          block (2 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator passed
                                value:
                                  binop +
                                    lhs:
                                      locator passed
                                    rhs:
                                      value 1
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... ok"
                                  select .name [unknown]
                                    object:
                                      locator test
                                kwargs: []
                        else:
                          block (2 stmts)
                            expr_stmt ;
                              assign
                                target:
                                  locator failed
                                value:
                                  binop +
                                    lhs:
                                      locator failed
                                    rhs:
                                      value 1
                            expr_stmt ;
                              intrinsic println
                                args:
                                  format_string "  {} ... FAILED"
                                  select .name [unknown]
                                    object:
                                      locator test
                                kwargs: []
                    expr_stmt ;
                      assign
                        target:
                          locator idx
                        value:
                          binop +
                            lhs:
                              locator idx
                            rhs:
                              value 1
            let total
              init:
                binop +
                  lhs:
                    locator passed
                  rhs:
                    locator failed
            expr_stmt ;
              intrinsic println
                args:
                  format_string "test result: {} passed; {} failed; {} total"
                  locator passed
                  locator failed
                  locator total
                kwargs: []
            expr_stmt (value)
              struct TestReport
                total:
                  locator total
                passed:
                  locator passed
                failed:
                  locator failed
        pub fn run() -> Expr(TestReport) : fn() -> TestReport{total: Expr(i64), passed: Expr(i64), failed: Expr(i64)}
          block (1 stmt)
            expr_stmt (value)
              invoke
                target: run_tests
      }
      pub module time {
        pub [attrs] fn now() -> Expr(f64) : fn() -> f64
          block (1 stmt)
            expr_stmt (value)
              intrinsic time_now
                args: []
                kwargs: []
        pub fn sleep(seconds: Expr(f64)) -> () : fn(f64) -> ()
          block (1 stmt)
            expr_stmt (value)
              intrinsic sleep
                args:
                  locator seconds
                kwargs: []
      }
    }
    pub type SockAddrIn = [Expr(u8); 16]
    pub module libc {
      declare extern "C" fn socket(domain: Expr(i32), sock_type: Expr(i32), protocol: Expr(i32)) -> Expr(i32) : fn(Expr(i32), Expr(i32), Expr(i32)) -> Expr(i32)
      declare extern "C" fn setsockopt(fd: Expr(i32), level: Expr(i32), optname: Expr(i32), optval: *const Expr(u8), optlen: Expr(u32)) -> Expr(i32) : fn(Expr(i32), Expr(i32), Expr(i32), *const Expr(u8), Expr(u32)) -> Expr(i32)
      declare extern "C" fn bind(fd: Expr(i32), addr: *const Expr(u8), addrlen: Expr(u32)) -> Expr(i32) : fn(Expr(i32), *const Expr(u8), Expr(u32)) -> Expr(i32)
      declare extern "C" fn listen(fd: Expr(i32), backlog: Expr(i32)) -> Expr(i32) : fn(Expr(i32), Expr(i32)) -> Expr(i32)
      declare extern "C" fn accept(fd: Expr(i32), addr: *mut Expr(u8), addrlen: *mut Expr(u32)) -> Expr(i32) : fn(Expr(i32), *mut Expr(u8), *mut Expr(u32)) -> Expr(i32)
      declare extern "C" fn write(fd: Expr(i32), buf: &Expr(std::ffi::CStr), count: Expr(usize)) -> Expr(i64) : fn(Expr(i32), &Expr(std::ffi::CStr), Expr(usize)) -> Expr(i64)
      declare extern "C" fn strlen(s: &Expr(std::ffi::CStr)) -> Expr(usize) : fn(&Expr(std::ffi::CStr)) -> Expr(usize)
      declare extern "C" fn perror(s: &Expr(std::ffi::CStr)) : fn(&Expr(std::ffi::CStr)) -> ()
      declare extern "C" fn close(fd: Expr(i32)) -> Expr(i32) : fn(Expr(i32)) -> Expr(i32)
    }
    pub const AF_INET: i32
      value 2
    pub const SOCK_STREAM: i32
      value 1
    pub const SOL_SOCKET: i32
      value 1
    pub const SO_REUSEADDR: i32
      value 2
    pub const SOCKADDR_LEN: u32
      value 16
    pub const RESPONSE: &string
      value "HTTP/1.1 200 OK\r\nContent-Length: 12\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\nHello world\n"
    pub const SOCKET_ERR: &string
      value "socket"
    pub const BIND_ERR: &string
      value "bind"
    pub const LISTEN_ERR: &string
      value "listen"
    pub const ACCEPT_ERR: &string
      value "accept"
    pub [attrs] fn make_addr(port: Expr(u16)) -> Expr(SockAddrIn) : fn(u16) -> any
      block (1 stmt)
        expr_stmt (value)
          array (16 values)
            cast -> Expr(u8)
              value 16
            cast -> Expr(u8)
              value 2
            cast -> Expr(u8)
              binop &
                lhs:
                  binop >>
                    lhs:
                      locator port
                    rhs:
                      value 8
                rhs:
                  value 255
            cast -> Expr(u8)
              binop &
                lhs:
                  locator port
                rhs:
                  value 255
            value 0
            value 0
            value 0
            value 0
            value 0
            value 0
            value 0
            value 0
            value 0
            value 0
            value 0
            value 0
    pub [attrs] fn main() -> () : fn() -> ()
      block (16 stmts)
        let server_fd
          init:
            cast -> Expr(i32)
              invoke
                target: libc::socket
                args:
                  value 2
                  value 1
                  value 0
        expr_stmt ;
          intrinsic println
            args:
              format_string "socket fd: {}"
              locator server_fd
            kwargs: []
        expr_stmt (value)
          if
            cond:
              binop <
                lhs:
                  locator server_fd
                rhs:
                  cast -> Expr(i32)
                    value 0
            then:
              block (2 stmts)
                expr_stmt ;
                  invoke
                    target: libc::perror
                    args:
                      value "socket"
                expr_stmt ;
                  return
        let reuse: Expr(i32)
          init:
            value 1
        let reuse_ptr
          init:
            cast -> *const Expr(i32)
              reference (mutable: unspecified)
                locator reuse
        let _
          init:
            invoke
              target: libc::setsockopt
              args:
                locator server_fd
                value 1
                value 2
                cast -> *const Expr(u8)
                  locator reuse_ptr
                value 4
        let mut addr
          init:
            invoke
              target: make_addr
              args:
                cast -> Expr(u16)
                  value 8080
        let addr_ptr
          init:
            cast -> *mut Expr(SockAddrIn)
              reference (mutable: mut)
                locator addr
        let bind_rc
          init:
            invoke
              target: libc::bind
              args:
                locator server_fd
                cast -> *const Expr(u8)
                  locator addr_ptr
                value 16
        expr_stmt ;
          intrinsic println
            args:
              format_string "bind rc: {}"
              locator bind_rc
            kwargs: []
        expr_stmt (value)
          if
            cond:
              binop !=
                lhs:
                  locator bind_rc
                rhs:
                  cast -> Expr(i32)
                    value 0
            then:
              block (3 stmts)
                expr_stmt ;
                  invoke
                    target: libc::perror
                    args:
                      value "bind"
                expr_stmt ;
                  invoke
                    target: libc::close
                    args:
                      locator server_fd
                expr_stmt ;
                  return
        let listen_rc
          init:
            invoke
              target: libc::listen
              args:
                locator server_fd
                value 16
        expr_stmt ;
          intrinsic println
            args:
              format_string "listen rc: {}"
              locator listen_rc
            kwargs: []
        expr_stmt (value)
          if
            cond:
              binop !=
                lhs:
                  locator listen_rc
                rhs:
                  cast -> Expr(i32)
                    value 0
            then:
              block (1 stmt)
                expr_stmt ;
                  invoke
                    target: libc::perror
                    args:
                      value "listen"
        expr_stmt ;
          intrinsic println
            args:
              format_string "listening on 0.0.0.0:8080"
            kwargs: []
        expr_stmt (value)
          loop
            block (9 stmts)
              let mut client_addr
                init:
                  invoke
                    target: make_addr
                    args:
                      cast -> Expr(u16)
                        value 0
              let mut client_len: Expr(u32)
                init:
                  value 16
              let client_addr_ptr
                init:
                  cast -> *mut Expr(SockAddrIn)
                    reference (mutable: mut)
                      locator client_addr
              let client_len_ptr
                init:
                  cast -> *mut Expr(u32)
                    reference (mutable: mut)
                      locator client_len
              let client_fd
                init:
                  cast -> Expr(i32)
                    invoke
                      target: libc::accept
                      args:
                        locator server_fd
                        cast -> *mut Expr(u8)
                          locator client_addr_ptr
                        locator client_len_ptr
              expr_stmt (value)
                if
                  cond:
                    binop <
                      lhs:
                        locator client_fd
                      rhs:
                        cast -> Expr(i32)
                          value 0
                  then:
                    block (2 stmts)
                      expr_stmt ;
                        invoke
                          target: libc::perror
                          args:
                            value "accept"
                      expr_stmt ;
                        continue
              let response_len
                init:
                  invoke
                    target: libc::strlen
                    args:
                      value "HTTP/1.1 200 OK\r\nContent-Length: 12\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\nHello world\n"
              let _
                init:
                  invoke
                    target: libc::write
                    args:
                      locator client_fd
                      value "HTTP/1.1 200 OK\r\nContent-Length: 12\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\nHello world\n"
                      locator response_len
              expr_stmt ;
                invoke
                  target: libc::close
                  args:
                    locator client_fd
}
