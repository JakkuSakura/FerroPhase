ast::File {
  items:
    pub fn factorial(n: Expr(i64)) -> Expr(i64) : fn(i64) -> i64 : fn(i64) -> i64
      block (4 stmts) : i64
        let mut result
          init:
            value 1 : i64
        let mut i
          init:
            value 1 : i64
        expr_stmt (value)
          while : ()
            cond:
              binop <= : bool
                lhs:
                  locator i : i64
                rhs:
                  locator n : i64
            body:
              block (2 stmts) : ()
                expr_stmt ;
                  assign : i64
                    target:
                      locator result : i64
                    value:
                      binop * : i64
                        lhs:
                          locator result : i64
                        rhs:
                          locator i : i64
                expr_stmt ;
                  assign : i64
                    target:
                      locator i : i64
                    value:
                      binop + : i64
                        lhs:
                          locator i : i64
                        rhs:
                          value 1 : i64
        expr_stmt (value)
          locator result : i64
    pub fn sum_range(start: Expr(i64), end: Expr(i64)) -> Expr(i64) : fn(i64, i64) -> i64 : fn(i64, i64) -> i64
      block (3 stmts) : i64
        let mut sum
          init:
            value 0 : i64
        expr_stmt (value)
          for : ()
            iter:
              range [exclusive] : Vec<i64>
                start:
                  locator start : i64
                end:
                  locator end : i64
            body:
              block (1 stmt) : ()
                expr_stmt ;
                  assign : i64
                    target:
                      locator sum : i64
                    value:
                      binop + : i64
                        lhs:
                          locator sum : i64
                        rhs:
                          locator i : i64
        expr_stmt (value)
          locator sum : i64
    pub fn find_first_divisor(n: Expr(i64)) -> Expr(i64) : fn(i64) -> i64 : fn(i64) -> i64
      block (2 stmts) : i64
        let mut i
          init:
            value 2 : i64
        expr_stmt (value)
          loop : i64
            block (3 stmts) : ()
              expr_stmt (value)
                if : ()
                  cond:
                    binop > : bool
                      lhs:
                        binop * : i64
                          lhs:
                            locator i : i64
                          rhs:
                            locator i : i64
                      rhs:
                        locator n : i64
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        intrinsic break : i64
                          args:
                            locator n : i64
              expr_stmt (value)
                if : ()
                  cond:
                    binop == : bool
                      lhs:
                        binop % : i64
                          lhs:
                            locator n : i64
                          rhs:
                            locator i : i64
                      rhs:
                        value 0 : i64
                  then:
                    block (1 stmt) : ()
                      expr_stmt ;
                        intrinsic break : i64
                          args:
                            locator i : i64
              expr_stmt ;
                assign : i64
                  target:
                    locator i : i64
                  value:
                    binop + : i64
                      lhs:
                        locator i : i64
                      rhs:
                        value 1 : i64
    pub fn sum_even_numbers(limit: Expr(i64)) -> Expr(i64) : fn(i64) -> i64 : fn(i64) -> i64
      block (4 stmts) : i64
        let mut sum
          init:
            value 0 : i64
        let mut i
          init:
            value 0 : i64
        expr_stmt (value)
          while : ()
            cond:
              binop < : bool
                lhs:
                  locator i : i64
                rhs:
                  locator limit : i64
            body:
              block (3 stmts) : ()
                expr_stmt ;
                  assign : i64
                    target:
                      locator i : i64
                    value:
                      binop + : i64
                        lhs:
                          locator i : i64
                        rhs:
                          value 1 : i64
                expr_stmt (value)
                  if : ()
                    cond:
                      binop != : bool
                        lhs:
                          binop % : i64
                            lhs:
                              locator i : i64
                            rhs:
                              value 2 : i64
                        rhs:
                          value 0 : i64
                    then:
                      block (1 stmt) : ()
                        expr_stmt ;
                          intrinsic continue : !
                            args: []
                expr_stmt ;
                  assign : i64
                    target:
                      locator sum : i64
                    value:
                      binop + : i64
                        lhs:
                          locator sum : i64
                        rhs:
                          locator i : i64
        expr_stmt (value)
          locator sum : i64
    pub fn main() -> () : fn() -> () : fn() -> ()
      block (25 stmts) : ()
        expr_stmt ;
          intrinsic println : ()
            template: "ðŸ“˜ Tutorial: 13_loops.fp"
        expr_stmt ;
          intrinsic println : ()
            template: "ðŸ§­ Focus: Loop constructs: while, for, and loop."
        expr_stmt ;
          intrinsic println : ()
            template: "ðŸ§ª What to look for: labeled outputs below"
        expr_stmt ;
          intrinsic println : ()
            template: "âœ… Expectation: outputs match labels"
        expr_stmt ;
          intrinsic println : ()
            template: ""
        expr_stmt ;
          intrinsic println : ()
            template: "=== Loop Constructs ===\n"
        expr_stmt ;
          intrinsic println : ()
            template: "1. While loop - factorial:"
        expr_stmt ;
          intrinsic println : ()
            template: "  5! = {}" factorial(5)
        expr_stmt ;
          intrinsic println : ()
            template: "  7! = {}" factorial(7)
        expr_stmt ;
          intrinsic println : ()
            template: "\n2. For loop - sum range:"
        expr_stmt ;
          intrinsic println : ()
            template: "  sum(1..10) = {}" sum_range(1, 10)
        expr_stmt ;
          intrinsic println : ()
            template: "  sum(5..15) = {}" sum_range(5, 15)
        expr_stmt ;
          intrinsic println : ()
            template: "\n3. Loop with break expression:"
        expr_stmt ;
          intrinsic println : ()
            template: "  First divisor of 24: {}" find_first_divisor(24)
        expr_stmt ;
          intrinsic println : ()
            template: "  First divisor of 17: {}" find_first_divisor(17)
        expr_stmt ;
          intrinsic println : ()
            template: "\n4. Loop with continue:"
        expr_stmt ;
          intrinsic println : ()
            template: "  Sum of even numbers < 10: {}" sum_even_numbers(10)
        expr_stmt ;
          intrinsic println : ()
            template: "\n5. Nested loops:"
        let mut count
          init:
            value 0 : i64
        expr_stmt (value)
          for : ()
            iter:
              range [exclusive] : Vec<i64>
                start:
                  value 1 : i64
                end:
                  value 4 : i64
            body:
              block (1 stmt) : ()
                expr_stmt (value)
                  for : ()
                    iter:
                      range [exclusive] : Vec<i64>
                        start:
                          value 1 : i64
                        end:
                          value 4 : i64
                    body:
                      block (2 stmts) : ()
                        expr_stmt ;
                          assign : i64
                            target:
                              locator count : i64
                            value:
                              binop + : i64
                                lhs:
                                  locator count : i64
                                rhs:
                                  value 1 : i64
                        expr_stmt (value)
                          if : ()
                            cond:
                              binop == : bool
                                lhs:
                                  locator i : i64
                                rhs:
                                  locator j : i64
                            then:
                              block (1 stmt) : ()
                                expr_stmt ;
                                  intrinsic print : ()
                                    template: "[{}] " i
        expr_stmt ;
          intrinsic println : ()
            template: "\n  Iterations: {}" count
        expr_stmt ;
          intrinsic println : ()
            template: "\n6. Compile-time iteration (simulated):"
        pub const FACTORIAL_CONST: i64 : i64
          value 120 : i64
        expr_stmt ;
          intrinsic println : ()
            template: "  const 5! = {}" FACTORIAL_CONST
        expr_stmt ;
          intrinsic println : ()
            template: "\nâœ“ Loop constructs demonstrated!"
}
